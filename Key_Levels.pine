// MIT License
//
// Copyright (c) 2025 User-3090
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//@version=6
indicator("VT Pro", overlay=true, max_lines_count=500, max_boxes_count=100, max_labels_count=200)

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIME CONSTANTS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const int MS_PER_MINUTE = 60000
const int MS_PER_HOUR = 3600000
const int MS_PER_DAY = 86400000
const int TWO_DAYS_MS = 172800000
const int MAX_LINE_DISTANCE = 200

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS â€” PREMIUM PANEL (GROUPING/ORDER ONLY; RUNTIME LOGIC UNCHANGED)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enableSessionFeatures = input.bool(true, "Enable Session Features", group="ğŸ•’ Sessions â€¢ General", tooltip="Main control: enables all session-based VWAP anchors (daily/weekly/monthly/yearly)")

showAnchorLabels = input.bool(true, "Enable Anchor Labels", group="ğŸ•’ Sessions â€¢ General", tooltip="Show labels on anchor VWAP lines (W1, M1, Y1, etc)")
compactLabels = input.bool(true, "Compact Anchor Labels", group="ğŸ•’ Sessions â€¢ General", tooltip="Short format (W1, M2) vs full format (Week 52, Month Jan)")
anchorLabelSize = input.string("Normal", "Anchor Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="ğŸ•’ Sessions â€¢ General", tooltip="Text size for all anchor labels")
longTermAnchorSession = input.string("Auto", "Primary Anchor Session", options=["Auto", "Globex", "Sydney", "Tokyo", "London", "New York"], group="ğŸ•’ Sessions â€¢ General", tooltip="Main session for daily anchors AND calendar reference for weekly/monthly/yearly anchors. Auto = NY for stocks, Globex for futures")
rthOnlyForStocks = input.bool(true, "RTH Only for NY Sessions (Stocks)", group="ğŸ•’ Sessions â€¢ General", tooltip="NY session uses only RTH (9:30-16:00 ET). Enable to track RTH levels on extended hours charts")
rthOnlyForIndices = input.bool(false, "RTH Only for NY Sessions (Indices)", group="ğŸ•’ Sessions â€¢ General", tooltip="NY session uses only RTH (9:30-16:00 ET). Enable to track RTH levels on extended hours charts")

showDailySessionVWAPs = input.bool(true, "Enable Daily VWAP Anchors", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Main control: show session-based daily VWAP anchors (Globex/Sydney/Tokyo/London/NY)")

primarySessionMaxTF = input.string("30m", "Max Timeframe (Primary)", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Hide primary session daily anchors above this timeframe (Primary = session selected above)")
otherSessionsMaxTF = input.string("5m", "Max Timeframe (Other)", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Hide non-primary session daily anchors above this timeframe")

sessionVWAPLineStyleInput = input.string("Dotted", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Visual style for all session VWAP lines")
sessionVWAPLineWidth = input.int(3, "Line Width", minval=1, maxval=5, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Line thickness for all session VWAP lines (1-5)")
sessionVWAPLineStyle = sessionVWAPLineStyleInput == "Solid" ? plot.linestyle_solid : sessionVWAPLineStyleInput == "Dashed" ? plot.linestyle_dashed : plot.linestyle_dotted

// Stock-specific session settings
enableGlobexStock = input.bool(false, "Globex", inline="SESS_GLX_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Globex: 18:00-17:00 ET (futures extended hours)")
globexVWAPCountStock = input.int(2, "History", inline="SESS_GLX_STK", minval=1, maxval=5, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Number of Globex sessions to show (1-5, 1=current only)")
colorGlobexStock = input.color(#2962ff, "", inline="SESS_GLX_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="First color (left) is the start of the gradient, second color (right) is the end")
colorGlobexStockEnd = input.color(#1cc1ff, "", inline="SESS_GLX_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Gradient end color (older sessions)")

enableSydneyStock = input.bool(false, "Sydney", inline="SESS_SYD_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Sydney: 17:00-01:00 ET")
sydneyVWAPCountStock = input.int(1, "History", inline="SESS_SYD_STK", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Number of Sydney sessions to show (current only)")
colorSydneyStock = input.color(#9c27b0, "", inline="SESS_SYD_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Color for Sydney VWAP line")
colorSydneyStockEnd = input.color(#9c27b0, "", inline="SESS_SYD_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Gradient end color (older sessions)")

enableTokyoStock = input.bool(false, "Tokyo", inline="SESS_TKY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Tokyo: 19:00-04:00 ET")
tokyoVWAPCountStock = input.int(1, "History", inline="SESS_TKY_STK", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Number of Tokyo sessions to show (current only)")
colorTokyoStock = input.color(#ff0000, "", inline="SESS_TKY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Color for Tokyo VWAP line")
colorTokyoStockEnd = input.color(#ff0000, "", inline="SESS_TKY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Gradient end color (older sessions)")

enableLondonStock = input.bool(false, "London", inline="SESS_LON_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="London: 03:00-11:30 ET")
londonVWAPCountStock = input.int(1, "History", inline="SESS_LON_STK", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Number of London sessions to show (current only)")
colorLondonStock = input.color(#ff9800, "", inline="SESS_LON_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Color for London VWAP line")
colorLondonStockEnd = input.color(#ff9800, "", inline="SESS_LON_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Gradient end color (older sessions)")

enableNewYorkStock = input.bool(true, "New York", inline="SESS_NY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="New York: 09:30-16:00 ET (RTH) or full session if RTH filter disabled")
nyVWAPCountStock = input.int(5, "History", inline="SESS_NY_STK", minval=1, maxval=5, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Number of NY sessions to show (1-5, 1=current only)")
colorNewYorkStock = input.color(#4caf50, "", inline="SESS_NY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Color for NY VWAP line (gradient start)")
colorNewYorkStockEnd = input.color(#e68900, "", inline="SESS_NY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Gradient end color (older sessions)")

// Non-stock (futures, crypto, etc.) session settings
enableGlobex = input.bool(true, "Globex", inline="SESS_GLX", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Globex: 18:00-17:00 ET (futures extended hours)")
globexVWAPCount = input.int(5, "History", inline="SESS_GLX", minval=1, maxval=5, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Number of Globex sessions to show (1-5, 1=current only)")
colorGlobex = input.color(#4caf50, "", inline="SESS_GLX", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Color for Globex VWAP line (gradient start)")
colorGlobexEnd = input.color(#e68900, "", inline="SESS_GLX", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Gradient end color (older sessions)")

enableSydney = input.bool(false, "Sydney", inline="SESS_SYD", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Sydney: 17:00-01:00 ET")
sydneyVWAPCount = input.int(1, "History", inline="SESS_SYD", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Number of Sydney sessions to show (current only)")
colorSydney = input.color(#9c27b0, "", inline="SESS_SYD", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Color for Sydney VWAP line")
colorSydneyEnd = input.color(#9c27b0, "", inline="SESS_SYD", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Gradient end color (older sessions)")

enableTokyo = input.bool(false, "Tokyo", inline="SESS_TKY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Tokyo: 19:00-04:00 ET")
tokyoVWAPCount = input.int(1, "History", inline="SESS_TKY", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Number of Tokyo sessions to show (current only)")
colorTokyo = input.color(#ff0000, "", inline="SESS_TKY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Color for Tokyo VWAP line")
colorTokyoEnd = input.color(#ff0000, "", inline="SESS_TKY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Gradient end color (older sessions)")

enableLondon = input.bool(true, "London", inline="SESS_LON", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="London: 03:00-11:30 ET")
londonVWAPCount = input.int(1, "History", inline="SESS_LON", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Number of London sessions to show (current only)")
colorLondon = input.color(#ff9800, "", inline="SESS_LON", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Color for London VWAP line")
colorLondonEnd = input.color(#ff9800, "", inline="SESS_LON", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Gradient end color (older sessions)")

enableNewYork = input.bool(true, "New York", inline="SESS_NY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="New York: 09:30-16:00 ET (RTH) or full session if RTH filter disabled")
nyVWAPCount = input.int(2, "History", inline="SESS_NY", minval=1, maxval=5, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Number of NY sessions to show (1-5, 1=current only)")
colorNewYork = input.color(#2962ff, "", inline="SESS_NY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Color for NY VWAP line (gradient start)")
colorNewYorkEnd = input.color(#1cc1ff, "", inline="SESS_NY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Gradient end color (older sessions)")

// Select settings based on symbol type
bool isStock = syminfo.type == "stock"
bool enableGlobexActive = isStock ? enableGlobexStock : enableGlobex
color colorGlobexActive = isStock ? colorGlobexStock : colorGlobex
color colorGlobexActiveEnd = isStock ? colorGlobexStockEnd : colorGlobexEnd
int globexVWAPCountActive = isStock ? globexVWAPCountStock : globexVWAPCount
bool enableSydneyActive = isStock ? enableSydneyStock : enableSydney
color colorSydneyActive = isStock ? colorSydneyStock : colorSydney
color colorSydneyActiveEnd = isStock ? colorSydneyStockEnd : colorSydneyEnd
int sydneyVWAPCountActive = isStock ? sydneyVWAPCountStock : sydneyVWAPCount
bool enableTokyoActive = isStock ? enableTokyoStock : enableTokyo
color colorTokyoActive = isStock ? colorTokyoStock : colorTokyo
color colorTokyoActiveEnd = isStock ? colorTokyoStockEnd : colorTokyoEnd
int tokyoVWAPCountActive = isStock ? tokyoVWAPCountStock : tokyoVWAPCount
bool enableLondonActive = isStock ? enableLondonStock : enableLondon
color colorLondonActive = isStock ? colorLondonStock : colorLondon
color colorLondonActiveEnd = isStock ? colorLondonStockEnd : colorLondonEnd
int londonVWAPCountActive = isStock ? londonVWAPCountStock : londonVWAPCount
bool enableNewYorkActive = isStock ? enableNewYorkStock : enableNewYork
color colorNewYorkActive = isStock ? colorNewYorkStock : colorNewYork
color colorNewYorkActiveEnd = isStock ? colorNewYorkStockEnd : colorNewYorkEnd
int nyVWAPCountActive = isStock ? nyVWAPCountStock : nyVWAPCount

showWeeklyAnchorVWAP = input.bool(true, "Enable Weekly VWAP Anchor", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="VWAP anchored to first session of each trading week (Monday's primary session)")
weeklyAnchorCount = input.int(6, "History", inline="WK_SET", minval=1, maxval=6, group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Number of weekly anchors to show (1-6, 1=current only)")
weeklyAnchorCountWhenDaily = input.int(6, "History (When Daily Active)", inline="WK_SET2", minval=1, maxval=6, group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Reduced count when daily anchors visible. Example: 6â†’3 on 5m chart, full 6 on 4h chart (keeps chart clean)")
colorWeeklyAnchor = input.color(#b51b00, "", inline="WK_SET", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Color for newest weekly anchor (gradient start)")
colorWeeklyAnchorEnd = input.color(#9c27b0, "", inline="WK_SET", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Gradient end color (older weeks)")
weeklyAnchorMinTimeframe = input.string("None", "Min Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Only show weekly anchors at or above this timeframe")
weeklyAnchorMaxTimeframe = input.string("2h", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Hide weekly anchors above this timeframe")

showMonthlyAnchorVWAP = input.bool(true, "Enable Monthly VWAP Anchor", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="VWAP anchored to first session of each calendar month")
monthlyAnchorCount = input.int(6, "History", inline="MN_SET", minval=1, maxval=6, group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Number of monthly anchors to show (1-6, 1=current only)")
monthlyAnchorCountWhenWeekly = input.int(1, "History (When Weekly Active)", inline="MN_SET2", minval=1, maxval=6, group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Reduced count when weekly anchors visible. Example: 6â†’1 shows only current month with weekly context")
colorMonthlyAnchor = input.color(#2962ff, "", inline="MN_SET", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Color for newest monthly anchor (gradient start)")
colorMonthlyAnchorEnd = input.color(#1cc1ff, "", inline="MN_SET", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Gradient end color (older months)")
monthlyAnchorMinTimeframe = input.string("None", "Min Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Only show monthly anchors at or above this timeframe")
monthlyAnchorMaxTimeframe = input.string("1D", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Hide monthly anchors above this timeframe")

showYearlyAnchorVWAP = input.bool(true, "Enable Yearly VWAP Anchor", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="VWAP anchored to first session of each calendar year")
yearlyAnchorCount = input.int(2, "History", inline="YR_SET", minval=1, maxval=2, group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Number of yearly anchors to show (1-2, 1=current only)")
yearlyAnchorCountWhenMonthly = input.int(2, "History (When Monthly Active)", inline="YR_SET2", minval=1, maxval=2, group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Reduced count when monthly anchors visible. Example: 2â†’1 shows only current year with monthly context")
colorYearlyAnchor = input.color(#000000, "", inline="YR_SET", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Color for newest yearly anchor (gradient start)")
colorYearlyAnchorEnd = input.color(#808080, "", inline="YR_SET", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Gradient end color (older years)")
yearlyAnchorMinTimeframe = input.string("15m", "Min Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W", "1M"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Only show yearly anchors at or above this timeframe")
yearlyAnchorMaxTimeframe = input.string("1W", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W", "1M"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Hide yearly anchors above this timeframe")


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ Levels â€¢ Global Settings
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
globalShowPriceValues = input.bool(false, "Show Prices in Level Labels", group="ğŸ“ Levels â€¢ Global Settings", tooltip="Add price values to level labels. Example: 'PDH (4523.50)' vs 'PDH'")

useATRFilter = input.bool(true, "Hide Distant Levels", group="ğŸ“ Levels â€¢ Global Settings", tooltip="Only show levels within ATR distance of current price")
atrMultiplier = input.float(1.5, "Distance (ATR)", minval=1.0, maxval=10.0, step=0.5, group="ğŸ“ Levels â€¢ Global Settings", tooltip="Only show levels within this many ATRs from price (1.0-10.0)")
atrPeriod = input.int(20, "ATR Period (Days)", minval=1, maxval=500, group="ğŸ“ Levels â€¢ Global Settings", tooltip="Lookback period for ATR calculation in days (1-500)")

globalLabelSize = input.string("Normal", "Level Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="ğŸ“ Levels â€¢ Global Settings", tooltip="Text size for all level labels (PDH, PWH, Open, ORB, IB)")
globalLineLengthBars = input.int(50, "Line Length (Bars)", minval=10, maxval=200, group="ğŸ“ Levels â€¢ Global Settings", tooltip="Max line length when using Fixed Bars Back mode")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ Levels â€¢ Session â€¢ Visibility
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showSessionLevelsInput = input.string("Futures Only", "Enable Session Levels", options=["Always", "Futures Only", "Off"], group="ğŸ“ Levels â€¢ Session â€¢ Visibility", tooltip="Show Open/ORB/IB levels")
sessionLevelsSessionSelect = input.string("New York", "Session", options=["All", "Globex", "Sydney", "Tokyo", "London", "New York"], group="ğŸ“ Levels â€¢ Session â€¢ Visibility", tooltip="Which session to show Open/ORB/IB levels for")
sessionLevelsMaxTimeframe = input.string("5m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ“ Levels â€¢ Session â€¢ Visibility", tooltip="Hide session levels above this timeframe")
sessionLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“ Levels â€¢ Session â€¢ Visibility", tooltip="Visual style for session level lines")
sessionLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ“ Levels â€¢ Session â€¢ Visibility", tooltip="Line thickness for session levels (1-5)")
sessionLineStartMode = input.string("Level Established", "Line Start", options=["Session Open", "Level Established", "Fixed Bars Back"], group="ğŸ“ Levels â€¢ Session â€¢ Visibility", tooltip="When to start drawing lines: session open, when level price is set, or fixed lookback")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ Levels â€¢ Session â€¢ Opening Price
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showOpenPrice = input.bool(true, "Enable Opening Price", group="ğŸ“ Levels â€¢ Session â€¢ Opening Price", tooltip="Show session opening price level")
colorOpenPrice = input.color(#fbbe30, "Color", group="ğŸ“ Levels â€¢ Session â€¢ Opening Price", tooltip="Color for opening price line and label")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showOpenRange = input.bool(true, "Enable Opening Range (ORB)", group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)", tooltip="Show high/low of first X minutes of session")
openRangeLength = input.string("15m", "Length", options=["1m", "5m", "15m", "30m"], group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)", tooltip="Opening range duration (1m/5m/15m/30m)")
colorORH = input.color(#4682b4, "High", inline="SL_ORC", group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)", tooltip="Color for opening range high")
colorORL = input.color(#cd5c5c, "Low", inline="SL_ORC", group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)", tooltip="Color for opening range low")
shadeOpenRange = input.bool(true, "Shade", inline="SL_ORC", group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)", tooltip="Fill area between ORH and ORL")
colorOpenRangeShade = input.color(color.new(color.black, 98), "", inline="SL_ORC", group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)", tooltip="Fill color for opening range box")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showInitialBalance = input.bool(false, "Enable Initial Balance (IB)", group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)", tooltip="Show high/low of first 30-60 minutes of session")
initialBalanceLength = input.string("1h", "Length", options=["30m", "1h"], group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)", tooltip="Initial balance duration (30m/1h)")
colorIBH = input.color(#81ce6f, "High", inline="SL_IBC", group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)", tooltip="Color for initial balance high")
colorIBL = input.color(#e43b38, "Low", inline="SL_IBC", group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)", tooltip="Color for initial balance low")
shadeInitialBalance = input.bool(true, "Shade", inline="SL_IBC", group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)", tooltip="Fill area between IBH and IBL")
colorInitialBalanceShade = input.color(color.new(color.green, 95), "", inline="SL_IBC", group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)", tooltip="Fill color for initial balance box")



showPivots = input.bool(true, "Enable Pivot Points", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Traditional pivot levels calculated from previous day's high, low, close")
pivotMaxTimeframe = input.string("4h", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Hide pivot points above this timeframe")
pivotLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Visual style for pivot lines")
pivotLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Line thickness for pivot levels (1-5)")

showPivotR3 = input.bool(true, "R3", inline="PV_R3", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Resistance 3 (highest resistance level)")
pivotColorR3 = input.color(#449955, "", inline="PV_R3", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Color for R3 line")
showPivotR2 = input.bool(true, "R2", inline="PV_R2", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Resistance 2")
pivotColorR2 = input.color(#449955, "", inline="PV_R2", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Color for R2 line")
showPivotR1 = input.bool(false, "R1", inline="PV_R1", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Resistance 1 (closest resistance)")
pivotColorR1 = input.color(#449955, "", inline="PV_R1", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Color for R1 line")

showPivotP = input.bool(false, "Pivot (P)", inline="PV_P", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Central pivot point")
pivotColorP = input.color(#808080, "", inline="PV_P", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Color for pivot line")

showPivotS1 = input.bool(false, "S1", inline="PV_S1", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Support 1 (closest support)")
pivotColorS1 = input.color(#b51b00, "", inline="PV_S1", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Color for S1 line")
showPivotS2 = input.bool(true, "S2", inline="PV_S2", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Support 2")
pivotColorS2 = input.color(#b51b00, "", inline="PV_S2", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Color for S2 line")
showPivotS3 = input.bool(true, "S3", inline="PV_S3", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Support 3 (lowest support level)")
pivotColorS3 = input.color(#b51b00, "", inline="PV_S3", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Color for S3 line")



showKeyLevels = input.bool(true, "Enable Key Levels", group="ğŸ“ Levels â€¢ Key Levels", tooltip="Show ATH and high/low for current/previous year/month/week/day")
keyLevelsMaxTimeframe = input.string("15m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ“ Levels â€¢ Key Levels", tooltip="Hide key levels above this timeframe")
keyLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“ Levels â€¢ Key Levels", tooltip="Visual style for key level lines")
keyLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ“ Levels â€¢ Key Levels", tooltip="Line thickness for key levels (1-5)")

showATH = input.bool(true, "All-Time High", inline="KL_ATH", group="ğŸ“ Levels â€¢ Key Levels â€¢ All-Time High", tooltip="Highest price ever reached on this symbol")
colorATH = input.color(#00bcd4, "Color", inline="KL_ATH", group="ğŸ“ Levels â€¢ Key Levels â€¢ All-Time High", tooltip="Color for ATH line")

showCYH = input.bool(true, "Current", inline="KL_CY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
colorCYH = input.color(#449955, "High", inline="KL_CY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
showCYL = input.bool(true, "", inline="KL_CY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
colorCYL = input.color(#b51b00, "Low", inline="KL_CY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")

showPYH = input.bool(true, "Previous", inline="KL_PY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
colorPYH = input.color(#449955, "High", inline="KL_PY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
showPYL = input.bool(true, "", inline="KL_PY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
colorPYL = input.color(#b51b00, "Low", inline="KL_PY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")

showCMH = input.bool(true, "Current", inline="KL_CM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
colorCMH = input.color(#449955, "High", inline="KL_CM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
showCML = input.bool(true, "", inline="KL_CM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
colorCML = input.color(#b51b00, "Low", inline="KL_CM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")

showPMH = input.bool(true, "Previous", inline="KL_PM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
colorPMH = input.color(#449955, "High", inline="KL_PM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
showPML = input.bool(true, "", inline="KL_PM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
colorPML = input.color(#b51b00, "Low", inline="KL_PM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")

showCWH = input.bool(true, "Current", inline="KL_CW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
colorCWH = input.color(#449955, "High", inline="KL_CW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
showCWL = input.bool(true, "", inline="KL_CW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
colorCWL = input.color(#b51b00, "Low", inline="KL_CW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")

showPWH = input.bool(true, "Previous", inline="KL_PW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
colorPWH = input.color(#449955, "High", inline="KL_PW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
showPWL = input.bool(true, "", inline="KL_PW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
colorPWL = input.color(#b51b00, "Low", inline="KL_PW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")

showCDH = input.bool(true, "Current", inline="KL_CD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
colorCDH = input.color(#449955, "High", inline="KL_CD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
showCDL = input.bool(true, "", inline="KL_CD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
colorCDL = input.color(#b51b00, "Low", inline="KL_CD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")

showPDH = input.bool(true, "Previous", inline="KL_PD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
colorPDH = input.color(#449955, "High", inline="KL_PD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
showPDL = input.bool(true, "", inline="KL_PD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
colorPDL = input.color(#b51b00, "Low", inline="KL_PD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")


// Constants for VWAP history (must be defined before helper functions that use them)
const int MAX_VWAP_HISTORY = 10
const int MAX_WEEKLY_HISTORY = 6
const int MAX_MONTHLY_HISTORY = 6
const int MAX_YEARLY_HISTORY = 2

// HELPER FUNCTIONS

getLabelSize(string s) => s == "Tiny" ? size.tiny : s == "Small" ? size.small : s == "Large" ? size.large : s == "Huge" ? size.huge : size.normal
getLineStyle(string s) => s == "Solid" ? line.style_solid : s == "Dashed" ? line.style_dashed : line.style_dotted

// Helper for VWAP plot value - returns na if conditions not met
vwapVal(bool base, bool meetsTF, bool enabled, int histCount, int minHist, array<float> vwaps, int idx, bool skipMostRecent) =>
    base and meetsTF and enabled and histCount >= minHist and (minHist > 1 or not skipMostRecent) ? array.get(vwaps, MAX_VWAP_HISTORY - minHist) : na

// Helper for anchor VWAP plot value (weekly/monthly/yearly)
anchorVal(bool base, int idx, int maxHist, int count, array<float> vwaps) =>
    base and idx >= (maxHist - count) ? array.get(vwaps, idx) : na
labelBgColor(color c) => color.new(c, 100)
priceToTicks(float p) => syminfo.mintick > 0 ? int(math.round(p / syminfo.mintick)) : int(p)

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HOLIDAY HANDLING (O(1) lookup via maps)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var map<int, bool> stockHolidayMap = map.new<int, bool>()
var map<int, bool> futuresHolidayMap = map.new<int, bool>()

if barstate.isfirst
    for d in array.from(20250101,20250120,20250217,20250418,20250526,20250619,20250704,20250901,20251127,20251225,20260101,20260119,20260216,20260403,20260525,20260619,20260703,20260907,20261126,20261225,20270101,20270118,20270215,20270326,20270531,20270618,20270705,20270906,20271125,20271224,20280117,20280221,20280414,20280529,20280619,20280704,20280904,20281123,20281225)
        stockHolidayMap.put(d, true)
    for d in array.from(20250101,20250120,20250217,20250418,20250526,20250619,20250704,20250901,20251013,20251111,20251127,20251225,20260101,20260119,20260216,20260403,20260525,20260619,20260703,20260907,20261012,20261111,20261126,20261225)
        futuresHolidayMap.put(d, true)

toYMD(int ts, string tz) => year(ts, tz) * 10000 + month(ts, tz) * 100 + dayofmonth(ts, tz)
isFullHoliday(int ts, string tz, bool stk) => stk ? stockHolidayMap.contains(toYMD(ts, tz)) : futuresHolidayMap.contains(toYMD(ts, tz))
isTradingDay(int ts, string tz, string sess, bool stk) =>
    int dow = dayofweek(ts, tz)
    (sess == "Globex" ? dow == dayofweek.sunday or dow >= dayofweek.monday and dow <= dayofweek.friday : dow >= dayofweek.monday and dow <= dayofweek.friday) and not isFullHoliday(ts, tz, stk)

updateBox(box b, int x1, float y1, int x2, float y2, color bg) =>
    if na(b)
        box.new(x1, y1, x2, y2, border_color=na, bgcolor=bg)
    else
        box.set_lefttop(b, x1, y1), box.set_rightbottom(b, x2, y2), b

rgbToHsl(float r, float g, float b) =>
    float rN = r / 255, float gN = g / 255, float bN = b / 255
    float mx = math.max(rN, math.max(gN, bN)), float mn = math.min(rN, math.min(gN, bN)), float d = mx - mn
    float h = 0.0, float s = 0.0, float l = (mx + mn) / 2
    if d != 0
        s := l > 0.5 ? d / (2 - mx - mn) : d / (mx + mn)
        h := mx == rN ? ((gN - bN) / d + (gN < bN ? 6 : 0)) / 6 : mx == gN ? ((bN - rN) / d + 2) / 6 : ((rN - gN) / d + 4) / 6
    [h, s, l]

hueToRgb(float p, float q, float t) =>
    float tA = t < 0 ? t + 1 : t > 1 ? t - 1 : t
    tA < 1.0/6 ? p + (q - p) * 6 * tA : tA < 0.5 ? q : tA < 2.0/3 ? p + (q - p) * (2.0/3 - tA) * 6 : p

hslToRgb(float h, float s, float l) =>
    if s == 0
        [int(l * 255), int(l * 255), int(l * 255)]
    else
        float q = l < 0.5 ? l * (1 + s) : l + s - l * s, float p = 2 * l - q
        [int(hueToRgb(p, q, h + 1.0/3) * 255), int(hueToRgb(p, q, h) * 255), int(hueToRgb(p, q, h - 1.0/3) * 255)]

isWithinATR(float lp, float cp, float th, bool on) => not on or na(lp) or math.abs(lp - cp) <= th
getSessionAbbr(string s) => s == "London" ? "LN" : s == "New York" ? "NY" : s == "Globex" ? "GLX" : s == "Sydney" ? "SYD" : "TKY"

// LEVEL RENDERER UDT

type LevelRenderer
    string name
    bool enabled
    float price
    int priceTicks
    int startBar
    color levelColor
    int lineWidth
    string lineStyle
    line lineRef
    label labelRef

addLevel(array<LevelRenderer> arr, string name, bool show, float price, int priceTicks, int startBar, color col, int width, string style) =>
    array.push(arr, LevelRenderer.new(name, show, price, priceTicks, startBar, col, width, style, na, na))

// Render method for a single level with deduplication support
method render(LevelRenderer this, bool groupCondition, bool checkDuplicate, map<int, string> priceLabels, array<int> renderedPrices, bool globalShowPriceValues, string labelSizeActual, float atrThreshold, bool useATRFilter, bool ignoreATRFilter = false) =>
    if groupCondition and this.enabled and not na(this.price) and (ignoreATRFilter or isWithinATR(this.price, close, atrThreshold, useATRFilter)) and (not checkDuplicate or not array.includes(renderedPrices, this.priceTicks))
        string combinedLabel = map.contains(priceLabels, this.priceTicks) ? map.get(priceLabels, this.priceTicks) : this.name
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(this.price, format.mintick) + ")" : combinedLabel
        if na(this.lineRef)
            line tempLine = line.new(this.startBar, this.price, bar_index, this.price, color=this.levelColor, width=this.lineWidth, style=getLineStyle(this.lineStyle))
            label tempLabel = label.new(bar_index, this.price, labelText, color=labelBgColor(this.levelColor), textcolor=this.levelColor, style=label.style_label_left, size=labelSizeActual)
            this.lineRef := tempLine
            this.labelRef := tempLabel
            true
        else
            line.set_xy1(this.lineRef, this.startBar, this.price)
            line.set_xy2(this.lineRef, bar_index, this.price)
            label.set_xy(this.labelRef, bar_index, this.price)
            label.set_text(this.labelRef, labelText)
            true
        array.push(renderedPrices, this.priceTicks)
        true
    else if not na(this.lineRef)
        line.delete(this.lineRef)
        this.lineRef := na
        label.delete(this.labelRef)
        this.labelRef := na
        true
    else
        true

method update(LevelRenderer this, bool enabled, float price, int priceTicks, int startBar) =>
    this.enabled := enabled
    this.price := price
    this.priceTicks := priceTicks
    this.startBar := startBar
    true

deleteLabel(array<label> arr, int idx) =>
    label old = array.get(arr, idx)
    if not na(old)
        label.delete(old)

getVWAPColor(color c1, color c2, int pos, int maxP) =>
    if pos == 0 or maxP == 0
        c1
    else
        float t = maxP > 0 ? math.min(pos / float(maxP), 1.0) : 0.0
        [h1, s1, l1] = rgbToHsl(color.r(c1), color.g(c1), color.b(c1))
        [h2, s2, l2] = rgbToHsl(color.r(c2), color.g(c2), color.b(c2))
        float hD = h2 - h1
        hD := hD > 0.5 ? hD - 1 : hD < -0.5 ? hD + 1 : hD
        float h = h1 + hD * t
        h := h < 0 ? h + 1 : h > 1 ? h - 1 : h
        [nR, nG, nB] = hslToRgb(h, s1 + (s2 - s1) * t, l1 + (l2 - l1) * t)
        color.rgb(nR, nG, nB, int(color.t(c1) + (color.t(c2) - color.t(c1)) * t))

getSessionTimezone(string s) => s == "London" ? "Europe/London" : s == "New York" or s == "Globex" ? "America/New_York" : s == "Sydney" ? "Australia/Sydney" : "Asia/Tokyo"
getSessionStartHour(string s) => s == "London" ? 8 : s == "New York" ? 9 : s == "Globex" ? 18 : s == "Sydney" ? 10 : 9
getSessionStartMinute(string s) => s == "New York" ? 30 : 0
getSessionEndHour(string s) => s == "London" ? 16 : s == "New York" ? 16 : s == "Globex" ? 17 : s == "Sydney" ? 16 : 15
getSessionEndMinute(string s) => s == "London" ? 30 : 0

getSessionStartForDate(string s, int y, int m, int d) => timestamp(getSessionTimezone(s), y, m, d, getSessionStartHour(s), getSessionStartMinute(s))
getSessionEndForDate(string s, int y, int m, int d) =>
    int ts = timestamp(getSessionTimezone(s), y, m, d, getSessionEndHour(s), getSessionEndMinute(s))
    s == "Globex" ? ts + MS_PER_DAY : ts

getSessionTimestampsArray(string session, int sessionsBack, bool isStart) =>
    var array<int> ts = array.new<int>()
    array.clear(ts)
    string tz = getSessionTimezone(session)
    bool stk = syminfo.type == "stock"
    int cY = year(timenow, tz), int cM = month(timenow, tz), int cD = dayofmonth(timenow, tz), int cDow = dayofweek(timenow, tz)
    if cDow == dayofweek.saturday
        int fri = timestamp(tz, cY, cM, cD, 0, 0) - MS_PER_DAY
        cY := year(fri, tz), cM := month(fri, tz), cD := dayofmonth(fri, tz)
    else if cDow == dayofweek.sunday and session != "Globex"
        int fri = timestamp(tz, cY, cM, cD, 0, 0) - TWO_DAYS_MS
        cY := year(fri, tz), cM := month(fri, tz), cD := dayofmonth(fri, tz)
    int collected = 0, int offset = 0, int lastTs = na, int maxDays = math.max(sessionsBack * 2 + 5, 25)
    while collected < sessionsBack and offset < maxDays
        int mid = timestamp(tz, cY, cM, cD, 0, 0) - offset * MS_PER_DAY
        int y = year(mid, tz), int m = month(mid, tz), int d = dayofmonth(mid, tz), int dow = dayofweek(mid, tz)
        if isTradingDay(mid, tz, session, stk)
            int t = na
            if session == "Globex" and dow != dayofweek.sunday
                int prev = mid - MS_PER_DAY
                t := isStart ? getSessionStartForDate(session, year(prev, tz), month(prev, tz), dayofmonth(prev, tz)) : getSessionEndForDate(session, year(prev, tz), month(prev, tz), dayofmonth(prev, tz))
            else
                t := isStart ? getSessionStartForDate(session, y, m, d) : getSessionEndForDate(session, y, m, d)
            if na(lastTs) or t != lastTs
                array.unshift(ts, t), lastTs := t, collected += 1
        offset += 1
    ts

getSessionStartsArray(string s, int n) => getSessionTimestampsArray(s, n, true)
getSessionEndsArray(string s, int n) => getSessionTimestampsArray(s, n, false)


getFirstTradingDayOfMonth(string session, int tY, int tM) =>
    string tz = getSessionTimezone(session)
    bool stk = syminfo.type == "stock"
    int fd = na
    for i = 1 to 10
        int t = timestamp(tz, tY, tM, i, 0, 0)
        if year(t, tz) != tY or month(t, tz) != tM
            break
        if isTradingDay(t, tz, session, stk)
            fd := i, break
    fd

getAnchorStarts(string period, string session, int maxSize) =>
    var array<int> starts = array.new<int>()
    array.clear(starts)
    string tz = getSessionTimezone(session)
    int cY = year(timenow, tz), int cM = month(timenow, tz), int cD = dayofmonth(timenow, tz)
    if period == "W"
        int cDow = dayofweek(timenow, tz)
        if cDow == dayofweek.saturday
            int fri = timestamp(tz, cY, cM, cD, 0, 0) - MS_PER_DAY
            cY := year(fri, tz), cM := month(fri, tz), cD := dayofmonth(fri, tz)
        else if cDow == dayofweek.sunday and session != "Globex"
            int fri = timestamp(tz, cY, cM, cD, 0, 0) - TWO_DAYS_MS
            cY := year(fri, tz), cM := month(fri, tz), cD := dayofmonth(fri, tz)
        if timenow < getSessionStartForDate(session, cY, cM, cD)
            int yest = timestamp(tz, cY, cM, cD, 0, 0) - MS_PER_DAY
            cY := year(yest, tz), cM := month(yest, tz), cD := dayofmonth(yest, tz)
        int tDow = session == "Globex" ? dayofweek.sunday : dayofweek.monday
        bool stk = syminfo.type == "stock"
        int curMid = timestamp(tz, cY, cM, cD, 0, 0)
        int daysTo = (dayofweek(curMid, tz) - tDow + 7) % 7
        int tgtMid = curMid - daysTo * MS_PER_DAY
        int col = 0, int wk = 0
        while col < maxSize and wk < maxSize + 4
            int mid = tgtMid - wk * 7 * MS_PER_DAY
            if isTradingDay(mid, tz, session, stk)
                array.unshift(starts, getSessionStartForDate(session, year(mid, tz), month(mid, tz), dayofmonth(mid, tz)))
                col += 1
            wk += 1
    else if period == "M"
        for i = 0 to maxSize - 1
            int tM = cM - i, int tY = cY
            while tM < 1
                tM += 12, tY -= 1
            int fd = getFirstTradingDayOfMonth(session, tY, tM)
            array.unshift(starts, not na(fd) ? getSessionStartForDate(session, tY, tM, fd) : na)
    else if period == "Y"
        for i = 0 to maxSize - 1
            int tY = cY - i
            int fd = getFirstTradingDayOfMonth(session, tY, 1)
            array.unshift(starts, not na(fd) ? getSessionStartForDate(session, tY, 1, fd) : na)
    starts

createAnchorLabel(array<label> arr, int idx, int start, string p, int pos, color c1, color c2, int maxC, string tz, string sess) =>
    if not na(start)
        label old = array.get(arr, idx)
        if not na(old)
            label.delete(old)
        string txt = p == "W" ? (compactLabels ? "W" : "Week " + str.tostring(weekofyear(start, tz)) + " (" + sess + ")") : p == "M" ? (compactLabels ? "M" : str.format("{0,date,MMM yyyy}", start) + " (" + sess + ")") : (compactLabels ? "Y" : str.tostring(year(start, tz)) + " (" + sess + ")")
        txt := compactLabels ? txt + str.tostring(pos + 1) : txt
        array.set(arr, idx, label.new(bar_index, high, txt, xloc=xloc.bar_index, yloc=yloc.abovebar, color=getVWAPColor(c1, c2, pos, maxC - 1), textcolor=color.white, size=getLabelSize(anchorLabelSize), style=label.style_label_down))

periodToMinutes(string p) => p == "1m" ? 1 : p == "2m" ? 2 : p == "3m" ? 3 : p == "5m" ? 5 : p == "15m" ? 15 : p == "30m" ? 30 : p == "1h" ? 60 : p == "65m" ? 65 : p == "2h" ? 120 : p == "4h" ? 240 : p == "1D" ? 1440 : 99999
getTimeframeMinutes() => timeframe.in_seconds() >= 86400 ? (timeframe.in_seconds() / 86400) * 1440 : timeframe.in_seconds() / 60

addToMap(map<int, string> m, float price, string lbl) =>
    int k = priceToTicks(price)
    string ex = map.contains(m, k) ? map.get(m, k) : ""
    map.put(m, k, ex != "" ? ex + "/" + lbl : lbl)

// Conditional addToMap - only adds if show is true
addIf(map<int, string> m, bool show, float price, string lbl) =>
    if show
        addToMap(m, price, lbl)

// DISPLAY CONDITIONS & ATR FILTERING

// Check timeframe conditions first (needed for ATR gate)
int currentTfMinutes = timeframe.in_seconds() >= 86400 ? (timeframe.in_seconds() / 86400) * 1440 : timeframe.in_seconds() / 60
bool meetsMaxTimeframe = keyLevelsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(keyLevelsMaxTimeframe)
bool showKeyLevelsCondition = showKeyLevels and meetsMaxTimeframe

bool isFutures = syminfo.type == "futures"

// Determine primary session name (used for long-term anchor and primary session logic)
string primarySessionName = longTermAnchorSession == "Auto" ? (syminfo.type == "stock" ? "New York" : "Globex") : longTermAnchorSession
string primarySessionTZ = getSessionTimezone(primarySessionName)

// Check timeframe conditions for session features
bool meetsOtherSessionsTimeframe = otherSessionsMaxTF == "None" or currentTfMinutes <= periodToMinutes(otherSessionsMaxTF)
bool meetsPrimarySessionTimeframe = primarySessionMaxTF == "None" or currentTfMinutes <= periodToMinutes(primarySessionMaxTF)
bool sessionBaseCondition = enableSessionFeatures
bool showSessionMarkersCondition = sessionBaseCondition and meetsOtherSessionsTimeframe

// Individual session VWAP timeframe checks (long-term anchor session gets extended visibility, others are intraday-only)
bool meetsLondonVWAPTimeframe = primarySessionName == "London" ? meetsPrimarySessionTimeframe : meetsOtherSessionsTimeframe
bool meetsNYVWAPTimeframe = primarySessionName == "New York" ? meetsPrimarySessionTimeframe : meetsOtherSessionsTimeframe
bool meetsGlobexVWAPTimeframe = primarySessionName == "Globex" ? meetsPrimarySessionTimeframe : meetsOtherSessionsTimeframe
bool meetsSydneyVWAPTimeframe = primarySessionName == "Sydney" ? meetsPrimarySessionTimeframe : meetsOtherSessionsTimeframe
bool meetsTokyoVWAPTimeframe = primarySessionName == "Tokyo" ? meetsPrimarySessionTimeframe : meetsOtherSessionsTimeframe

// Check timeframe conditions for session levels and pivot features
bool meetsSessionLevelsMaxTimeframe = sessionLevelsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(sessionLevelsMaxTimeframe)

// Session levels visibility (separate from VWAPs)
bool showSessionLevels = showSessionLevelsInput == "Always" or (showSessionLevelsInput == "Futures Only" and syminfo.type == "futures")
bool sessionLevelsVisible = showSessionLevels and sessionBaseCondition and meetsSessionLevelsMaxTimeframe

// Combined visibility checks for VWAP computation: session enabled AND meets timeframe AND VWAP features enabled
// These don't change per bar, so no need for var (already compile-time constant per chart load)
bool shouldComputeLondonVWAP = enableLondonActive and meetsLondonVWAPTimeframe and sessionBaseCondition and showDailySessionVWAPs
bool shouldComputeNYVWAP = enableNewYorkActive and meetsNYVWAPTimeframe and sessionBaseCondition and showDailySessionVWAPs
bool shouldComputeGlobexVWAP = enableGlobexActive and meetsGlobexVWAPTimeframe and sessionBaseCondition and showDailySessionVWAPs
bool shouldComputeSydneyVWAP = enableSydneyActive and meetsSydneyVWAPTimeframe and sessionBaseCondition and showDailySessionVWAPs
bool shouldComputeTokyoVWAP = enableTokyoActive and meetsTokyoVWAPTimeframe and sessionBaseCondition and showDailySessionVWAPs
bool anySessionVWAPEnabled = shouldComputeLondonVWAP or shouldComputeNYVWAP or shouldComputeGlobexVWAP or shouldComputeSydneyVWAP or shouldComputeTokyoVWAP

// Session timestamp computation needed if VWAPs OR session levels are visible
bool shouldComputeLondon = shouldComputeLondonVWAP or (sessionLevelsVisible and enableLondonActive)
bool shouldComputeNY = shouldComputeNYVWAP or (sessionLevelsVisible and enableNewYorkActive)
bool shouldComputeGlobex = shouldComputeGlobexVWAP or (sessionLevelsVisible and enableGlobexActive)
bool shouldComputeSydney = shouldComputeSydneyVWAP or (sessionLevelsVisible and enableSydneyActive)
bool shouldComputeTokyo = shouldComputeTokyoVWAP or (sessionLevelsVisible and enableTokyoActive)

// Session detection needed if VWAPs OR session levels are visible
bool needSessionDetection = anySessionVWAPEnabled or sessionLevelsVisible
bool meetsPivotMaxTimeframe = pivotMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(pivotMaxTimeframe)
bool showPivotsCondition = showPivots and meetsPivotMaxTimeframe

// Fetch ATR if filtering is enabled AND any levels will be shown (key levels, session levels, or pivots)
float atrValue = useATRFilter and (showKeyLevelsCondition or sessionLevelsVisible or showPivotsCondition) ? request.security(syminfo.tickerid, "D", ta.atr(atrPeriod), lookahead=barmerge.lookahead_on) : na
float atrThreshold = useATRFilter and not na(atrValue) ? atrValue * atrMultiplier : na

// NY session filter for stocks and equity indices (RTH = 9:30 AM - 4:00 PM ET, bars before 4:00 PM)
// Precompute RTH filter condition once (doesn't change per bar)
bool isEquityIndex = syminfo.type == "futures" and (str.contains(syminfo.ticker, "ES") or str.contains(syminfo.ticker, "MES") or str.contains(syminfo.ticker, "NQ") or str.contains(syminfo.ticker, "MNQ") or str.contains(syminfo.ticker, "RTY") or str.contains(syminfo.ticker, "M2K") or str.contains(syminfo.ticker, "YM") or str.contains(syminfo.ticker, "MYM"))
bool shouldFilterRTH = (rthOnlyForStocks and syminfo.type == "stock") or (rthOnlyForIndices and isEquityIndex)
// Only compute expensive timezone conversions when RTH filtering is active (cache hour/minute to avoid repeated calls)
int nyHour = shouldFilterRTH ? hour(time, "America/New_York") : 0
int nyMin = shouldFilterRTH ? minute(time, "America/New_York") : 0
int nyDow = shouldFilterRTH ? dayofweek(time, "America/New_York") : 0
bool isNYSession = not shouldFilterRTH ? true : (nyDow >= dayofweek.monday and nyDow <= dayofweek.friday and ((nyHour == 9 and nyMin >= 30) or (nyHour > 9 and nyHour < 16)))

// Check timeframe condition for weekly anchors
bool meetsWeeklyAnchorMinTimeframe = weeklyAnchorMinTimeframe == "None" or currentTfMinutes >= periodToMinutes(weeklyAnchorMinTimeframe)
bool meetsWeeklyAnchorMaxTimeframe = weeklyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(weeklyAnchorMaxTimeframe)
bool meetsWeeklyAnchorTimeframe = meetsWeeklyAnchorMinTimeframe and meetsWeeklyAnchorMaxTimeframe
bool meetsMonthlyAnchorMinTimeframe = monthlyAnchorMinTimeframe == "None" or currentTfMinutes >= periodToMinutes(monthlyAnchorMinTimeframe)
bool meetsMonthlyAnchorMaxTimeframe = monthlyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(monthlyAnchorMaxTimeframe)
bool meetsMonthlyAnchorTimeframe = meetsMonthlyAnchorMinTimeframe and meetsMonthlyAnchorMaxTimeframe
bool meetsYearlyAnchorMinTimeframe = yearlyAnchorMinTimeframe == "None" or currentTfMinutes >= periodToMinutes(yearlyAnchorMinTimeframe)
bool meetsYearlyAnchorMaxTimeframe = yearlyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(yearlyAnchorMaxTimeframe)
bool meetsYearlyAnchorTimeframe = meetsYearlyAnchorMinTimeframe and meetsYearlyAnchorMaxTimeframe

// KEY LEVELS DATA - Fetch via request.security (runs once per bar, cached by Pine)
// Use direct assignment for cleaner code - Pine optimizes repeated security calls
var float pdh = na, var float pdl = na, var float cdh = na, var float cdl = na
var float pwh = na, var float pwl = na, var float cwh = na, var float cwl = na
var float pmh = na, var float pml = na, var float cmh = na, var float cml = na
var float pyh = na, var float pyl = na, var float cyh = na, var float cyl = na

// Only fetch on last bar or first bar to minimize security call overhead during initial load
bool shouldFetchLevels = barstate.islast or barstate.isfirst
if shouldFetchLevels and showKeyLevelsCondition and (showPDH or showPDL or showCDH or showCDL)
    [_pdh, _pdl, _cdh, _cdl] = request.security(syminfo.tickerid, "D", [high[1], low[1], high, low], lookahead=barmerge.lookahead_on)
    pdh := _pdh, pdl := _pdl, cdh := _cdh, cdl := _cdl

if shouldFetchLevels and showKeyLevelsCondition and (showPWH or showPWL or showCWH or showCWL)
    [_pwh, _pwl, _cwh, _cwl] = request.security(syminfo.tickerid, "W", [high[1], low[1], high, low], lookahead=barmerge.lookahead_on)
    pwh := _pwh, pwl := _pwl, cwh := _cwh, cwl := _cwl

if shouldFetchLevels and showKeyLevelsCondition and (showPMH or showPML or showCMH or showCML)
    [_pmh, _pml, _cmh, _cml] = request.security(syminfo.tickerid, "M", [high[1], low[1], high, low], lookahead=barmerge.lookahead_on)
    pmh := _pmh, pml := _pml, cmh := _cmh, cml := _cml

if shouldFetchLevels and showKeyLevelsCondition and (showPYH or showPYL or showCYH or showCYL)
    [_pyh, _pyl, _cyh, _cyl] = request.security(syminfo.tickerid, "12M", [high[1], low[1], high, low], lookahead=barmerge.lookahead_on)
    pyh := _pyh, pyl := _pyl, cyh := _cyh, cyl := _cyl

var float ath = na
if showKeyLevelsCondition and showATH
    ath := na(ath) ? high : (na(high) ? ath : math.max(ath, high))

// PIVOT POINTS (from previous day's HLC) - only fetch if pivots will be displayed
var float dailyHigh = na, var float dailyLow = na, var float dailyClose = na
if shouldFetchLevels and showPivotsCondition
    [_dailyHigh, _dailyLow, _dailyClose] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    dailyHigh := _dailyHigh, dailyLow := _dailyLow, dailyClose := _dailyClose

float dailyRange = dailyHigh - dailyLow
float pivotP = (dailyHigh + dailyLow + dailyClose) / 3
float pivotR1 = 2 * pivotP - dailyLow
float pivotS1 = 2 * pivotP - dailyHigh
float pivotR2 = pivotP + dailyRange
float pivotS2 = pivotP - dailyRange
float pivotR3 = dailyHigh + 2 * (pivotP - dailyLow)
float pivotS3 = dailyLow - 2 * (dailyHigh - pivotP)

var array<LevelRenderer> keyLevels = array.new<LevelRenderer>()
var array<LevelRenderer> pivotLevels = array.new<LevelRenderer>()
var array<LevelRenderer> sessionLevels = array.new<LevelRenderer>()

// MULTI-SESSION INFRASTRUCTURE

type SessionManager
    string name
    string timezone
    bool enabled
    color col
    color colEnd
    int historyCount
    array<int> starts
    array<int> ends
    array<int> startBars
    array<float> sumSrc
    array<float> sumVol
    array<float> vwaps
    array<label> labels
    int prevMostRecentStart
    bool meetsTimeframe
    array<color> preCalcColors
    array<int> holidayRanks
    int cachedHistoryCount

calcHolidayRanks(array<int> starts, string sessionName, bool isStockType) =>
    array<int> ranks = array.new<int>(MAX_VWAP_HISTORY, 0)
    string tz = getSessionTimezone(sessionName)
    int rank = 0
    for idx = MAX_VWAP_HISTORY - 1 to 0
        int sessionStart = array.get(starts, idx)
        if not na(sessionStart)
            int checkTS = sessionName == "Globex" ? sessionStart + 86400000 : sessionStart
            if not isFullHoliday(checkTS, tz, isStockType)
                rank += 1
                array.set(ranks, idx, rank)
    ranks

// Shift session VWAP arrays left when new session detected
shiftSessionArrays(array<int> oldStarts, array<int> newStarts, array<int> startBars, array<float> sumSrc, array<float> sumVol, array<float> vwaps) =>
    int newestSlot = array.get(newStarts, MAX_VWAP_HISTORY - 1)
    if not na(newestSlot)
        array<int> tempStartBars = array.new<int>(MAX_VWAP_HISTORY, na)
        for oldIdx = 0 to MAX_VWAP_HISTORY - 1
            int oldSessionTime = array.get(oldStarts, oldIdx)
            int oldBarIdx = array.get(startBars, oldIdx)
            if not na(oldSessionTime) and not na(oldBarIdx)
                for newIdx = 0 to MAX_VWAP_HISTORY - 1
                    int newSessionTime = array.get(newStarts, newIdx)
                    if newSessionTime == oldSessionTime
                        array.set(tempStartBars, newIdx, oldBarIdx)
                        break
        for i = 0 to MAX_VWAP_HISTORY - 2
            int srcIdx = MAX_VWAP_HISTORY - 1 - i
            int dstIdx = srcIdx - 1
            array.set(sumSrc, dstIdx, array.get(sumSrc, srcIdx))
            array.set(sumVol, dstIdx, array.get(sumVol, srcIdx))
            array.set(vwaps, dstIdx, array.get(vwaps, srcIdx))
        array.set(sumSrc, MAX_VWAP_HISTORY - 1, 0.0)
        array.set(sumVol, MAX_VWAP_HISTORY - 1, 0.0)
        array.set(vwaps, MAX_VWAP_HISTORY - 1, na)
        for idx = 0 to MAX_VWAP_HISTORY - 1
            array.set(startBars, idx, array.get(tempStartBars, idx))

var array<SessionManager> sessionManagers = array.new<SessionManager>()

// Helper to create empty arrays for disabled sessions (avoids expensive timestamp computation)
emptyIntArray() => array.new<int>(MAX_VWAP_HISTORY, na)

if barstate.isfirst
    array<int> londonStarts = shouldComputeLondon ? getSessionStartsArray("London", MAX_VWAP_HISTORY) : emptyIntArray()
    array<int> nyStarts = shouldComputeNY ? getSessionStartsArray("New York", MAX_VWAP_HISTORY) : emptyIntArray()
    array<int> globexStarts = shouldComputeGlobex ? getSessionStartsArray("Globex", MAX_VWAP_HISTORY) : emptyIntArray()
    array<int> sydneyStarts = shouldComputeSydney ? getSessionStartsArray("Sydney", MAX_VWAP_HISTORY) : emptyIntArray()
    array<int> tokyoStarts = shouldComputeTokyo ? getSessionStartsArray("Tokyo", MAX_VWAP_HISTORY) : emptyIntArray()

    array.push(sessionManagers, SessionManager.new("London", "Europe/London", enableLondonActive, colorLondonActive, colorLondonActiveEnd, londonVWAPCountActive, londonStarts, shouldComputeLondon ? getSessionEndsArray("London", MAX_VWAP_HISTORY) : emptyIntArray(), array.new<int>(MAX_VWAP_HISTORY, na), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, na), array.new<label>(MAX_VWAP_HISTORY, na), na, meetsLondonVWAPTimeframe, array.new<color>(MAX_VWAP_HISTORY), shouldComputeLondon ? calcHolidayRanks(londonStarts, "London", isStock) : emptyIntArray(), 0))
    array.push(sessionManagers, SessionManager.new("New York", "America/New_York", enableNewYorkActive, colorNewYorkActive, colorNewYorkActiveEnd, nyVWAPCountActive, nyStarts, shouldComputeNY ? getSessionEndsArray("New York", MAX_VWAP_HISTORY) : emptyIntArray(), array.new<int>(MAX_VWAP_HISTORY, na), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, na), array.new<label>(MAX_VWAP_HISTORY, na), na, meetsNYVWAPTimeframe, array.new<color>(MAX_VWAP_HISTORY), shouldComputeNY ? calcHolidayRanks(nyStarts, "New York", isStock) : emptyIntArray(), 0))
    array.push(sessionManagers, SessionManager.new("Globex", "America/New_York", enableGlobexActive, colorGlobexActive, colorGlobexActiveEnd, globexVWAPCountActive, globexStarts, shouldComputeGlobex ? getSessionEndsArray("Globex", MAX_VWAP_HISTORY) : emptyIntArray(), array.new<int>(MAX_VWAP_HISTORY, na), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, na), array.new<label>(MAX_VWAP_HISTORY, na), na, meetsGlobexVWAPTimeframe, array.new<color>(MAX_VWAP_HISTORY), shouldComputeGlobex ? calcHolidayRanks(globexStarts, "Globex", isStock) : emptyIntArray(), 0))
    array.push(sessionManagers, SessionManager.new("Sydney", "Australia/Sydney", enableSydneyActive, colorSydneyActive, colorSydneyActiveEnd, sydneyVWAPCountActive, sydneyStarts, shouldComputeSydney ? getSessionEndsArray("Sydney", MAX_VWAP_HISTORY) : emptyIntArray(), array.new<int>(MAX_VWAP_HISTORY, na), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, na), array.new<label>(MAX_VWAP_HISTORY, na), na, meetsSydneyVWAPTimeframe, array.new<color>(MAX_VWAP_HISTORY), shouldComputeSydney ? calcHolidayRanks(sydneyStarts, "Sydney", isStock) : emptyIntArray(), 0))
    array.push(sessionManagers, SessionManager.new("Tokyo", "Asia/Tokyo", enableTokyoActive, colorTokyoActive, colorTokyoActiveEnd, tokyoVWAPCountActive, tokyoStarts, shouldComputeTokyo ? getSessionEndsArray("Tokyo", MAX_VWAP_HISTORY) : emptyIntArray(), array.new<int>(MAX_VWAP_HISTORY, na), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, na), array.new<label>(MAX_VWAP_HISTORY, na), na, meetsTokyoVWAPTimeframe, array.new<color>(MAX_VWAP_HISTORY), shouldComputeTokyo ? calcHolidayRanks(tokyoStarts, "Tokyo", isStock) : emptyIntArray(), 0))

    for i = 0 to 4
        SessionManager mgr = array.get(sessionManagers, i)
        if mgr.enabled and mgr.meetsTimeframe
            mgr.prevMostRecentStart := array.get(mgr.starts, MAX_VWAP_HISTORY - 1)
            mgr.cachedHistoryCount := mgr.historyCount
            for pos = 0 to MAX_VWAP_HISTORY - 1
                array.set(mgr.preCalcColors, pos, getVWAPColor(mgr.col, mgr.colEnd, pos, mgr.historyCount - 1))

var array<int> weeklyAnchorStartsArray = array.new<int>(MAX_WEEKLY_HISTORY, na), var array<float> weeklyAnchorSumSrc = array.new<float>(MAX_WEEKLY_HISTORY, 0.0), var array<float> weeklyAnchorSumVol = array.new<float>(MAX_WEEKLY_HISTORY, 0.0)
var array<float> weeklyAnchorVWAPs = array.new<float>(MAX_WEEKLY_HISTORY, na), var array<label> weeklyAnchorLabels = array.new<label>(MAX_WEEKLY_HISTORY, na), var array<color> weeklyColors = array.new<color>(MAX_WEEKLY_HISTORY)
var bool currentSessionIsWeeklyAnchor = false, var bool currentSessionIsMonthlyAnchor = false, var bool currentSessionIsYearlyAnchor = false
var array<int> monthlyAnchorStartsArray = array.new<int>(MAX_MONTHLY_HISTORY, na), var array<float> monthlyAnchorSumSrc = array.new<float>(MAX_MONTHLY_HISTORY, 0.0), var array<float> monthlyAnchorSumVol = array.new<float>(MAX_MONTHLY_HISTORY, 0.0)
var array<float> monthlyAnchorVWAPs = array.new<float>(MAX_MONTHLY_HISTORY, na), var array<label> monthlyAnchorLabels = array.new<label>(MAX_MONTHLY_HISTORY, na), var array<color> monthlyColors = array.new<color>(MAX_MONTHLY_HISTORY)
var array<int> yearlyAnchorStartsArray = array.new<int>(MAX_YEARLY_HISTORY, na), var array<float> yearlyAnchorSumSrc = array.new<float>(MAX_YEARLY_HISTORY, 0.0), var array<float> yearlyAnchorSumVol = array.new<float>(MAX_YEARLY_HISTORY, 0.0)
var array<float> yearlyAnchorVWAPs = array.new<float>(MAX_YEARLY_HISTORY, na), var array<label> yearlyAnchorLabels = array.new<label>(MAX_YEARLY_HISTORY, na), var array<color> yearlyColors = array.new<color>(MAX_YEARLY_HISTORY)

// Combined visibility checks for anchor VWAPs (enabled AND meets timeframe)
bool shouldComputeWeekly = showWeeklyAnchorVWAP and enableSessionFeatures and meetsWeeklyAnchorTimeframe
bool shouldComputeMonthly = showMonthlyAnchorVWAP and enableSessionFeatures and meetsMonthlyAnchorTimeframe
bool shouldComputeYearly = showYearlyAnchorVWAP and enableSessionFeatures and meetsYearlyAnchorTimeframe
bool anyAnchorEnabled = shouldComputeWeekly or shouldComputeMonthly or shouldComputeYearly

if barstate.isfirst
    if shouldComputeWeekly
        weeklyAnchorStartsArray := getAnchorStarts("W", primarySessionName, MAX_WEEKLY_HISTORY)
        for pos = 0 to MAX_WEEKLY_HISTORY - 1
            array.set(weeklyColors, MAX_WEEKLY_HISTORY - 1 - pos, getVWAPColor(colorWeeklyAnchor, colorWeeklyAnchorEnd, pos, weeklyAnchorCount - 1))
    if shouldComputeMonthly
        monthlyAnchorStartsArray := getAnchorStarts("M", primarySessionName, MAX_MONTHLY_HISTORY)
        for pos = 0 to MAX_MONTHLY_HISTORY - 1
            array.set(monthlyColors, MAX_MONTHLY_HISTORY - 1 - pos, getVWAPColor(colorMonthlyAnchor, colorMonthlyAnchorEnd, pos, monthlyAnchorCount - 1))
    if shouldComputeYearly
        yearlyAnchorStartsArray := getAnchorStarts("Y", primarySessionName, MAX_YEARLY_HISTORY)
        for pos = 0 to MAX_YEARLY_HISTORY - 1
            array.set(yearlyColors, MAX_YEARLY_HISTORY - 1 - pos, getVWAPColor(colorYearlyAnchor, colorYearlyAnchorEnd, pos, yearlyAnchorCount - 1))

var int activeSessionIndex = na, var int sessionStartBar = na, var int sessionStartTime = na, var int sessionEndTime = na
var float sessionOpen = na, var float openRangeHigh = na, var float openRangeLow = na, var float initialBalanceHigh = na, var float initialBalanceLow = na
var int openPriceBar = na, var int orhBar = na, var int orlBar = na, var int ibhBar = na, var int iblBar = na

int openRangeMinutes = periodToMinutes(openRangeLength)
int ibMinutes = periodToMinutes(initialBalanceLength)

// UNIFIED SESSION DETECTION (Calendar-based)
// Skip entirely if neither session VWAPs nor session levels are visible
// Find the most recently started active session (handles overlapping sessions like London/NY)
if needSessionDetection and not na(time)
    int mostRecentStartTime = na
    int mostRecentSessionIdx = na
    int mostRecentSessionEnd = na
    int mostRecentHolidayRank = na
    for i = 0 to 4
        SessionManager mgr = array.get(sessionManagers, i)
        if not mgr.enabled
            continue
        int sessionStart = array.get(mgr.starts, MAX_VWAP_HISTORY - 1)
        int sessionEnd = array.get(mgr.ends, MAX_VWAP_HISTORY - 1)
        if na(sessionStart) or na(sessionEnd) or time < sessionStart or time >= sessionEnd
            continue
        int holidayRank = array.get(mgr.holidayRanks, MAX_VWAP_HISTORY - 1)
        if holidayRank > 0 and (na(mostRecentStartTime) or sessionStart > mostRecentStartTime)
            mostRecentStartTime := sessionStart
            mostRecentSessionIdx := i
            mostRecentSessionEnd := sessionEnd
            mostRecentHolidayRank := holidayRank
    if not na(mostRecentSessionIdx)
        SessionManager detectedMgr = array.get(sessionManagers, mostRecentSessionIdx)
        // Check if this session matches the selected session filter
        bool sessionMatches = sessionLevelsSessionSelect == "All" or detectedMgr.name == sessionLevelsSessionSelect
        bool sessionJustStarted = time[1] < mostRecentStartTime
        if sessionJustStarted and sessionMatches
            activeSessionIndex := mostRecentSessionIdx
            sessionOpen := open
            openRangeHigh := high
            openRangeLow := low
            initialBalanceHigh := high
            initialBalanceLow := low
            sessionStartBar := bar_index
            sessionStartTime := mostRecentStartTime
            sessionEndTime := mostRecentSessionEnd
            openPriceBar := bar_index
            orhBar := bar_index
            orlBar := bar_index
            ibhBar := bar_index
            iblBar := bar_index

if not na(activeSessionIndex) and not na(sessionOpen) and not na(sessionStartTime)
    SessionManager activeMgr = array.get(sessionManagers, activeSessionIndex)
    array<int> activeSessionEnds = activeMgr.ends

    // Verify active session still matches filter (in case user changes it mid-session)
    bool activeSessionMatches = sessionLevelsSessionSelect == "All" or activeMgr.name == sessionLevelsSessionSelect

    // Use stored session end time (set at session start) to handle edge case where
    // active session gets dropped from array after MAX_VWAP_HISTORY shifts
    bool stillInSession = not na(sessionEndTime) and time >= sessionStartTime and time < sessionEndTime and activeSessionMatches

    if stillInSession
        int elapsedMinutes = math.round((time - sessionStartTime) / MS_PER_MINUTE)
        if elapsedMinutes <= openRangeMinutes
            if high > openRangeHigh
                openRangeHigh := high
                orhBar := bar_index
            if low < openRangeLow
                openRangeLow := low
                orlBar := bar_index

        if elapsedMinutes <= ibMinutes
            if high > initialBalanceHigh
                initialBalanceHigh := high
                ibhBar := bar_index
            if low < initialBalanceLow
                initialBalanceLow := low
                iblBar := bar_index
// MULTI-SESSION VWAP CALCULATIONS
// Optimized: skip bars before oldest tracked session, cache per-bar values
// Cache showLabelsOnStart - doesn't change per bar
bool showLabelsOnStart = sessionBaseCondition and showAnchorLabels and showDailySessionVWAPs

// Global early skip: find earliest session start across all enabled managers (computed once)
var int globalOldestSessionStart = na
var int globalOldestAnchorStart = na
if barstate.isfirst
    if anySessionVWAPEnabled
        for i = 0 to 4
            SessionManager mgr = array.get(sessionManagers, i)
            if mgr.enabled and mgr.meetsTimeframe
                int startIdx = MAX_VWAP_HISTORY - mgr.historyCount
                int oldest = array.get(mgr.starts, startIdx)
                if not na(oldest) and (na(globalOldestSessionStart) or oldest < globalOldestSessionStart)
                    globalOldestSessionStart := oldest
    if anyAnchorEnabled
        int wkOldest = shouldComputeWeekly ? array.get(weeklyAnchorStartsArray, MAX_WEEKLY_HISTORY - weeklyAnchorCount) : na
        int mnOldest = shouldComputeMonthly ? array.get(monthlyAnchorStartsArray, MAX_MONTHLY_HISTORY - monthlyAnchorCount) : na
        int yrOldest = shouldComputeYearly ? array.get(yearlyAnchorStartsArray, MAX_YEARLY_HISTORY - yearlyAnchorCount) : na
        if not na(wkOldest)
            globalOldestAnchorStart := wkOldest
        if not na(mnOldest) and (na(globalOldestAnchorStart) or mnOldest < globalOldestAnchorStart)
            globalOldestAnchorStart := mnOldest
        if not na(yrOldest) and (na(globalOldestAnchorStart) or yrOldest < globalOldestAnchorStart)
            globalOldestAnchorStart := yrOldest

// Per-bar cached values
float barOhlc4Vol = not na(ohlc4) and not na(volume) ? ohlc4 * volume : na
bool hasVolume = not na(volume) and volume > 0
int prevTime = bar_index > 0 ? nz(time[1], 0) : 0
bool skipVWAPBar = not na(globalOldestSessionStart) and time < globalOldestSessionStart
bool skipAnchorBar = not na(globalOldestAnchorStart) and time < globalOldestAnchorStart

if anySessionVWAPEnabled and not na(barOhlc4Vol) and not skipVWAPBar and bar_index > 0
    for i = 0 to 4
        SessionManager mgr = array.get(sessionManagers, i)
        if not mgr.enabled or not mgr.meetsTimeframe
            continue
        int historyCountUser = mgr.historyCount
        int startIdx = MAX_VWAP_HISTORY - historyCountUser
        int oldestStart = array.get(mgr.starts, startIdx)
        if not na(oldestStart) and time < oldestStart
            continue
        bool isNYSessionVWAP = mgr.name == "New York"
        bool shouldAccumulate = not isNYSessionVWAP or not shouldFilterRTH or isNYSession

        for arrayIdx = startIdx to MAX_VWAP_HISTORY - 1
            int sessionStart = array.get(mgr.starts, arrayIdx)
            if na(sessionStart) or sessionStart > time
                continue

            bool isSessionStart = prevTime < sessionStart
            if isSessionStart and hasVolume
                array.set(mgr.sumSrc, arrayIdx, 0.0)
                array.set(mgr.sumVol, arrayIdx, 0.0)
                array.set(mgr.startBars, arrayIdx, bar_index)

            int sessionBarIdx = array.get(mgr.startBars, arrayIdx)
            if not na(sessionBarIdx) and shouldAccumulate
                float currentSumSrc = array.get(mgr.sumSrc, arrayIdx) + barOhlc4Vol
                float currentSumVol = array.get(mgr.sumVol, arrayIdx) + volume
                array.set(mgr.sumSrc, arrayIdx, currentSumSrc)
                array.set(mgr.sumVol, arrayIdx, currentSumVol)
                array.set(mgr.vwaps, arrayIdx, currentSumVol > 0 ? currentSumSrc / currentSumVol : na)

            if isSessionStart and showLabelsOnStart
                int nonHolidayRank = array.get(mgr.holidayRanks, arrayIdx)
                if nonHolidayRank > 0 and nonHolidayRank <= historyCountUser
                    deleteLabel(mgr.labels, arrayIdx)
                    int positionInHistory = nonHolidayRank - 1
                    color labelColor = array.get(mgr.preCalcColors, positionInHistory)
                    int labelTS = mgr.name == "Globex" ? sessionStart + 86400000 : sessionStart
                    bool isPrimary = mgr.name == primarySessionName
                    string txt = compactLabels ? (isPrimary ? "D" : getSessionAbbr(mgr.name)) + str.tostring(positionInHistory + 1) : mgr.name + " " + str.format_time(labelTS, "d MMM", mgr.timezone)
                    array.set(mgr.labels, arrayIdx, label.new(bar_index, high, txt, xloc=xloc.bar_index, yloc=yloc.abovebar, color=labelColor, textcolor=color.white, size=getLabelSize(anchorLabelSize), style=label.style_label_down))

// Detect array shifts and shift accumulators + recreate labels with updated position numbers
// Only check on last bar to avoid expensive getSessionStartsArray calls on every historical bar
if barstate.islast and anySessionVWAPEnabled
    for i = 0 to 4
        SessionManager mgr = array.get(sessionManagers, i)
        if mgr.enabled and mgr.meetsTimeframe
            array<int> currentStarts = getSessionStartsArray(mgr.name, MAX_VWAP_HISTORY)
            int newestStart = array.get(currentStarts, MAX_VWAP_HISTORY - 1)
            bool shifted = not na(mgr.prevMostRecentStart) and not na(newestStart) and newestStart != mgr.prevMostRecentStart

            if shifted
                array<int> currentEnds = getSessionEndsArray(mgr.name, MAX_VWAP_HISTORY)
                mgr.starts := currentStarts
                mgr.ends := currentEnds
                mgr.holidayRanks := calcHolidayRanks(currentStarts, mgr.name, isStock)
                mgr.prevMostRecentStart := newestStart
                shiftSessionArrays(mgr.starts, currentStarts, mgr.startBars, mgr.sumSrc, mgr.sumVol, mgr.vwaps)

                if mgr.historyCount != mgr.cachedHistoryCount
                    mgr.cachedHistoryCount := mgr.historyCount
                    for pos = 0 to MAX_VWAP_HISTORY - 1
                        array.set(mgr.preCalcColors, pos, getVWAPColor(mgr.col, mgr.colEnd, pos, mgr.historyCount - 1))

                for arrayIdx = 0 to MAX_VWAP_HISTORY - 1
                    int sessionStart = array.get(mgr.starts, arrayIdx)
                    int mgrSessionStartBar = array.get(mgr.startBars, arrayIdx)

                    int shiftNonHolidayRank = array.get(mgr.holidayRanks, arrayIdx)
                    bool shiftAnchorIsHoliday = shiftNonHolidayRank == 0
                    bool shiftShouldShow = not shiftAnchorIsHoliday and shiftNonHolidayRank <= mgr.historyCount

                    bool withinLookback = not na(mgrSessionStartBar) and mgrSessionStartBar <= bar_index and (bar_index - mgrSessionStartBar) < 5000

                    if not na(sessionStart) and withinLookback and time >= sessionStart and sessionStart <= time and showAnchorLabels and showDailySessionVWAPs and sessionBaseCondition and shiftShouldShow
                        deleteLabel(mgr.labels, arrayIdx)
                        int positionInHistory = shiftNonHolidayRank - 1
                        color labelColor = getVWAPColor(mgr.col, mgr.colEnd, positionInHistory, mgr.historyCount - 1)
                        bool isPrimarySession = mgr.name == primarySessionName
                        int labelTimestamp = mgr.name == "Globex" ? sessionStart + 86400000 : sessionStart
                        string sessionLabelText = compactLabels ? (isPrimarySession ? "D" + str.tostring(positionInHistory + 1) : getSessionAbbr(mgr.name) + str.tostring(positionInHistory + 1)) : mgr.name + " " + str.format_time(labelTimestamp, "d MMM", mgr.timezone)
                        label newLabel = label.new(mgrSessionStartBar, high[bar_index - mgrSessionStartBar], sessionLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=labelColor, textcolor=color.white, size=getLabelSize(anchorLabelSize), style=label.style_label_down)
                        array.set(mgr.labels, arrayIdx, newLabel)

// Plot VWAPs - up to 5 historical sessions per type
SessionManager londonMgr = array.get(sessionManagers, 0)
SessionManager nyMgr = array.get(sessionManagers, 1)
SessionManager globexMgr = array.get(sessionManagers, 2)
SessionManager sydneyMgr = array.get(sessionManagers, 3)
SessionManager tokyoMgr = array.get(sessionManagers, 4)

bool vwapBase = sessionBaseCondition and showDailySessionVWAPs
bool skipLN = showWeeklyAnchorVWAP and primarySessionName == "London" and currentSessionIsWeeklyAnchor
bool skipNY = showWeeklyAnchorVWAP and primarySessionName == "New York" and currentSessionIsWeeklyAnchor
bool skipGLX = showWeeklyAnchorVWAP and primarySessionName == "Globex" and currentSessionIsWeeklyAnchor
bool skipSYD = showWeeklyAnchorVWAP and primarySessionName == "Sydney" and currentSessionIsWeeklyAnchor
bool skipTKY = showWeeklyAnchorVWAP and primarySessionName == "Tokyo" and currentSessionIsWeeklyAnchor

plot(vwapVal(vwapBase, londonMgr.meetsTimeframe, londonMgr.enabled, londonMgr.historyCount, 1, londonMgr.vwaps, 0, skipLN), "LN1", array.get(londonMgr.preCalcColors, 0), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

plot(vwapVal(vwapBase, nyMgr.meetsTimeframe, nyMgr.enabled, nyMgr.historyCount, 1, nyMgr.vwaps, 0, skipNY), "NY1", array.get(nyMgr.preCalcColors, 0), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(vwapVal(vwapBase, nyMgr.meetsTimeframe, nyMgr.enabled, nyMgr.historyCount, 2, nyMgr.vwaps, 1, false), "NY2", array.get(nyMgr.preCalcColors, 1), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(vwapVal(vwapBase, nyMgr.meetsTimeframe, nyMgr.enabled, nyMgr.historyCount, 3, nyMgr.vwaps, 2, false), "NY3", array.get(nyMgr.preCalcColors, 2), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(vwapVal(vwapBase, nyMgr.meetsTimeframe, nyMgr.enabled, nyMgr.historyCount, 4, nyMgr.vwaps, 3, false), "NY4", array.get(nyMgr.preCalcColors, 3), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(vwapVal(vwapBase, nyMgr.meetsTimeframe, nyMgr.enabled, nyMgr.historyCount, 5, nyMgr.vwaps, 4, false), "NY5", array.get(nyMgr.preCalcColors, 4), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

plot(vwapVal(vwapBase, globexMgr.meetsTimeframe, globexMgr.enabled, globexMgr.historyCount, 1, globexMgr.vwaps, 0, skipGLX), "GLX1", array.get(globexMgr.preCalcColors, 0), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(vwapVal(vwapBase, globexMgr.meetsTimeframe, globexMgr.enabled, globexMgr.historyCount, 2, globexMgr.vwaps, 1, false), "GLX2", array.get(globexMgr.preCalcColors, 1), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(vwapVal(vwapBase, globexMgr.meetsTimeframe, globexMgr.enabled, globexMgr.historyCount, 3, globexMgr.vwaps, 2, false), "GLX3", array.get(globexMgr.preCalcColors, 2), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(vwapVal(vwapBase, globexMgr.meetsTimeframe, globexMgr.enabled, globexMgr.historyCount, 4, globexMgr.vwaps, 3, false), "GLX4", array.get(globexMgr.preCalcColors, 3), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(vwapVal(vwapBase, globexMgr.meetsTimeframe, globexMgr.enabled, globexMgr.historyCount, 5, globexMgr.vwaps, 4, false), "GLX5", array.get(globexMgr.preCalcColors, 4), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

plot(vwapVal(vwapBase, sydneyMgr.meetsTimeframe, sydneyMgr.enabled, sydneyMgr.historyCount, 1, sydneyMgr.vwaps, 0, skipSYD), "SYD1", array.get(sydneyMgr.preCalcColors, 0), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

plot(vwapVal(vwapBase, tokyoMgr.meetsTimeframe, tokyoMgr.enabled, tokyoMgr.historyCount, 1, tokyoMgr.vwaps, 0, skipTKY), "TKY1", array.get(tokyoMgr.preCalcColors, 0), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

// WEEKLY/MONTHLY/YEARLY ANCHOR VWAP CALCULATIONS
SessionManager primaryMgr = switch primarySessionName
    "London" => londonMgr
    "New York" => nyMgr
    "Globex" => globexMgr
    "Sydney" => sydneyMgr
    => tokyoMgr

processAnchorPeriod(bool shouldCompute, int anchorCount, int maxHistory, array<int> startsArray, array<float> sumSrcArray, array<float> sumVolArray, array<float> vwapsArray, array<label> labelsArray, string labelPrefix, color colorAnchor, color colorAnchorEnd, bool shouldAccumulate, bool isNewestSlot) =>
    bool sessionFlag = false
    if shouldCompute and not na(barOhlc4Vol) and not skipAnchorBar and bar_index > 0
        int startIdx = maxHistory - anchorCount
        for idx = startIdx to maxHistory - 1
            int anchorStart = array.get(startsArray, idx)
            if na(anchorStart) or anchorStart > time
                continue
            bool atAnchorStart = prevTime < anchorStart
            if atAnchorStart
                array.set(sumSrcArray, idx, 0.0)
                array.set(sumVolArray, idx, 0.0)
                if idx == maxHistory - 1 and isNewestSlot
                    sessionFlag := (anchorStart == array.get(primaryMgr.starts, MAX_VWAP_HISTORY - 1))
                if showAnchorLabels
                    createAnchorLabel(labelsArray, idx, anchorStart, labelPrefix, (maxHistory - 1) - idx, colorAnchor, colorAnchorEnd, anchorCount - 1, primarySessionTZ, primarySessionName)
            if shouldAccumulate
                float sumSrc = array.get(sumSrcArray, idx) + barOhlc4Vol
                float sumVol = array.get(sumVolArray, idx) + volume
                array.set(sumSrcArray, idx, sumSrc)
                array.set(sumVolArray, idx, sumVol)
                array.set(vwapsArray, idx, sumVol > 0 ? sumSrc / sumVol : na)
    sessionFlag

// Determine if daily sessions are actively displayed
bool dailySessionsActive = showDailySessionVWAPs and enableSessionFeatures and (meetsPrimarySessionTimeframe or meetsOtherSessionsTimeframe)

// Determine effective history counts based on lower timeframe visibility
int effectiveWeeklyCount = dailySessionsActive ? weeklyAnchorCountWhenDaily : weeklyAnchorCount
int effectiveMonthlyCount = (showWeeklyAnchorVWAP and enableSessionFeatures and meetsWeeklyAnchorTimeframe) ? monthlyAnchorCountWhenWeekly : monthlyAnchorCount
int effectiveYearlyCount = (showMonthlyAnchorVWAP and enableSessionFeatures and meetsMonthlyAnchorTimeframe) ? yearlyAnchorCountWhenMonthly : yearlyAnchorCount

currentSessionIsWeeklyAnchor := processAnchorPeriod(shouldComputeWeekly, effectiveWeeklyCount, MAX_WEEKLY_HISTORY, weeklyAnchorStartsArray, weeklyAnchorSumSrc, weeklyAnchorSumVol, weeklyAnchorVWAPs, weeklyAnchorLabels, "W", colorWeeklyAnchor, colorWeeklyAnchorEnd, not shouldFilterRTH or isNYSession, true)

bool wklyBase = showWeeklyAnchorVWAP and enableSessionFeatures and meetsWeeklyAnchorTimeframe
plot(anchorVal(wklyBase, 5, MAX_WEEKLY_HISTORY, effectiveWeeklyCount, weeklyAnchorVWAPs), "W1", array.get(weeklyColors, 5), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(wklyBase, 4, MAX_WEEKLY_HISTORY, effectiveWeeklyCount, weeklyAnchorVWAPs), "W2", array.get(weeklyColors, 4), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(wklyBase, 3, MAX_WEEKLY_HISTORY, effectiveWeeklyCount, weeklyAnchorVWAPs), "W3", array.get(weeklyColors, 3), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(wklyBase, 2, MAX_WEEKLY_HISTORY, effectiveWeeklyCount, weeklyAnchorVWAPs), "W4", array.get(weeklyColors, 2), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(wklyBase, 1, MAX_WEEKLY_HISTORY, effectiveWeeklyCount, weeklyAnchorVWAPs), "W5", array.get(weeklyColors, 1), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(wklyBase, 0, MAX_WEEKLY_HISTORY, effectiveWeeklyCount, weeklyAnchorVWAPs), "W6", array.get(weeklyColors, 0), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

bool mnthBase = showMonthlyAnchorVWAP and enableSessionFeatures and meetsMonthlyAnchorTimeframe
currentSessionIsMonthlyAnchor := processAnchorPeriod(shouldComputeMonthly, effectiveMonthlyCount, MAX_MONTHLY_HISTORY, monthlyAnchorStartsArray, monthlyAnchorSumSrc, monthlyAnchorSumVol, monthlyAnchorVWAPs, monthlyAnchorLabels, "M", colorMonthlyAnchor, colorMonthlyAnchorEnd, not shouldFilterRTH or isNYSession, true)

plot(anchorVal(mnthBase, 5, MAX_MONTHLY_HISTORY, effectiveMonthlyCount, monthlyAnchorVWAPs), "M1", array.get(monthlyColors, 5), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(mnthBase, 4, MAX_MONTHLY_HISTORY, effectiveMonthlyCount, monthlyAnchorVWAPs), "M2", array.get(monthlyColors, 4), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(mnthBase, 3, MAX_MONTHLY_HISTORY, effectiveMonthlyCount, monthlyAnchorVWAPs), "M3", array.get(monthlyColors, 3), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(mnthBase, 2, MAX_MONTHLY_HISTORY, effectiveMonthlyCount, monthlyAnchorVWAPs), "M4", array.get(monthlyColors, 2), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(mnthBase, 1, MAX_MONTHLY_HISTORY, effectiveMonthlyCount, monthlyAnchorVWAPs), "M5", array.get(monthlyColors, 1), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(mnthBase, 0, MAX_MONTHLY_HISTORY, effectiveMonthlyCount, monthlyAnchorVWAPs), "M6", array.get(monthlyColors, 0), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

currentSessionIsYearlyAnchor := processAnchorPeriod(shouldComputeYearly, effectiveYearlyCount, MAX_YEARLY_HISTORY, yearlyAnchorStartsArray, yearlyAnchorSumSrc, yearlyAnchorSumVol, yearlyAnchorVWAPs, yearlyAnchorLabels, "Y", colorYearlyAnchor, colorYearlyAnchorEnd, not shouldFilterRTH or isNYSession, true)

bool yrlyBase = showYearlyAnchorVWAP and enableSessionFeatures and meetsYearlyAnchorTimeframe
plot(anchorVal(yrlyBase, 1, MAX_YEARLY_HISTORY, effectiveYearlyCount, yearlyAnchorVWAPs), "Y1", array.get(yearlyColors, 1), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(anchorVal(yrlyBase, 0, MAX_YEARLY_HISTORY, effectiveYearlyCount, yearlyAnchorVWAPs), "Y2", array.get(yearlyColors, 0), sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

var box boxOpenRange = na
var box boxInitialBalanceUpper = na
var box boxInitialBalanceLower = na

// KEY LEVELS RENDERING - only on last bar
var int lastRenderBarIndex = na

if barstate.islast and (na(lastRenderBarIndex) or bar_index != lastRenderBarIndex)
    lastRenderBarIndex := bar_index

    // Calculate line start position with hard limit to prevent lines getting too long
    int startBar = math.max(0, bar_index - globalLineLengthBars)

    // Determine session line start based on user preference, but reset to configured length if beyond hard limit
    int sessionOpenBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > MAX_LINE_DISTANCE ? startBar : sessionStartBar) : startBar
    int openPriceStartBar = sessionLineStartMode == "Level Established" and not na(openPriceBar) ? (bar_index - openPriceBar > MAX_LINE_DISTANCE ? startBar : openPriceBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orhStartBar = sessionLineStartMode == "Level Established" and not na(orhBar) ? (bar_index - orhBar > MAX_LINE_DISTANCE ? startBar : orhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orlStartBar = sessionLineStartMode == "Level Established" and not na(orlBar) ? (bar_index - orlBar > MAX_LINE_DISTANCE ? startBar : orlBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int ibhStartBar = sessionLineStartMode == "Level Established" and not na(ibhBar) ? (bar_index - ibhBar > MAX_LINE_DISTANCE ? startBar : ibhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int iblStartBar = sessionLineStartMode == "Level Established" and not na(iblBar) ? (bar_index - iblBar > MAX_LINE_DISTANCE ? startBar : iblBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)

    string labelSizeActual = getLabelSize(globalLabelSize)

    // Convert prices to integer ticks for deduplication
    int athTicks = priceToTicks(ath)
    int pyhTicks = priceToTicks(pyh)
    int pylTicks = priceToTicks(pyl)
    int pmhTicks = priceToTicks(pmh)
    int pmlTicks = priceToTicks(pml)
    int pwhTicks = priceToTicks(pwh)
    int pwlTicks = priceToTicks(pwl)
    int pdhTicks = priceToTicks(pdh)
    int pdlTicks = priceToTicks(pdl)
    int cyhTicks = priceToTicks(cyh)
    int cylTicks = priceToTicks(cyl)
    int cmhTicks = priceToTicks(cmh)
    int cmlTicks = priceToTicks(cml)
    int cwhTicks = priceToTicks(cwh)
    int cwlTicks = priceToTicks(cwl)
    int cdhTicks = priceToTicks(cdh)
    int cdlTicks = priceToTicks(cdl)

    // Pivot points in ticks
    int pivotPTicks = priceToTicks(pivotP)
    int pivotR1Ticks = priceToTicks(pivotR1)
    int pivotR2Ticks = priceToTicks(pivotR2)
    int pivotR3Ticks = priceToTicks(pivotR3)
    int pivotS1Ticks = priceToTicks(pivotS1)
    int pivotS2Ticks = priceToTicks(pivotS2)
    int pivotS3Ticks = priceToTicks(pivotS3)

    // Session levels in ticks
    int ibhTicks = priceToTicks(initialBalanceHigh)
    int iblTicks = priceToTicks(initialBalanceLow)
    int orhTicks = priceToTicks(openRangeHigh)
    int orlTicks = priceToTicks(openRangeLow)
    int openTicks = priceToTicks(sessionOpen)

    // Build price->label map (merges duplicates with "/")
    // Priority: Session Levels > Pivot Points > Key Levels
    var map<int, string> priceLabels = map.new<int, string>()
    map.clear(priceLabels)

    // Session levels first (highest priority)
    bool shouldAddSessionToMap = showSessionMarkersCondition and not na(sessionOpen)
    if shouldAddSessionToMap
        if showOpenPrice
            addToMap(priceLabels, sessionOpen, "Open")
        if showOpenRange and not na(openRangeHigh)
            addToMap(priceLabels, openRangeHigh, "ORH")
        if showOpenRange and not na(openRangeLow)
            addToMap(priceLabels, openRangeLow, "ORL")
        if showInitialBalance and not na(initialBalanceHigh)
            addToMap(priceLabels, initialBalanceHigh, "IBH")
        if showInitialBalance and not na(initialBalanceLow)
            addToMap(priceLabels, initialBalanceLow, "IBL")

    // Pivot points second (after session, before key levels)
    if showPivotsCondition
        addIf(priceLabels, showPivotP, pivotP, "P"), addIf(priceLabels, showPivotR1, pivotR1, "R1")
        addIf(priceLabels, showPivotR2, pivotR2, "R2"), addIf(priceLabels, showPivotR3, pivotR3, "R3")
        addIf(priceLabels, showPivotS1, pivotS1, "S1"), addIf(priceLabels, showPivotS2, pivotS2, "S2")
        addIf(priceLabels, showPivotS3, pivotS3, "S3")

    // Key levels (lower priority)
    if showKeyLevelsCondition
        addIf(priceLabels, showATH, ath, "ATH")
        addIf(priceLabels, showPYH, pyh, "PYH"), addIf(priceLabels, showPYL, pyl, "PYL")
        addIf(priceLabels, showPMH, pmh, "PMH"), addIf(priceLabels, showPML, pml, "PML")
        addIf(priceLabels, showPWH, pwh, "PWH"), addIf(priceLabels, showPWL, pwl, "PWL")
        addIf(priceLabels, showPDH, pdh, "PDH"), addIf(priceLabels, showPDL, pdl, "PDL")
        addIf(priceLabels, showCYH, cyh, "CYH"), addIf(priceLabels, showCYL, cyl, "CYL")
        addIf(priceLabels, showCMH, cmh, "CMH"), addIf(priceLabels, showCML, cml, "CML")
        addIf(priceLabels, showCWH, cwh, "CWH"), addIf(priceLabels, showCWL, cwl, "CWL")
        addIf(priceLabels, showCDH, cdh, "CDH"), addIf(priceLabels, showCDL, cdl, "CDL")

    var array<int> renderedPrices = array.new<int>()
    array.clear(renderedPrices)

    // Initialize level arrays on first render
    if array.size(sessionLevels) == 0
        addLevel(sessionLevels, "Open", showOpenPrice, sessionOpen, openTicks, openPriceStartBar, colorOpenPrice, sessionLevelsLineWidth, sessionLevelsLineStyle)
        addLevel(sessionLevels, "ORH", showOpenRange, openRangeHigh, orhTicks, orhStartBar, colorORH, sessionLevelsLineWidth, sessionLevelsLineStyle)
        addLevel(sessionLevels, "ORL", showOpenRange, openRangeLow, orlTicks, orlStartBar, colorORL, sessionLevelsLineWidth, sessionLevelsLineStyle)
        addLevel(sessionLevels, "IBH", showInitialBalance, initialBalanceHigh, ibhTicks, ibhStartBar, colorIBH, sessionLevelsLineWidth, sessionLevelsLineStyle)
        addLevel(sessionLevels, "IBL", showInitialBalance, initialBalanceLow, iblTicks, iblStartBar, colorIBL, sessionLevelsLineWidth, sessionLevelsLineStyle)

        addLevel(pivotLevels, "P", showPivotP, pivotP, pivotPTicks, startBar, pivotColorP, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "R1", showPivotR1, pivotR1, pivotR1Ticks, startBar, pivotColorR1, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "R2", showPivotR2, pivotR2, pivotR2Ticks, startBar, pivotColorR2, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "R3", showPivotR3, pivotR3, pivotR3Ticks, startBar, pivotColorR3, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "S1", showPivotS1, pivotS1, pivotS1Ticks, startBar, pivotColorS1, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "S2", showPivotS2, pivotS2, pivotS2Ticks, startBar, pivotColorS2, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "S3", showPivotS3, pivotS3, pivotS3Ticks, startBar, pivotColorS3, pivotLineWidth, pivotLineStyle)

        addLevel(keyLevels, "ATH", showATH, ath, athTicks, startBar, colorATH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PYH", showPYH, pyh, pyhTicks, startBar, colorPYH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PYL", showPYL, pyl, pylTicks, startBar, colorPYL, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PMH", showPMH, pmh, pmhTicks, startBar, colorPMH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PML", showPML, pml, pmlTicks, startBar, colorPML, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PWH", showPWH, pwh, pwhTicks, startBar, colorPWH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PWL", showPWL, pwl, pwlTicks, startBar, colorPWL, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PDH", showPDH, pdh, pdhTicks, startBar, colorPDH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PDL", showPDL, pdl, pdlTicks, startBar, colorPDL, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CYH", showCYH, cyh, cyhTicks, startBar, colorCYH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CYL", showCYL, cyl, cylTicks, startBar, colorCYL, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CMH", showCMH, cmh, cmhTicks, startBar, colorCMH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CML", showCML, cml, cmlTicks, startBar, colorCML, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CWH", showCWH, cwh, cwhTicks, startBar, colorCWH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CWL", showCWL, cwl, cwlTicks, startBar, colorCWL, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CDH", showCDH, cdh, cdhTicks, startBar, colorCDH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CDL", showCDL, cdl, cdlTicks, startBar, colorCDL, keyLevelsLineWidth, keyLevelsLineStyle)
    else
        // Update level data each bar
        array.get(sessionLevels, 0).update(showOpenPrice, sessionOpen, openTicks, openPriceStartBar)
        array.get(sessionLevels, 1).update(showOpenRange, openRangeHigh, orhTicks, orhStartBar)
        array.get(sessionLevels, 2).update(showOpenRange, openRangeLow, orlTicks, orlStartBar)
        array.get(sessionLevels, 3).update(showInitialBalance, initialBalanceHigh, ibhTicks, ibhStartBar)
        array.get(sessionLevels, 4).update(showInitialBalance, initialBalanceLow, iblTicks, iblStartBar)

        array.get(pivotLevels, 0).update(showPivotP, pivotP, pivotPTicks, startBar)
        array.get(pivotLevels, 1).update(showPivotR1, pivotR1, pivotR1Ticks, startBar)
        array.get(pivotLevels, 2).update(showPivotR2, pivotR2, pivotR2Ticks, startBar)
        array.get(pivotLevels, 3).update(showPivotR3, pivotR3, pivotR3Ticks, startBar)
        array.get(pivotLevels, 4).update(showPivotS1, pivotS1, pivotS1Ticks, startBar)
        array.get(pivotLevels, 5).update(showPivotS2, pivotS2, pivotS2Ticks, startBar)
        array.get(pivotLevels, 6).update(showPivotS3, pivotS3, pivotS3Ticks, startBar)

        array.get(keyLevels, 0).update(showATH, ath, athTicks, startBar)
        array.get(keyLevels, 1).update(showPYH, pyh, pyhTicks, startBar)
        array.get(keyLevels, 2).update(showPYL, pyl, pylTicks, startBar)
        array.get(keyLevels, 3).update(showPMH, pmh, pmhTicks, startBar)
        array.get(keyLevels, 4).update(showPML, pml, pmlTicks, startBar)
        array.get(keyLevels, 5).update(showPWH, pwh, pwhTicks, startBar)
        array.get(keyLevels, 6).update(showPWL, pwl, pwlTicks, startBar)
        array.get(keyLevels, 7).update(showPDH, pdh, pdhTicks, startBar)
        array.get(keyLevels, 8).update(showPDL, pdl, pdlTicks, startBar)
        array.get(keyLevels, 9).update(showCYH, cyh, cyhTicks, startBar)
        array.get(keyLevels, 10).update(showCYL, cyl, cylTicks, startBar)
        array.get(keyLevels, 11).update(showCMH, cmh, cmhTicks, startBar)
        array.get(keyLevels, 12).update(showCML, cml, cmlTicks, startBar)
        array.get(keyLevels, 13).update(showCWH, cwh, cwhTicks, startBar)
        array.get(keyLevels, 14).update(showCWL, cwl, cwlTicks, startBar)
        array.get(keyLevels, 15).update(showCDH, cdh, cdhTicks, startBar)
        array.get(keyLevels, 16).update(showCDL, cdl, cdlTicks, startBar)

    // SESSION LEVELS RENDERING
    string sessionLineStyleActual = getLineStyle(sessionLevelsLineStyle)
    bool shouldShowSessionLevels = sessionLevelsVisible and not na(activeSessionIndex) and not na(sessionOpen)
    for level in sessionLevels
        level.render(shouldShowSessionLevels, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter, true)

    // Open Range Background Shading
    if shouldShowSessionLevels and showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        int boxORStartBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > MAX_LINE_DISTANCE ? startBar : sessionStartBar) : startBar
        boxOpenRange := updateBox(boxOpenRange, boxORStartBar, openRangeHigh, bar_index, openRangeLow, colorOpenRangeShade)
    else if not na(boxOpenRange)
        box.delete(boxOpenRange), boxOpenRange := na



    // Initial Balance Background Shading
    if shouldShowSessionLevels and showInitialBalance and shadeInitialBalance and not na(initialBalanceHigh) and not na(initialBalanceLow)
        int boxIBStartBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > MAX_LINE_DISTANCE ? startBar : sessionStartBar) : startBar
        bool splitIBBox = showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        if splitIBBox
            if initialBalanceHigh > openRangeHigh
                boxInitialBalanceUpper := updateBox(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh, bar_index, openRangeHigh, colorInitialBalanceShade)
            else if not na(boxInitialBalanceUpper)
                box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
            if initialBalanceLow < openRangeLow
                boxInitialBalanceLower := updateBox(boxInitialBalanceLower, boxIBStartBar, openRangeLow, bar_index, initialBalanceLow, colorInitialBalanceShade)
            else if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
        else
            boxInitialBalanceUpper := updateBox(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh, bar_index, initialBalanceLow, colorInitialBalanceShade)
            if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
    else
        if not na(boxInitialBalanceUpper)
            box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
        if not na(boxInitialBalanceLower)
            box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na

    // PIVOT POINTS RENDERING
    for level in pivotLevels
        level.render(showPivotsCondition, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)

    // KEY LEVELS RENDERING
    for level in keyLevels
        level.render(showKeyLevelsCondition, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)
