// MIT License
//
// Copyright (c) 2025 User-3090
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//@version=6
indicator("Key Levels", overlay=true, max_lines_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸŒ GLOBAL SETTINGS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
globalLabelSize = input.string("Normal", "Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="ğŸŒ Global Settings", tooltip="Label size for all levels")
globalShowPriceValues = input.bool(false, "Show Prices in Labels", group="ğŸŒ Global Settings", tooltip="Show price in labels: 'PDH (4523.50)' vs 'PDH'")
globalLineLengthBars = input.int(50, "Line Length (Bars)", minval=10, maxval=200, group="ğŸŒ Global Settings", tooltip="Bars to extend lines backward from current bar (hard limit for lines: 200)")

useATRFilter = input.bool(true, "Hide Distant Levels", group="ğŸŒ Global Settings", tooltip="Only show levels within specified ATR distance from current price")
atrMultiplier = input.float(1.0, "  Distance (ATR)", minval=1.0, maxval=10.0, step=0.5, group="ğŸŒ Global Settings", tooltip="Hide levels beyond this many ATRs from current price")
atrPeriod = input.int(20, "  ATR Period (Days)", minval=1, maxval=500, group="ğŸŒ Global Settings", tooltip="Number of days for Average True Range calculation")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ• SESSION SELECTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showSessionLevels = input.bool(true, "Enable Session Levels", group="ğŸ• Session Selection", tooltip="Master toggle: Show session-based levels (Open, Open Range, Initial Balance, VWAP)")
sessionLevelsMode = input.string("Only Futures", "Instrument Filter", options=["All Instruments", "Only Futures"], group="ğŸ• Session Selection", tooltip="All Instruments: Show on all markets | Only Futures: Futures only")
sessionLevelsMaxTimeframe = input.string("15m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ• Session Selection", tooltip="Hide session levels on timeframes above this")

enableLondon = input.bool(true, "London", inline="LON", group="ğŸ• Session Selection")
colorLondon = input.color(#FF9800, "", inline="LON", group="ğŸ• Session Selection", tooltip="0800-1630 GMT | European open")
enableNewYork = input.bool(true, "New York", inline="NY", group="ğŸ• Session Selection")
colorNewYork = input.color(#2962FF, "", inline="NY", group="ğŸ• Session Selection", tooltip="0930-1600 EST | US RTH")
enableSydney = input.bool(false, "Sydney/ETH", inline="SYD", group="ğŸ• Session Selection")
colorSydney = input.color(#4CAF50, "", inline="SYD", group="ğŸ• Session Selection", tooltip="1000-1600 AEDT | ~1800 ET (US futures ETH open)")
enableTokyo = input.bool(false, "Tokyo", inline="TKY", group="ğŸ• Session Selection")
colorTokyo = input.color(#E91E63, "", inline="TKY", group="ğŸ• Session Selection", tooltip="0900-1500 JST | Asian session")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“Š SESSION VWAP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showSessionVWAP = input.bool(true, "Show VWAP", group="ğŸ“Š Session VWAP", tooltip="Volume-weighted average price for each session")
sessionVWAPLineWidth = input.int(4, "Line Width", minval=1, maxval=5, group="ğŸ“Š Session VWAP")
sessionVWAPLineStyleInput = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“Š Session VWAP")
sessionVWAPLineStyle = sessionVWAPLineStyleInput == "Solid" ? plot.linestyle_solid : sessionVWAPLineStyleInput == "Dashed" ? plot.linestyle_dashed : plot.linestyle_dotted

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ·ï¸ SESSION LABELS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showSessionLabels = input.bool(true, "Show Session Labels", group="ğŸ·ï¸ Session Labels", tooltip="Show session start labels with date")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ SESSION LEVEL LINES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sessionLevelsLineWidth = input.int(3, "Line Width", minval=1, maxval=5, group="ğŸ“ Session Level Lines", tooltip="Width for Open/ORH/ORL/IBH/IBL lines")
sessionLevelsLineStyle = input.string("Dotted", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“ Session Level Lines")
sessionLineStartMode = input.string("Level Established", "Line Start Mode", options=["Level Established", "Session Open", "Fixed Bars Back"], group="ğŸ“ Session Level Lines", tooltip="Level Established: From where level was created\nSession Open: From session start\nFixed Bars Back: Use global line length")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ”” OPENING PRICE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showOpenPrice = input.bool(true, "Show Opening Price", inline="OP", group="ğŸ”” Opening Price")
colorOpenPrice = input.color(#fbbe30, "Color", inline="OP", group="ğŸ”” Opening Price", tooltip="First price at session open")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“¦ OPEN RANGE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showOpenRange = input.bool(true, "Show Open Range", group="ğŸ“¦ Open Range", tooltip="High/Low in first minutes after session open (breakout levels)")
openRangePeriod = input.string("15m", "Period", options=["1m", "5m", "15m"], group="ğŸ“¦ Open Range")
colorORH = input.color(#00b8bd, "High Color", group="ğŸ“¦ Open Range")
colorORL = input.color(#b51b00, "Low Color", group="ğŸ“¦ Open Range")
shadeOpenRange = input.bool(true, "Shade Background", group="ğŸ“¦ Open Range")
colorOpenRangeShade = input.color(color.new(color.gray, 90), "Shade Color", group="ğŸ“¦ Open Range", tooltip="Background shading between ORH and ORL")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ¯ INITIAL BALANCE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showInitialBalance = input.bool(true, "Show Initial Balance", group="ğŸ¯ Initial Balance", tooltip="High/Low in first 30m-1h (institutional reference range)")
initialBalancePeriod = input.string("1h", "Period", options=["30m", "1h"], group="ğŸ¯ Initial Balance")
colorIBH = input.color(#81ce6f, "High Color", group="ğŸ¯ Initial Balance")
colorIBL = input.color(#e43b38, "Low Color", group="ğŸ¯ Initial Balance")
shadeInitialBalance = input.bool(true, "Shade Background", group="ğŸ¯ Initial Balance")
colorInitialBalanceShade = input.color(color.new(color.gray, 90), "Shade Color", group="ğŸ¯ Initial Balance", tooltip="Background shading between IBH and IBL")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ”„ PIVOT POINTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showPivots = input.bool(true, "Enable Pivot Points", group="ğŸ”„ Pivot Points", tooltip="Traditional pivots from previous day H/L/C")
pivotMaxTimeframe = input.string("4h", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ”„ Pivot Points", tooltip="Hide on timeframes above this")
pivotLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ”„ Pivot Points")
pivotLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ”„ Pivot Points")

showPivotP = input.bool(false, "P", inline="pivotP", group="ğŸ”„ Pivot Points")
pivotColorP = input.color(#808080, "", inline="pivotP", group="ğŸ”„ Pivot Points", tooltip="Central pivot: (High + Low + Close) / 3")

showPivotR1 = input.bool(false, "R1", inline="pivotR", group="ğŸ”„ Pivot Points")
pivotColorR1 = input.color(#449955, "", inline="pivotR", group="ğŸ”„ Pivot Points")
showPivotR2 = input.bool(true, "R2", inline="pivotR", group="ğŸ”„ Pivot Points")
pivotColorR2 = input.color(#449955, "", inline="pivotR", group="ğŸ”„ Pivot Points")
showPivotR3 = input.bool(true, "R3", inline="pivotR", group="ğŸ”„ Pivot Points")
pivotColorR3 = input.color(#81ce6f, "", inline="pivotR", group="ğŸ”„ Pivot Points", tooltip="Resistance levels")

showPivotS1 = input.bool(false, "S1", inline="pivotS", group="ğŸ”„ Pivot Points")
pivotColorS1 = input.color(#b51b00, "", inline="pivotS", group="ğŸ”„ Pivot Points")
showPivotS2 = input.bool(true, "S2", inline="pivotS", group="ğŸ”„ Pivot Points")
pivotColorS2 = input.color(#b51b00, "", inline="pivotS", group="ğŸ”„ Pivot Points")
showPivotS3 = input.bool(true, "S3", inline="pivotS", group="ğŸ”„ Pivot Points")
pivotColorS3 = input.color(#d37666, "", inline="pivotS", group="ğŸ”„ Pivot Points", tooltip="Support levels")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ˆ KEY LEVELS - GENERAL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showKeyLevels = input.bool(true, "Enable Key Levels", group="ğŸ“ˆ Key Levels", tooltip="Show Previous/Current Day/Week/Month/Year levels + ATH")
keyLevelsMode = input.string("Only Futures", "Instrument Filter", options=["All Instruments", "Only Futures"], group="ğŸ“ˆ Key Levels", tooltip="All Instruments: Show on all markets | Only Futures: Futures only")
keyLevelsMaxTimeframe = input.string("30m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ“ˆ Key Levels", tooltip="Hide on timeframes above this")
keyLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ“ˆ Key Levels")
keyLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“ˆ Key Levels")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“… DAILY LEVELS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showPDH = input.bool(true, "PDH", inline="PD", group="ğŸ“… Daily Levels")
colorPDH = input.color(#81ce6f, "", inline="PD", group="ğŸ“… Daily Levels")
showPDL = input.bool(true, "PDL", inline="PD", group="ğŸ“… Daily Levels")
colorPDL = input.color(#d37666, "", inline="PD", group="ğŸ“… Daily Levels", tooltip="Previous Day High/Low")

showCDH = input.bool(true, "CDH", inline="CD", group="ğŸ“… Daily Levels")
colorCDH = input.color(#a8e6a1, "", inline="CD", group="ğŸ“… Daily Levels")
showCDL = input.bool(true, "CDL", inline="CD", group="ğŸ“… Daily Levels")
colorCDL = input.color(#e8a090, "", inline="CD", group="ğŸ“… Daily Levels", tooltip="Current Day High/Low (developing)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“† WEEKLY LEVELS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showPWH = input.bool(true, "PWH", inline="PW", group="ğŸ“† Weekly Levels")
colorPWH = input.color(#449955, "", inline="PW", group="ğŸ“† Weekly Levels")
showPWL = input.bool(true, "PWL", inline="PW", group="ğŸ“† Weekly Levels")
colorPWL = input.color(#b51b00, "", inline="PW", group="ğŸ“† Weekly Levels", tooltip="Previous Week High/Low")

showCWH = input.bool(true, "CWH", inline="CW", group="ğŸ“† Weekly Levels")
colorCWH = input.color(#6bb370, "", inline="CW", group="ğŸ“† Weekly Levels")
showCWL = input.bool(true, "CWL", inline="CW", group="ğŸ“† Weekly Levels")
colorCWL = input.color(#d84530, "", inline="CW", group="ğŸ“† Weekly Levels", tooltip="Current Week High/Low (developing)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ—“ï¸ MONTHLY LEVELS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showPMH = input.bool(true, "PMH", inline="PM", group="ğŸ—“ï¸ Monthly Levels")
colorPMH = input.color(#2e8b3a, "", inline="PM", group="ğŸ—“ï¸ Monthly Levels")
showPML = input.bool(true, "PML", inline="PM", group="ğŸ—“ï¸ Monthly Levels")
colorPML = input.color(#8b1500, "", inline="PM", group="ğŸ—“ï¸ Monthly Levels", tooltip="Previous Month High/Low")

showCMH = input.bool(true, "CMH", inline="CM", group="ğŸ—“ï¸ Monthly Levels")
colorCMH = input.color(#50a555, "", inline="CM", group="ğŸ—“ï¸ Monthly Levels")
showCML = input.bool(true, "CML", inline="CM", group="ğŸ—“ï¸ Monthly Levels")
colorCML = input.color(#a83020, "", inline="CM", group="ğŸ—“ï¸ Monthly Levels", tooltip="Current Month High/Low (developing)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“… YEARLY LEVELS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showPYH = input.bool(true, "PYH", inline="PY", group="ğŸ“… Yearly Levels")
colorPYH = input.color(#1e6b28, "", inline="PY", group="ğŸ“… Yearly Levels")
showPYL = input.bool(true, "PYL", inline="PY", group="ğŸ“… Yearly Levels")
colorPYL = input.color(#6b0f00, "", inline="PY", group="ğŸ“… Yearly Levels", tooltip="Previous Year High/Low")

showCYH = input.bool(true, "CYH", inline="CY", group="ğŸ“… Yearly Levels")
colorCYH = input.color(#3a8540, "", inline="CY", group="ğŸ“… Yearly Levels")
showCYL = input.bool(true, "CYL", inline="CY", group="ğŸ“… Yearly Levels")
colorCYL = input.color(#851a00, "", inline="CY", group="ğŸ“… Yearly Levels", tooltip="Current Year High/Low (developing)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ† ALL-TIME HIGH
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showATH = input.bool(true, "Show ATH", inline="ATH", group="ğŸ† All-Time High")
colorATH = input.color(#00fcff, "Color", inline="ATH", group="ğŸ† All-Time High", tooltip="All-Time High across all history")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

getLabelSize(string sizeStr) =>
    sizeStr == "Tiny" ? size.tiny : sizeStr == "Small" ? size.small : sizeStr == "Large" ? size.large : sizeStr == "Huge" ? size.huge : size.normal

getLineStyle(string styleStr) =>
    styleStr == "Solid" ? line.style_solid : styleStr == "Dashed" ? line.style_dashed : line.style_dotted

labelBgColor(color c) => color.new(c, 100)

// Round price to mintick precision for consistent map keys
roundToTick(float price) =>
    syminfo.mintick > 0 ? math.round(price / syminfo.mintick) * syminfo.mintick : price

// Session time definitions (in exchange local timezone)
// LSE: 8:00 AM - 4:30 PM GMT
// NYSE/CME: 9:30 AM - 4:00 PM EST
// ASX: 10:00 AM - 4:00 PM AEDT
// TSE: 9:00 AM - 3:00 PM JST
getSessionSpec(string session) =>
    session == "London" ? "0800-1630" : session == "New York" ? "0930-1600" : session == "Sydney" ? "1000-1600" : "0900-1500"

getSessionTimezone(string session) =>
    session == "London" ? "Europe/London" : session == "New York" ? "America/New_York" : session == "Sydney" ? "Australia/Sydney" : "Asia/Tokyo"

// Calculate today's session start timestamp (handles DST automatically via timezone)
getSessionStartTimestamp(string session) =>
    string tz = getSessionTimezone(session)
    int sessionHour = session == "London" ? 8 : session == "New York" ? 9 : session == "Sydney" ? 10 : 9
    int sessionMinute = session == "New York" ? 30 : 0
    timestamp(tz, year(timenow), month(timenow), dayofmonth(timenow), sessionHour, sessionMinute)

// Convert period string to minutes
periodToMinutes(string period) =>
    period == "1m" ? 1 : period == "2m" ? 2 : period == "3m" ? 3 : period == "5m" ? 5 : period == "15m" ? 15 : period == "30m" ? 30 : period == "1h" ? 60 : period == "65m" ? 65 : period == "2h" ? 120 : period == "4h" ? 240 : 0

// Get timeframe in minutes for comparison
getTimeframeMinutes() =>
    int localTfSeconds = timeframe.in_seconds()
    int tfMinutes = localTfSeconds / 60
    tfMinutes

// Add level to priceLabels map with duplicate detection
addToMap(map<float, string> priceMap, float price, string label) =>
    float key = roundToTick(price)
    string existing = map.contains(priceMap, key) ? map.get(priceMap, key) : ""
    if existing != ""
        map.put(priceMap, key, existing + "/" + label)
    else
        map.put(priceMap, key, label)

// Check if level price is within ATR distance from current price
isWithinATR(float levelPrice, float currentPrice, float threshold, bool filterEnabled) =>
    not filterEnabled or na(levelPrice) or math.abs(levelPrice - currentPrice) <= threshold

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DISPLAY CONDITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ATR CALCULATION (for distance filtering)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Use daily ATR with offset [1] and lookahead_on for non-repainting historical data
float atrValue = request.security(syminfo.tickerid, "D", ta.atr(atrPeriod)[1], lookahead=barmerge.lookahead_on)
float atrThreshold = atrValue * atrMultiplier

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DISPLAY CONDITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check instrument type
bool isFutures = syminfo.type == "futures"

// Check timeframe conditions
int currentTfMinutes = getTimeframeMinutes()
int maxTfMinutes = periodToMinutes(keyLevelsMaxTimeframe)
bool meetsMaxTimeframe = keyLevelsMaxTimeframe == "None" or currentTfMinutes <= maxTfMinutes

// Check if key levels should be shown (futures filter + max timeframe filter)
bool showKeyLevelsCondition = showKeyLevels and (keyLevelsMode == "All Instruments" or (keyLevelsMode == "Only Futures" and isFutures)) and meetsMaxTimeframe

// Check if session levels should be shown (independent of key levels timeframe filter)
int sessionMaxTfMinutes = periodToMinutes(sessionLevelsMaxTimeframe)
bool meetsSessionMaxTimeframe = sessionLevelsMaxTimeframe == "None" or currentTfMinutes <= sessionMaxTfMinutes
bool showSessionLevelsCondition = showSessionLevels and (sessionLevelsMode == "All Instruments" or (sessionLevelsMode == "Only Futures" and isFutures)) and meetsSessionMaxTimeframe

// Check if pivot points should be shown (timeframe filter only)
int pivotMaxTfMinutes = periodToMinutes(pivotMaxTimeframe)
bool meetsPivotMaxTimeframe = pivotMaxTimeframe == "None" or currentTfMinutes <= pivotMaxTfMinutes
bool showPivotsCondition = showPivots and meetsPivotMaxTimeframe

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEY LEVELS DATA - Works on any timeframe (10s to monthly)
// Conditional requests for performance (only fetch enabled levels)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Previous period levels (completed periods)
var float pdh = na, var float pdl = na
var float pwh = na, var float pwl = na
var float pmh = na, var float pml = na
var float pyh = na, var float pyl = na

// Previous period levels - only update on confirmed bars (static values don't change intrabar)
if barstate.isconfirmed and showKeyLevelsCondition and (showPDH or showPDL or showCDH or showCDL)
    [_pdh, _pdl] = request.security(syminfo.tickerid, "D", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pdh := _pdh, pdl := _pdl
if barstate.isconfirmed and showKeyLevelsCondition and (showPWH or showPWL or showCWH or showCWL)
    [_pwh, _pwl] = request.security(syminfo.tickerid, "W", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pwh := _pwh, pwl := _pwl
if barstate.isconfirmed and showKeyLevelsCondition and (showPMH or showPML or showCMH or showCML)
    [_pmh, _pml] = request.security(syminfo.tickerid, "M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pmh := _pmh, pml := _pml
if barstate.isconfirmed and showKeyLevelsCondition and (showPYH or showPYL or showCYH or showCYL)
    [_pyh, _pyl] = request.security(syminfo.tickerid, "12M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pyh := _pyh, pyl := _pyl

// Current period levels (developing periods)
var float cdh = na, var float cdl = na
var float cwh = na, var float cwl = na
var float cmh = na, var float cml = na
var float cyh = na, var float cyl = na

// Current period levels - update every bar to track developing highs/lows
if showKeyLevelsCondition and (showCDH or showCDL)
    [_cdh, _cdl] = request.security(syminfo.tickerid, "D", [high, low], lookahead=barmerge.lookahead_on)
    cdh := _cdh, cdl := _cdl
if showKeyLevelsCondition and (showCWH or showCWL)
    [_cwh, _cwl] = request.security(syminfo.tickerid, "W", [high, low], lookahead=barmerge.lookahead_on)
    cwh := _cwh, cwl := _cwl
if showKeyLevelsCondition and (showCMH or showCML)
    [_cmh, _cml] = request.security(syminfo.tickerid, "M", [high, low], lookahead=barmerge.lookahead_on)
    cmh := _cmh, cml := _cml
if showKeyLevelsCondition and (showCYH or showCYL)
    [_cyh, _cyl] = request.security(syminfo.tickerid, "12M", [high, low], lookahead=barmerge.lookahead_on)
    cyh := _cyh, cyl := _cyl

// All-time high (uses monthly for better performance) - only update on confirmed bars
var float ath = na
float _ath = ta.highest(high, bar_index + 1)
if barstate.isconfirmed
    ath := showKeyLevelsCondition and showATH ? request.security(syminfo.tickerid, "M", _ath, lookahead=barmerge.lookahead_on) : na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PIVOT POINTS CALCULATIONS (from previous day's HLC)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Fetch previous day's high, low, close for pivot calculations - only update on confirmed bars
var float dailyHigh = na, var float dailyLow = na, var float dailyClose = na
if barstate.isconfirmed
    [_dailyHigh, _dailyLow, _dailyClose] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    dailyHigh := _dailyHigh
    dailyLow := _dailyLow
    dailyClose := _dailyClose

// Traditional pivot point calculations
float dailyRange = dailyHigh - dailyLow
float pivotP = (dailyHigh + dailyLow + dailyClose) / 3
float pivotR1 = 2 * pivotP - dailyLow
float pivotS1 = 2 * pivotP - dailyHigh
float pivotR2 = pivotP + dailyRange
float pivotS2 = pivotP - dailyRange
float pivotR3 = dailyHigh + 2 * (pivotP - dailyLow)
float pivotS3 = dailyLow - 2 * (dailyHigh - pivotP)

var line linePDH = na, var line linePDL = na, var label labelPDH = na, var label labelPDL = na
var line linePWH = na, var line linePWL = na, var label labelPWH = na, var label labelPWL = na
var line linePMH = na, var line linePML = na, var label labelPMH = na, var label labelPML = na
var line linePYH = na, var line linePYL = na, var label labelPYH = na, var label labelPYL = na
var line lineATH = na, var label labelATH = na
var line lineCDH = na, var line lineCDL = na, var label labelCDH = na, var label labelCDL = na
var line lineCWH = na, var line lineCWL = na, var label labelCWH = na, var label labelCWL = na
var line lineCMH = na, var line lineCML = na, var label labelCMH = na, var label labelCML = na
var line lineCYH = na, var line lineCYL = na, var label labelCYH = na, var label labelCYL = na

// Pivot point line and label variables
var line lineP = na, var label labelP = na
var line lineR1 = na, var label labelR1 = na
var line lineR2 = na, var label labelR2 = na
var line lineR3 = na, var label labelR3 = na
var line lineS1 = na, var label labelS1 = na
var line lineS2 = na, var label labelS2 = na
var line lineS3 = na, var label labelS3 = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MULTI-SESSION INFRASTRUCTURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Session arrays (indices: 0=London, 1=NY, 2=Sydney, 3=Tokyo)
var array<bool> sessionEnabled = array.from(enableLondon, enableNewYork, enableSydney, enableTokyo)
var array<string> sessionNames = array.from("London", "New York", "Sydney", "Tokyo")
var array<color> sessionColors = array.from(colorLondon, colorNewYork, colorSydney, colorTokyo)

// Per-session tracking
var array<int> sessionStartBars = array.new<int>(4, na)
var array<int> sessionStartTimes = array.new<int>(4, na)
var array<label> sessionLabels = array.new<label>(4, na)

// Per-session VWAP accumulators (one set per session)
var array<float> vwapSumSrc = array.from(0.0, 0.0, 0.0, 0.0)
var array<float> vwapSumVol = array.from(0.0, 0.0, 0.0, 0.0)

// Active session tracking (for session levels)
var int activeSessionIndex = na
var string activeSessionName = na

// Session levels (always track the most recently started selected session)
var float sessionOpen = na
var float openRangeHigh = na
var float openRangeLow = na
var float initialBalanceHigh = na
var float initialBalanceLow = na
var int sessionStartBar = na
var int sessionStartTime = na

// Track bar indices where each level was established
var int openPriceBar = na
var int orhBar = na
var int orlBar = na
var int ibhBar = na
var int iblBar = na

// Calculate elapsed minutes in session
int openRangeMinutes = periodToMinutes(openRangePeriod)
int ibMinutes = periodToMinutes(initialBalancePeriod)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MULTI-SESSION DETECTION & MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detect session changes for all 4 sessions
// Track session state outside loop to avoid scope issues
var array<bool> inSessionState = array.new<bool>(4, false)

for i = 0 to 3
    if array.get(sessionEnabled, i)
        string sessionName = array.get(sessionNames, i)
        string sessionSpec = getSessionSpec(sessionName)
        string sessionTz = getSessionTimezone(sessionName)

        bool inThisSession = not na(time(timeframe.period, sessionSpec, sessionTz))
        bool wasInSession = array.get(inSessionState, i)
        array.set(inSessionState, i, inThisSession)
        bool thisSessionChange = inThisSession and not wasInSession

        // When this session starts
        if thisSessionChange
            // Delete old label for this session (24h cycle)
            label oldLabel = array.get(sessionLabels, i)
            if not na(oldLabel)
                label.delete(oldLabel)

            // Create new label with session name + date
            if showSessionLevelsCondition and showSessionLabels
                string dateStr = str.format("{0,date,d MMM}", time)
                string labelText = sessionName + " " + dateStr
                color sessionColor = array.get(sessionColors, i)
                label newLabel = label.new(bar_index, high, labelText, yloc=yloc.abovebar, color=sessionColor, textcolor=color.white, style=label.style_label_down, size=getLabelSize(globalLabelSize))
                array.set(sessionLabels, i, newLabel)

            // Update session tracking
            array.set(sessionStartBars, i, bar_index)
            array.set(sessionStartTimes, i, time)

            // This session becomes the active session for levels
            activeSessionIndex := i
            activeSessionName := sessionName

            // Reset session levels to this session
            sessionOpen := open
            openRangeHigh := high
            openRangeLow := low
            initialBalanceHigh := high
            initialBalanceLow := low
            sessionStartBar := bar_index
            sessionStartTime := time
            openPriceBar := bar_index
            orhBar := bar_index
            orlBar := bar_index
            ibhBar := bar_index
            iblBar := bar_index

// Update session levels (only for active session)
if not na(activeSessionIndex) and not na(sessionStartTime)
    string activeSpec = getSessionSpec(activeSessionName)
    string activeTz = getSessionTimezone(activeSessionName)
    bool inActiveSession = not na(time(timeframe.period, activeSpec, activeTz))

    if inActiveSession
        int elapsedMinutes = math.round((time - sessionStartTime) / 60000)

        // Update Open Range
        if elapsedMinutes <= openRangeMinutes
            if high > openRangeHigh
                openRangeHigh := high
                orhBar := bar_index
            if low < openRangeLow
                openRangeLow := low
                orlBar := bar_index

        // Update Initial Balance
        if elapsedMinutes <= ibMinutes
            if high > initialBalanceHigh
                initialBalanceHigh := high
                ibhBar := bar_index
            if low < initialBalanceLow
                initialBalanceLow := low
                iblBar := bar_index

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MULTI-SESSION VWAP CALCULATIONS (Time-based anchor pattern)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Calculate VWAP for each enabled session using time-based anchoring
var float londonVWAP = na, var float nyVWAP = na, var float sydneyVWAP = na, var float tokyoVWAP = na

for i = 0 to 3
    if array.get(sessionEnabled, i)
        string sessionName = array.get(sessionNames, i)

        // Calculate today's session start using timezone-aware function (exact pattern from working version)
        int todaySessionStart = getSessionStartTimestamp(sessionName)

        // Detect when time crosses into this session (exact pattern from working version)
        bool vwapAnchor = time >= todaySessionStart and time[1] < todaySessionStart

        // Get current accumulators
        float currentSumSrc = array.get(vwapSumSrc, i)
        float currentSumVol = array.get(vwapSumVol, i)

        // Reset on anchor (session start), otherwise accumulate
        float newSumSrc = vwapAnchor ? (ohlc4 * volume) : (currentSumSrc + ohlc4 * volume)
        float newSumVol = vwapAnchor ? volume : (currentSumVol + volume)

        // Update accumulators
        array.set(vwapSumSrc, i, newSumSrc)
        array.set(vwapSumVol, i, newSumVol)

        // Calculate VWAP
        float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na

        // Only show VWAP for bars after session started (exact pattern from working version)
        bool isInTargetSession = time >= todaySessionStart
        float displayVwap = isInTargetSession ? vwap : na

        // Store in appropriate variable for plotting
        if i == 0
            londonVWAP := displayVwap
        else if i == 1
            nyVWAP := displayVwap
        else if i == 2
            sydneyVWAP := displayVwap
        else if i == 3
            tokyoVWAP := displayVwap



// Plot VWAPs (plot na when session not active or disabled)
plot(showSessionLevelsCondition and showSessionVWAP and enableLondon ? londonVWAP : na, "London VWAP", color=colorLondon, linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionLevelsCondition and showSessionVWAP and enableNewYork ? nyVWAP : na, "NY VWAP", color=colorNewYork, linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionLevelsCondition and showSessionVWAP and enableSydney ? sydneyVWAP : na, "Sydney VWAP", color=colorSydney, linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionLevelsCondition and showSessionVWAP and enableTokyo ? tokyoVWAP : na, "Tokyo VWAP", color=colorTokyo, linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION LEVELS RENDERING (for active session only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line lineOpenPrice = na, var label labelOpenPrice = na
var line lineORH = na, var line lineORL = na, var label labelORH = na, var label labelORL = na
var line lineIBH = na, var line lineIBL = na, var label labelIBH = na, var label labelIBL = na
var box boxOpenRange = na
var box boxInitialBalanceUpper = na
var box boxInitialBalanceLower = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEY LEVELS RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Cache bar_index to prevent redundant updates on same bar (improves scrolling performance)
var int lastRenderBarIndex = na

if barstate.islast and (na(lastRenderBarIndex) or bar_index != lastRenderBarIndex)
    lastRenderBarIndex := bar_index

    // Calculate line start position with hard limit to prevent lines getting too long
    int startBar = math.max(0, bar_index - globalLineLengthBars)
    int maxLineDistance = 200  // Safe hard limit: lines can't go back more than 200 bars (prevents crashes on high-frequency charts)

    // Determine session line start based on user preference, but reset to configured length if beyond hard limit
    int sessionOpenBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
    int openPriceStartBar = sessionLineStartMode == "Level Established" and not na(openPriceBar) ? (bar_index - openPriceBar > maxLineDistance ? startBar : openPriceBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orhStartBar = sessionLineStartMode == "Level Established" and not na(orhBar) ? (bar_index - orhBar > maxLineDistance ? startBar : orhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orlStartBar = sessionLineStartMode == "Level Established" and not na(orlBar) ? (bar_index - orlBar > maxLineDistance ? startBar : orlBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int ibhStartBar = sessionLineStartMode == "Level Established" and not na(ibhBar) ? (bar_index - ibhBar > maxLineDistance ? startBar : ibhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int iblStartBar = sessionLineStartMode == "Level Established" and not na(iblBar) ? (bar_index - iblBar > maxLineDistance ? startBar : iblBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)

    string keyLevelsLineStyleActual = getLineStyle(keyLevelsLineStyle)
    string labelSizeActual = getLabelSize(globalLabelSize)

    // Round prices for map key consistency
    float athRounded = roundToTick(ath)
    float pyhRounded = roundToTick(pyh)
    float pylRounded = roundToTick(pyl)
    float pmhRounded = roundToTick(pmh)
    float pmlRounded = roundToTick(pml)
    float pwhRounded = roundToTick(pwh)
    float pwlRounded = roundToTick(pwl)
    float pdhRounded = roundToTick(pdh)
    float pdlRounded = roundToTick(pdl)
    float cyhRounded = roundToTick(cyh)
    float cylRounded = roundToTick(cyl)
    float cmhRounded = roundToTick(cmh)
    float cmlRounded = roundToTick(cml)
    float cwhRounded = roundToTick(cwh)
    float cwlRounded = roundToTick(cwl)
    float cdhRounded = roundToTick(cdh)
    float cdlRounded = roundToTick(cdl)

    // Pivot points rounded
    float pivotPRounded = roundToTick(pivotP)
    float pivotR1Rounded = roundToTick(pivotR1)
    float pivotR2Rounded = roundToTick(pivotR2)
    float pivotR3Rounded = roundToTick(pivotR3)
    float pivotS1Rounded = roundToTick(pivotS1)
    float pivotS2Rounded = roundToTick(pivotS2)
    float pivotS3Rounded = roundToTick(pivotS3)

    // Session levels rounded
    float ibhRounded = roundToTick(initialBalanceHigh)
    float iblRounded = roundToTick(initialBalanceLow)
    float orhRounded = roundToTick(openRangeHigh)
    float orlRounded = roundToTick(openRangeLow)
    float openRounded = roundToTick(sessionOpen)

    // Build price->label map (merges duplicates with "/")
    // Priority: Session Levels > Pivot Points > Key Levels
    var map<float, string> priceLabels = map.new<float, string>()
    map.clear(priceLabels)

    // Session levels first (highest priority)
    bool shouldAddSessionToMap = showSessionLevelsCondition and not na(sessionOpen)
    if shouldAddSessionToMap
        if showOpenPrice
            addToMap(priceLabels, sessionOpen, "Open")
        if showOpenRange and not na(openRangeHigh)
            addToMap(priceLabels, openRangeHigh, "ORH")
        if showOpenRange and not na(openRangeLow)
            addToMap(priceLabels, openRangeLow, "ORL")
        if showInitialBalance and not na(initialBalanceHigh)
            addToMap(priceLabels, initialBalanceHigh, "IBH")
        if showInitialBalance and not na(initialBalanceLow)
            addToMap(priceLabels, initialBalanceLow, "IBL")

    // Pivot points second (after session, before key levels)
    if showPivotsCondition
        if showPivotP
            addToMap(priceLabels, pivotP, "P")
        if showPivotR1
            addToMap(priceLabels, pivotR1, "R1")
        if showPivotR2
            addToMap(priceLabels, pivotR2, "R2")
        if showPivotR3
            addToMap(priceLabels, pivotR3, "R3")
        if showPivotS1
            addToMap(priceLabels, pivotS1, "S1")
        if showPivotS2
            addToMap(priceLabels, pivotS2, "S2")
        if showPivotS3
            addToMap(priceLabels, pivotS3, "S3")

    // Key levels (lower priority)
    if showKeyLevelsCondition
        if showATH
            addToMap(priceLabels, ath, "ATH")
        if showPYH
            addToMap(priceLabels, pyh, "PYH")
        if showPYL
            addToMap(priceLabels, pyl, "PYL")
        if showPMH
            addToMap(priceLabels, pmh, "PMH")
        if showPML
            addToMap(priceLabels, pml, "PML")
        if showPWH
            addToMap(priceLabels, pwh, "PWH")
        if showPWL
            addToMap(priceLabels, pwl, "PWL")
        if showPDH
            addToMap(priceLabels, pdh, "PDH")
        if showPDL
            addToMap(priceLabels, pdl, "PDL")
        if showCYH
            addToMap(priceLabels, cyh, "CYH")
        if showCYL
            addToMap(priceLabels, cyl, "CYL")
        if showCMH
            addToMap(priceLabels, cmh, "CMH")
        if showCML
            addToMap(priceLabels, cml, "CML")
        if showCWH
            addToMap(priceLabels, cwh, "CWH")
        if showCWL
            addToMap(priceLabels, cwl, "CWL")
        if showCDH
            addToMap(priceLabels, cdh, "CDH")
        if showCDL
            addToMap(priceLabels, cdl, "CDL")

    var array<float> renderedPrices = array.new<float>()
    array.clear(renderedPrices)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION LEVELS RENDERING (FIRST - highest priority for line style)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    string sessionLineStyleActual = getLineStyle(sessionLevelsLineStyle)
    // Only show session levels if we have an active session
    bool shouldShowSessionLevels = showSessionLevelsCondition and not na(activeSessionIndex) and not na(sessionOpen)

    // Opening Price
    if shouldShowSessionLevels and showOpenPrice and isWithinATR(sessionOpen, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, openRounded)
            string combinedLabel = map.contains(priceLabels, openRounded) ? map.get(priceLabels, openRounded) : "Open"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(sessionOpen, format.mintick) + ")" : combinedLabel
            if na(lineOpenPrice)
                lineOpenPrice := line.new(openPriceStartBar, sessionOpen, bar_index, sessionOpen, color=colorOpenPrice, width=sessionLevelsLineWidth, style=sessionLineStyleActual)
                labelOpenPrice := label.new(bar_index, sessionOpen, labelText, color=labelBgColor(colorOpenPrice), textcolor=colorOpenPrice, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineOpenPrice, openPriceStartBar, sessionOpen), line.set_xy2(lineOpenPrice, bar_index, sessionOpen)
                label.set_xy(labelOpenPrice, bar_index, sessionOpen), label.set_text(labelOpenPrice, labelText)
            array.push(renderedPrices, openRounded)
    else if not na(lineOpenPrice)
        line.delete(lineOpenPrice), lineOpenPrice := na, label.delete(labelOpenPrice), labelOpenPrice := na

    // Open Range High
    if shouldShowSessionLevels and showOpenRange and not na(openRangeHigh) and isWithinATR(openRangeHigh, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, orhRounded)
            string combinedLabel = map.contains(priceLabels, orhRounded) ? map.get(priceLabels, orhRounded) : "ORH"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(openRangeHigh, format.mintick) + ")" : combinedLabel
            if na(lineORH)
                lineORH := line.new(orhStartBar, openRangeHigh, bar_index, openRangeHigh, color=colorORH, width=sessionLevelsLineWidth, style=sessionLineStyleActual)
                labelORH := label.new(bar_index, openRangeHigh, labelText, color=labelBgColor(colorORH), textcolor=colorORH, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineORH, orhStartBar, openRangeHigh), line.set_xy2(lineORH, bar_index, openRangeHigh)
                label.set_xy(labelORH, bar_index, openRangeHigh), label.set_text(labelORH, labelText)
            array.push(renderedPrices, orhRounded)
    else if not na(lineORH)
        line.delete(lineORH), lineORH := na, label.delete(labelORH), labelORH := na

    // Open Range Low
    if shouldShowSessionLevels and showOpenRange and not na(openRangeLow) and isWithinATR(openRangeLow, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, orlRounded)
            string combinedLabel = map.contains(priceLabels, orlRounded) ? map.get(priceLabels, orlRounded) : "ORL"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(openRangeLow, format.mintick) + ")" : combinedLabel
            if na(lineORL)
                lineORL := line.new(orlStartBar, openRangeLow, bar_index, openRangeLow, color=colorORL, width=sessionLevelsLineWidth, style=sessionLineStyleActual)
                labelORL := label.new(bar_index, openRangeLow, labelText, color=labelBgColor(colorORL), textcolor=colorORL, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineORL, orlStartBar, openRangeLow), line.set_xy2(lineORL, bar_index, openRangeLow)
                label.set_xy(labelORL, bar_index, openRangeLow), label.set_text(labelORL, labelText)
            array.push(renderedPrices, orlRounded)
    else if not na(lineORL)
        line.delete(lineORL), lineORL := na, label.delete(labelORL), labelORL := na

    // Open Range Background Shading (boxes represent time periods, always start from session start)
    if shouldShowSessionLevels and showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        // Box always starts from session start (represents first X minutes as a time period)
        int boxORStartBar = not na(sessionStartBar) ? sessionStartBar : startBar
        if na(boxOpenRange)
            boxOpenRange := box.new(boxORStartBar, openRangeHigh, bar_index, openRangeLow, border_color=na, bgcolor=colorOpenRangeShade)
        else
            box.set_lefttop(boxOpenRange, boxORStartBar, openRangeHigh)
            box.set_rightbottom(boxOpenRange, bar_index, openRangeLow)
    else if not na(boxOpenRange)
        box.delete(boxOpenRange), boxOpenRange := na

    // Initial Balance High
    if shouldShowSessionLevels and showInitialBalance and not na(initialBalanceHigh) and isWithinATR(initialBalanceHigh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, ibhRounded)
        string combinedLabel = map.contains(priceLabels, ibhRounded) ? map.get(priceLabels, ibhRounded) : "IBH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(initialBalanceHigh, format.mintick) + ")" : combinedLabel
        if na(lineIBH)
            lineIBH := line.new(ibhStartBar, initialBalanceHigh, bar_index, initialBalanceHigh, color=colorIBH, width=sessionLevelsLineWidth, style=sessionLineStyleActual)
            labelIBH := label.new(bar_index, initialBalanceHigh, labelText, color=labelBgColor(colorIBH), textcolor=colorIBH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineIBH, ibhStartBar, initialBalanceHigh), line.set_xy2(lineIBH, bar_index, initialBalanceHigh)
            label.set_xy(labelIBH, bar_index, initialBalanceHigh), label.set_text(labelIBH, labelText)
        array.push(renderedPrices, ibhRounded)
    else if not na(lineIBH)
        line.delete(lineIBH), lineIBH := na, label.delete(labelIBH), labelIBH := na

    // Initial Balance Low
    if shouldShowSessionLevels and showInitialBalance and not na(initialBalanceLow) and isWithinATR(initialBalanceLow, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, iblRounded)
        string combinedLabel = map.contains(priceLabels, iblRounded) ? map.get(priceLabels, iblRounded) : "IBL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(initialBalanceLow, format.mintick) + ")" : combinedLabel
        if na(lineIBL)
            lineIBL := line.new(iblStartBar, initialBalanceLow, bar_index, initialBalanceLow, color=colorIBL, width=sessionLevelsLineWidth, style=sessionLineStyleActual)
            labelIBL := label.new(bar_index, initialBalanceLow, labelText, color=labelBgColor(colorIBL), textcolor=colorIBL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineIBL, iblStartBar, initialBalanceLow), line.set_xy2(lineIBL, bar_index, initialBalanceLow)
            label.set_xy(labelIBL, bar_index, initialBalanceLow), label.set_text(labelIBL, labelText)
        array.push(renderedPrices, iblRounded)
    else if not na(lineIBL)
        line.delete(lineIBL), lineIBL := na, label.delete(labelIBL), labelIBL := na

    // Initial Balance Background Shading (boxes represent time periods, always start from session start)
    if shouldShowSessionLevels and showInitialBalance and shadeInitialBalance and not na(initialBalanceHigh) and not na(initialBalanceLow)
        // Box always starts from session start (represents first 30m-1h as a time period)
        int boxIBStartBar = not na(sessionStartBar) ? sessionStartBar : startBar

        // If both OR and IB boxes enabled, split IB into upper/lower to avoid overlap
        bool splitIBBox = showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)

        if splitIBBox
            // Create upper box: IBH to ORH
            if initialBalanceHigh > openRangeHigh
                if na(boxInitialBalanceUpper)
                    boxInitialBalanceUpper := box.new(boxIBStartBar, initialBalanceHigh, bar_index, openRangeHigh, border_color=na, bgcolor=colorInitialBalanceShade)
                else
                    box.set_lefttop(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh)
                    box.set_rightbottom(boxInitialBalanceUpper, bar_index, openRangeHigh)
            else if not na(boxInitialBalanceUpper)
                box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na

            // Create lower box: ORL to IBL
            if initialBalanceLow < openRangeLow
                if na(boxInitialBalanceLower)
                    boxInitialBalanceLower := box.new(boxIBStartBar, openRangeLow, bar_index, initialBalanceLow, border_color=na, bgcolor=colorInitialBalanceShade)
                else
                    box.set_lefttop(boxInitialBalanceLower, boxIBStartBar, openRangeLow)
                    box.set_rightbottom(boxInitialBalanceLower, bar_index, initialBalanceLow)
            else if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
        else
            // Single IB box when OR box not shown
            if na(boxInitialBalanceUpper)
                boxInitialBalanceUpper := box.new(boxIBStartBar, initialBalanceHigh, bar_index, initialBalanceLow, border_color=na, bgcolor=colorInitialBalanceShade)
            else
                box.set_lefttop(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh)
                box.set_rightbottom(boxInitialBalanceUpper, bar_index, initialBalanceLow)

            // Delete lower box if it exists
            if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
    else
        // Delete both boxes when IB shading disabled
        if not na(boxInitialBalanceUpper)
            box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
        if not na(boxInitialBalanceLower)
            box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PIVOT POINTS RENDERING (SECOND - after session levels, before key levels)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    string pivotLineStyleActual = getLineStyle(pivotLineStyle)

    // Pivot P
    if showPivotsCondition and showPivotP and not na(pivotP) and isWithinATR(pivotP, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotPRounded)
            string combinedLabel = map.contains(priceLabels, pivotPRounded) ? map.get(priceLabels, pivotPRounded) : "P"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotP, format.mintick) + ")" : combinedLabel
            if na(lineP)
                lineP := line.new(startBar, pivotP, bar_index, pivotP, color=pivotColorP, width=pivotLineWidth, style=pivotLineStyleActual)
                labelP := label.new(bar_index, pivotP, labelText, color=labelBgColor(pivotColorP), textcolor=pivotColorP, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineP, startBar, pivotP), line.set_xy2(lineP, bar_index, pivotP)
                label.set_xy(labelP, bar_index, pivotP), label.set_text(labelP, labelText)
            array.push(renderedPrices, pivotPRounded)
        else
            if not na(lineP)
                line.delete(lineP), lineP := na, label.delete(labelP), labelP := na
    else if not na(lineP)
        line.delete(lineP), lineP := na, label.delete(labelP), labelP := na

    // Pivot R1
    if showPivotsCondition and showPivotR1 and not na(pivotR1) and isWithinATR(pivotR1, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotR1Rounded)
            string combinedLabel = map.contains(priceLabels, pivotR1Rounded) ? map.get(priceLabels, pivotR1Rounded) : "R1"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotR1, format.mintick) + ")" : combinedLabel
            if na(lineR1)
                lineR1 := line.new(startBar, pivotR1, bar_index, pivotR1, color=pivotColorR1, width=pivotLineWidth, style=pivotLineStyleActual)
                labelR1 := label.new(bar_index, pivotR1, labelText, color=labelBgColor(pivotColorR1), textcolor=pivotColorR1, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineR1, startBar, pivotR1), line.set_xy2(lineR1, bar_index, pivotR1)
                label.set_xy(labelR1, bar_index, pivotR1), label.set_text(labelR1, labelText)
            array.push(renderedPrices, pivotR1Rounded)
        else
            if not na(lineR1)
                line.delete(lineR1), lineR1 := na, label.delete(labelR1), labelR1 := na
    else if not na(lineR1)
        line.delete(lineR1), lineR1 := na, label.delete(labelR1), labelR1 := na

    // Pivot R2
    if showPivotsCondition and showPivotR2 and not na(pivotR2) and isWithinATR(pivotR2, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotR2Rounded)
            string combinedLabel = map.contains(priceLabels, pivotR2Rounded) ? map.get(priceLabels, pivotR2Rounded) : "R2"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotR2, format.mintick) + ")" : combinedLabel
            if na(lineR2)
                lineR2 := line.new(startBar, pivotR2, bar_index, pivotR2, color=pivotColorR2, width=pivotLineWidth, style=pivotLineStyleActual)
                labelR2 := label.new(bar_index, pivotR2, labelText, color=labelBgColor(pivotColorR2), textcolor=pivotColorR2, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineR2, startBar, pivotR2), line.set_xy2(lineR2, bar_index, pivotR2)
                label.set_xy(labelR2, bar_index, pivotR2), label.set_text(labelR2, labelText)
            array.push(renderedPrices, pivotR2Rounded)
        else
            if not na(lineR2)
                line.delete(lineR2), lineR2 := na, label.delete(labelR2), labelR2 := na
    else if not na(lineR2)
        line.delete(lineR2), lineR2 := na, label.delete(labelR2), labelR2 := na

    // Pivot R3
    if showPivotsCondition and showPivotR3 and not na(pivotR3) and isWithinATR(pivotR3, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotR3Rounded)
            string combinedLabel = map.contains(priceLabels, pivotR3Rounded) ? map.get(priceLabels, pivotR3Rounded) : "R3"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotR3, format.mintick) + ")" : combinedLabel
            if na(lineR3)
                lineR3 := line.new(startBar, pivotR3, bar_index, pivotR3, color=pivotColorR3, width=pivotLineWidth, style=pivotLineStyleActual)
                labelR3 := label.new(bar_index, pivotR3, labelText, color=labelBgColor(pivotColorR3), textcolor=pivotColorR3, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineR3, startBar, pivotR3), line.set_xy2(lineR3, bar_index, pivotR3)
                label.set_xy(labelR3, bar_index, pivotR3), label.set_text(labelR3, labelText)
            array.push(renderedPrices, pivotR3Rounded)
        else
            if not na(lineR3)
                line.delete(lineR3), lineR3 := na, label.delete(labelR3), labelR3 := na
    else if not na(lineR3)
        line.delete(lineR3), lineR3 := na, label.delete(labelR3), labelR3 := na

    // Pivot S1
    if showPivotsCondition and showPivotS1 and not na(pivotS1) and isWithinATR(pivotS1, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotS1Rounded)
            string combinedLabel = map.contains(priceLabels, pivotS1Rounded) ? map.get(priceLabels, pivotS1Rounded) : "S1"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotS1, format.mintick) + ")" : combinedLabel
            if na(lineS1)
                lineS1 := line.new(startBar, pivotS1, bar_index, pivotS1, color=pivotColorS1, width=pivotLineWidth, style=pivotLineStyleActual)
                labelS1 := label.new(bar_index, pivotS1, labelText, color=labelBgColor(pivotColorS1), textcolor=pivotColorS1, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineS1, startBar, pivotS1), line.set_xy2(lineS1, bar_index, pivotS1)
                label.set_xy(labelS1, bar_index, pivotS1), label.set_text(labelS1, labelText)
            array.push(renderedPrices, pivotS1Rounded)
        else
            if not na(lineS1)
                line.delete(lineS1), lineS1 := na, label.delete(labelS1), labelS1 := na
    else if not na(lineS1)
        line.delete(lineS1), lineS1 := na, label.delete(labelS1), labelS1 := na

    // Pivot S2
    if showPivotsCondition and showPivotS2 and not na(pivotS2) and isWithinATR(pivotS2, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotS2Rounded)
            string combinedLabel = map.contains(priceLabels, pivotS2Rounded) ? map.get(priceLabels, pivotS2Rounded) : "S2"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotS2, format.mintick) + ")" : combinedLabel
            if na(lineS2)
                lineS2 := line.new(startBar, pivotS2, bar_index, pivotS2, color=pivotColorS2, width=pivotLineWidth, style=pivotLineStyleActual)
                labelS2 := label.new(bar_index, pivotS2, labelText, color=labelBgColor(pivotColorS2), textcolor=pivotColorS2, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineS2, startBar, pivotS2), line.set_xy2(lineS2, bar_index, pivotS2)
                label.set_xy(labelS2, bar_index, pivotS2), label.set_text(labelS2, labelText)
            array.push(renderedPrices, pivotS2Rounded)
        else
            if not na(lineS2)
                line.delete(lineS2), lineS2 := na, label.delete(labelS2), labelS2 := na
    else if not na(lineS2)
        line.delete(lineS2), lineS2 := na, label.delete(labelS2), labelS2 := na

    // Pivot S3
    if showPivotsCondition and showPivotS3 and not na(pivotS3) and isWithinATR(pivotS3, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotS3Rounded)
            string combinedLabel = map.contains(priceLabels, pivotS3Rounded) ? map.get(priceLabels, pivotS3Rounded) : "S3"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotS3, format.mintick) + ")" : combinedLabel
            if na(lineS3)
                lineS3 := line.new(startBar, pivotS3, bar_index, pivotS3, color=pivotColorS3, width=pivotLineWidth, style=pivotLineStyleActual)
                labelS3 := label.new(bar_index, pivotS3, labelText, color=labelBgColor(pivotColorS3), textcolor=pivotColorS3, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineS3, startBar, pivotS3), line.set_xy2(lineS3, bar_index, pivotS3)
                label.set_xy(labelS3, bar_index, pivotS3), label.set_text(labelS3, labelText)
            array.push(renderedPrices, pivotS3Rounded)
        else
            if not na(lineS3)
                line.delete(lineS3), lineS3 := na, label.delete(labelS3), labelS3 := na
    else if not na(lineS3)
        line.delete(lineS3), lineS3 := na, label.delete(labelS3), labelS3 := na

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // KEY LEVELS RENDERING (THIRD - after session levels and pivots)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // ATH
    if showKeyLevelsCondition and showATH and not na(ath) and isWithinATR(ath, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, athRounded)
        string combinedLabel = map.contains(priceLabels, athRounded) ? map.get(priceLabels, athRounded) : "ATH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(ath, format.mintick) + ")" : combinedLabel
        if na(lineATH)
            lineATH := line.new(startBar, ath, bar_index, ath, color=colorATH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelATH := label.new(bar_index, ath, labelText, color=labelBgColor(colorATH), textcolor=colorATH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineATH, startBar, ath), line.set_xy2(lineATH, bar_index, ath)
            label.set_xy(labelATH, bar_index, ath), label.set_text(labelATH, labelText)
        array.push(renderedPrices, athRounded)
    else if not na(lineATH)
        line.delete(lineATH), lineATH := na, label.delete(labelATH), labelATH := na

    // PYH
    if showKeyLevelsCondition and showPYH and not na(pyh) and isWithinATR(pyh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pyhRounded)
        string combinedLabel = map.contains(priceLabels, pyhRounded) ? map.get(priceLabels, pyhRounded) : "PYH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pyh, format.mintick) + ")" : combinedLabel
        if na(linePYH)
            linePYH := line.new(startBar, pyh, bar_index, pyh, color=colorPYH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPYH := label.new(bar_index, pyh, labelText, color=labelBgColor(colorPYH), textcolor=colorPYH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePYH, startBar, pyh), line.set_xy2(linePYH, bar_index, pyh)
            label.set_xy(labelPYH, bar_index, pyh), label.set_text(labelPYH, labelText)
        array.push(renderedPrices, pyhRounded)
    else if not na(linePYH)
        line.delete(linePYH), linePYH := na, label.delete(labelPYH), labelPYH := na

    // PYL
    if showKeyLevelsCondition and showPYL and not na(pyl) and isWithinATR(pyl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pylRounded)
        string combinedLabel = map.contains(priceLabels, pylRounded) ? map.get(priceLabels, pylRounded) : "PYL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pyl, format.mintick) + ")" : combinedLabel
        if na(linePYL)
            linePYL := line.new(startBar, pyl, bar_index, pyl, color=colorPYL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPYL := label.new(bar_index, pyl, labelText, color=labelBgColor(colorPYL), textcolor=colorPYL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePYL, startBar, pyl), line.set_xy2(linePYL, bar_index, pyl)
            label.set_xy(labelPYL, bar_index, pyl), label.set_text(labelPYL, labelText)
        array.push(renderedPrices, pylRounded)
    else if not na(linePYL)
        line.delete(linePYL), linePYL := na, label.delete(labelPYL), labelPYL := na

    // PMH
    if showKeyLevelsCondition and showPMH and not na(pmh) and isWithinATR(pmh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pmhRounded)
        string combinedLabel = map.contains(priceLabels, pmhRounded) ? map.get(priceLabels, pmhRounded) : "PMH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pmh, format.mintick) + ")" : combinedLabel
        if na(linePMH)
            linePMH := line.new(startBar, pmh, bar_index, pmh, color=colorPMH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPMH := label.new(bar_index, pmh, labelText, color=labelBgColor(colorPMH), textcolor=colorPMH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePMH, startBar, pmh), line.set_xy2(linePMH, bar_index, pmh)
            label.set_xy(labelPMH, bar_index, pmh), label.set_text(labelPMH, labelText)
        array.push(renderedPrices, pmhRounded)
    else if not na(linePMH)
        line.delete(linePMH), linePMH := na, label.delete(labelPMH), labelPMH := na

    // PML
    if showKeyLevelsCondition and showPML and not na(pml) and isWithinATR(pml, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pmlRounded)
        string combinedLabel = map.contains(priceLabels, pmlRounded) ? map.get(priceLabels, pmlRounded) : "PML"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pml, format.mintick) + ")" : combinedLabel
        if na(linePML)
            linePML := line.new(startBar, pml, bar_index, pml, color=colorPML, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPML := label.new(bar_index, pml, labelText, color=labelBgColor(colorPML), textcolor=colorPML, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePML, startBar, pml), line.set_xy2(linePML, bar_index, pml)
            label.set_xy(labelPML, bar_index, pml), label.set_text(labelPML, labelText)
        array.push(renderedPrices, pmlRounded)
    else if not na(linePML)
        line.delete(linePML), linePML := na, label.delete(labelPML), labelPML := na

    // PWH
    if showKeyLevelsCondition and showPWH and not na(pwh) and isWithinATR(pwh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pwhRounded)
        string combinedLabel = map.contains(priceLabels, pwhRounded) ? map.get(priceLabels, pwhRounded) : "PWH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pwh, format.mintick) + ")" : combinedLabel
        if na(linePWH)
            linePWH := line.new(startBar, pwh, bar_index, pwh, color=colorPWH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPWH := label.new(bar_index, pwh, labelText, color=labelBgColor(colorPWH), textcolor=colorPWH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePWH, startBar, pwh), line.set_xy2(linePWH, bar_index, pwh)
            label.set_xy(labelPWH, bar_index, pwh), label.set_text(labelPWH, labelText)
        array.push(renderedPrices, pwhRounded)
    else if not na(linePWH)
        line.delete(linePWH), linePWH := na, label.delete(labelPWH), labelPWH := na

    // PWL
    if showKeyLevelsCondition and showPWL and not na(pwl) and isWithinATR(pwl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pwlRounded)
        string combinedLabel = map.contains(priceLabels, pwlRounded) ? map.get(priceLabels, pwlRounded) : "PWL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pwl, format.mintick) + ")" : combinedLabel
        if na(linePWL)
            linePWL := line.new(startBar, pwl, bar_index, pwl, color=colorPWL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPWL := label.new(bar_index, pwl, labelText, color=labelBgColor(colorPWL), textcolor=colorPWL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePWL, startBar, pwl), line.set_xy2(linePWL, bar_index, pwl)
            label.set_xy(labelPWL, bar_index, pwl), label.set_text(labelPWL, labelText)
        array.push(renderedPrices, pwlRounded)
    else if not na(linePWL)
        line.delete(linePWL), linePWL := na, label.delete(labelPWL), labelPWL := na

    // PDH
    if showKeyLevelsCondition and showPDH and not na(pdh) and isWithinATR(pdh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pdhRounded)
        string combinedLabel = map.contains(priceLabels, pdhRounded) ? map.get(priceLabels, pdhRounded) : "PDH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pdh, format.mintick) + ")" : combinedLabel
        if na(linePDH)
            linePDH := line.new(startBar, pdh, bar_index, pdh, color=colorPDH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPDH := label.new(bar_index, pdh, labelText, color=labelBgColor(colorPDH), textcolor=colorPDH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePDH, startBar, pdh), line.set_xy2(linePDH, bar_index, pdh)
            label.set_xy(labelPDH, bar_index, pdh), label.set_text(labelPDH, labelText)
        array.push(renderedPrices, pdhRounded)
    else if not na(linePDH)
        line.delete(linePDH), linePDH := na, label.delete(labelPDH), labelPDH := na

    // PDL
    if showKeyLevelsCondition and showPDL and not na(pdl) and isWithinATR(pdl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pdlRounded)
        string combinedLabel = map.contains(priceLabels, pdlRounded) ? map.get(priceLabels, pdlRounded) : "PDL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pdl, format.mintick) + ")" : combinedLabel
        if na(linePDL)
            linePDL := line.new(startBar, pdl, bar_index, pdl, color=colorPDL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPDL := label.new(bar_index, pdl, labelText, color=labelBgColor(colorPDL), textcolor=colorPDL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePDL, startBar, pdl), line.set_xy2(linePDL, bar_index, pdl)
            label.set_xy(labelPDL, bar_index, pdl), label.set_text(labelPDL, labelText)
        array.push(renderedPrices, pdlRounded)
    else if not na(linePDL)
        line.delete(linePDL), linePDL := na, label.delete(labelPDL), labelPDL := na


    // CYH
    if showKeyLevelsCondition and showCYH and not na(cyh) and isWithinATR(cyh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cyhRounded)
        string combinedLabel = map.contains(priceLabels, cyhRounded) ? map.get(priceLabels, cyhRounded) : "CYH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cyh, format.mintick) + ")" : combinedLabel
        if na(lineCYH)
            lineCYH := line.new(startBar, cyh, bar_index, cyh, color=colorCYH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCYH := label.new(bar_index, cyh, labelText, color=labelBgColor(colorCYH), textcolor=colorCYH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCYH, startBar, cyh), line.set_xy2(lineCYH, bar_index, cyh)
            label.set_xy(labelCYH, bar_index, cyh), label.set_text(labelCYH, labelText)
        array.push(renderedPrices, cyhRounded)
    else if not na(lineCYH)
        line.delete(lineCYH), lineCYH := na, label.delete(labelCYH), labelCYH := na

    // CYL
    if showKeyLevelsCondition and showCYL and not na(cyl) and isWithinATR(cyl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cylRounded)
        string combinedLabel = map.contains(priceLabels, cylRounded) ? map.get(priceLabels, cylRounded) : "CYL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cyl, format.mintick) + ")" : combinedLabel
        if na(lineCYL)
            lineCYL := line.new(startBar, cyl, bar_index, cyl, color=colorCYL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCYL := label.new(bar_index, cyl, labelText, color=labelBgColor(colorCYL), textcolor=colorCYL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCYL, startBar, cyl), line.set_xy2(lineCYL, bar_index, cyl)
            label.set_xy(labelCYL, bar_index, cyl), label.set_text(labelCYL, labelText)
        array.push(renderedPrices, cylRounded)
    else if not na(lineCYL)
        line.delete(lineCYL), lineCYL := na, label.delete(labelCYL), labelCYL := na

    // CMH
    if showKeyLevelsCondition and showCMH and not na(cmh) and isWithinATR(cmh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cmhRounded)
        string combinedLabel = map.contains(priceLabels, cmhRounded) ? map.get(priceLabels, cmhRounded) : "CMH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cmh, format.mintick) + ")" : combinedLabel
        if na(lineCMH)
            lineCMH := line.new(startBar, cmh, bar_index, cmh, color=colorCMH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCMH := label.new(bar_index, cmh, labelText, color=labelBgColor(colorCMH), textcolor=colorCMH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCMH, startBar, cmh), line.set_xy2(lineCMH, bar_index, cmh)
            label.set_xy(labelCMH, bar_index, cmh), label.set_text(labelCMH, labelText)
        array.push(renderedPrices, cmhRounded)
    else if not na(lineCMH)
        line.delete(lineCMH), lineCMH := na, label.delete(labelCMH), labelCMH := na

    // CWH
    if showKeyLevelsCondition and showCWH and not na(cwh) and isWithinATR(cwh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cwhRounded)
        string combinedLabel = map.contains(priceLabels, cwhRounded) ? map.get(priceLabels, cwhRounded) : "CWH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cwh, format.mintick) + ")" : combinedLabel
        if na(lineCWH)
            lineCWH := line.new(startBar, cwh, bar_index, cwh, color=colorCWH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCWH := label.new(bar_index, cwh, labelText, color=labelBgColor(colorCWH), textcolor=colorCWH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCWH, startBar, cwh), line.set_xy2(lineCWH, bar_index, cwh)
            label.set_xy(labelCWH, bar_index, cwh), label.set_text(labelCWH, labelText)
        array.push(renderedPrices, cwhRounded)
    else if not na(lineCWH)
        line.delete(lineCWH), lineCWH := na, label.delete(labelCWH), labelCWH := na

    // CWL
    if showKeyLevelsCondition and showCWL and not na(cwl) and isWithinATR(cwl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cwlRounded)
        string combinedLabel = map.contains(priceLabels, cwlRounded) ? map.get(priceLabels, cwlRounded) : "CWL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cwl, format.mintick) + ")" : combinedLabel
        if na(lineCWL)
            lineCWL := line.new(startBar, cwl, bar_index, cwl, color=colorCWL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCWL := label.new(bar_index, cwl, labelText, color=labelBgColor(colorCWL), textcolor=colorCWL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCWL, startBar, cwl), line.set_xy2(lineCWL, bar_index, cwl)
            label.set_xy(labelCWL, bar_index, cwl), label.set_text(labelCWL, labelText)
        array.push(renderedPrices, cwlRounded)
    else if not na(lineCWL)
        line.delete(lineCWL), lineCWL := na, label.delete(labelCWL), labelCWL := na

    // CML
    if showKeyLevelsCondition and showCML and not na(cml) and isWithinATR(cml, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cmlRounded)
        string combinedLabel = map.contains(priceLabels, cmlRounded) ? map.get(priceLabels, cmlRounded) : "CML"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cml, format.mintick) + ")" : combinedLabel
        if na(lineCML)
            lineCML := line.new(startBar, cml, bar_index, cml, color=colorCML, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCML := label.new(bar_index, cml, labelText, color=labelBgColor(colorCML), textcolor=colorCML, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCML, startBar, cml), line.set_xy2(lineCML, bar_index, cml)
            label.set_xy(labelCML, bar_index, cml), label.set_text(labelCML, labelText)
        array.push(renderedPrices, cmlRounded)
    else if not na(lineCML)
        line.delete(lineCML), lineCML := na, label.delete(labelCML), labelCML := na

    // CDH
    if showKeyLevelsCondition and showCDH and not na(cdh) and isWithinATR(cdh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cdhRounded)
        string combinedLabel = map.contains(priceLabels, cdhRounded) ? map.get(priceLabels, cdhRounded) : "CDH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cdh, format.mintick) + ")" : combinedLabel
        if na(lineCDH)
            lineCDH := line.new(startBar, cdh, bar_index, cdh, color=colorCDH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCDH := label.new(bar_index, cdh, labelText, color=labelBgColor(colorCDH), textcolor=colorCDH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCDH, startBar, cdh), line.set_xy2(lineCDH, bar_index, cdh)
            label.set_xy(labelCDH, bar_index, cdh), label.set_text(labelCDH, labelText)
        array.push(renderedPrices, cdhRounded)
    else if not na(lineCDH)
        line.delete(lineCDH), lineCDH := na, label.delete(labelCDH), labelCDH := na

    // CDL
    if showKeyLevelsCondition and showCDL and not na(cdl) and isWithinATR(cdl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cdlRounded)
        string combinedLabel = map.contains(priceLabels, cdlRounded) ? map.get(priceLabels, cdlRounded) : "CDL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cdl, format.mintick) + ")" : combinedLabel
        if na(lineCDL)
            lineCDL := line.new(startBar, cdl, bar_index, cdl, color=colorCDL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCDL := label.new(bar_index, cdl, labelText, color=labelBgColor(colorCDL), textcolor=colorCDL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCDL, startBar, cdl), line.set_xy2(lineCDL, bar_index, cdl)
            label.set_xy(labelCDL, bar_index, cdl), label.set_text(labelCDL, labelText)
        array.push(renderedPrices, cdlRounded)
    else if not na(lineCDL)
        line.delete(lineCDL), lineCDL := na, label.delete(labelCDL), labelCDL := na
