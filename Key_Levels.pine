// MIT License
//
// Copyright (c) 2025 User-3090
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//@version=6
indicator("Key Levels", overlay=true, max_lines_count=500, max_boxes_count=100)

// INPUTS - GLOBAL SETTINGS
globalLabelSize = input.string("Normal", "Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="ðŸŒ Global Settings", tooltip="Label size for all levels")
globalShowPriceValues = input.bool(false, "Show Prices in Labels", group="ðŸŒ Global Settings", tooltip="Show price in labels: 'PDH (4523.50)' vs 'PDH'")
globalLineLengthBars = input.int(50, "Line Length (Bars)", minval=10, maxval=200, group="ðŸŒ Global Settings", tooltip="Bars to extend lines backward from current bar (hard limit for lines: 200)")

useATRFilter = input.bool(true, "Hide Distant Levels", group="ðŸŒ Global Settings", tooltip="Only show levels within specified ATR distance from current price")
atrMultiplier = input.float(1.5, "  Distance (ATR)", minval=1.0, maxval=10.0, step=0.5, group="ðŸŒ Global Settings", tooltip="Hide levels beyond this many ATRs from current price")
atrPeriod = input.int(20, "  ATR Period (Days)", minval=1, maxval=500, group="ðŸŒ Global Settings", tooltip="ATR calculated from daily bars (last N days), regardless of chart timeframe")

longTermAnchorSession = input.string("Auto", "Long Term Anchor Session", options=["Auto", "London", "New York", "Globex", "Sydney", "Tokyo"], group="ðŸŒ Global Settings", tooltip="Defines which session is used as the long-term anchor for weekly VWAPs and gets extended visibility. Auto = NY for stocks, Globex for futures. This setting determines which session uses 'Long Term Anchor Session Max TF' vs 'Other Sessions Max TF' below.")

showSessionMarkers = input.bool(true, "Enable Sessions", group="âš™ï¸ Global", tooltip="Master switch for all session features (anchors, VWAPs, levels, labels)")
sessionMarkersMode = input.string("Only Futures", "Instrument Filter", options=["Always", "Only Futures"], group="âš™ï¸ Global", tooltip="Always = show on all instruments | Only Futures = show only on futures contracts")

// VWAP APPEARANCE
sessionVWAPLineWidth = input.int(3, "Line Width", minval=1, maxval=5, group="ðŸŽ¨ VWAP Appearance", tooltip="Thickness of VWAP lines")
sessionVWAPLineStyleInput = input.string("Dotted", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸŽ¨ VWAP Appearance", tooltip="VWAP line appearance")
sessionVWAPLineStyle = sessionVWAPLineStyleInput == "Solid" ? plot.linestyle_solid : sessionVWAPLineStyleInput == "Dashed" ? plot.linestyle_dashed : plot.linestyle_dotted

vwapColorDifferentiation = input.bool(true, "Fade Older Sessions", group="ðŸŽ¨ VWAP Appearance", tooltip="Make older sessions visually distinct")
vwapMaxTransparency = input.int(0, "Transparency", minval=0, maxval=95, group="ðŸŽ¨ VWAP Appearance", tooltip="Transparency for oldest session (0=opaque)")
vwapHueShift = input.int(-18, "Hue Shift", minval=-50, maxval=50, group="ðŸŽ¨ VWAP Appearance", tooltip="Color shift for older sessions (-=cooler, +=warmer)")
vwapDesaturation = input.int(0, "Desaturation", minval=0, maxval=100, group="ðŸŽ¨ VWAP Appearance", tooltip="Reduce color vibrancy (0=vibrant, 100=gray)")

// LONG TERM ANCHORS
weeklyAnchorMaxTimeframe = input.string("4h", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D"], group="ðŸ“… Long Term Anchors", tooltip="Hide weekly anchors on timeframes above this")

showWeeklyAnchorVWAP = input.bool(true, "Weekly", inline="WEEKLY", group="ðŸ“… Long Term Anchors", tooltip="VWAP anchored to first session of trading week")
colorWeeklyAnchor = input.color(#b51b00, "", inline="WEEKLY", group="ðŸ“… Long Term Anchors")
weeklyAnchorCount = input.int(5, "Count", inline="WEEKLY", minval=1, maxval=5, group="ðŸ“… Long Term Anchors", tooltip="Number of weeks to show (1=current only, 2=current+previous)")

// DAILY SESSIONS
longTermAnchorSessionMaxTimeframe = input.string("1h", "Long Term Anchor Session Max TF", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ“† Daily Sessions", tooltip="Max timeframe for the session chosen as Long Term Anchor Session above. This session stays visible at higher timeframes.")
otherSessionsMaxTimeframe = input.string("15m", "Other Sessions Max TF", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ“† Daily Sessions", tooltip="Max timeframe for all other sessions (non-anchor). These appear only at smaller timeframes for intraday precision.")

showSessionVWAP = input.bool(true, "Show Session VWAP", group="ðŸ“† Daily Sessions", tooltip="Display volume-weighted average price per session")
showSessionLabels = input.bool(true, "Show Session Labels", group="ðŸ“† Daily Sessions", tooltip="Show session start labels with date")
compactSessionLabels = input.bool(true, "Compact Labels", group="ðŸ“† Daily Sessions", tooltip="Use abbreviated session labels (e.g., 'NY1', 'LN2') instead of full names with dates")
compactWeeklyLabels = input.bool(true, "Compact Weekly Labels", group="ðŸ“… Long Term Anchors", tooltip="Use short weekly labels (e.g., 'W1', 'W2') for long-term anchor sessions")

enableLondon = input.bool(true, "London", inline="LON", group="ðŸ“† Daily Sessions")
colorLondon = input.color(#FF9800, "", inline="LON", group="ðŸ“† Daily Sessions")
londonVWAPCount = input.int(1, "Count", inline="LON", minval=1, maxval=5, group="ðŸ“† Daily Sessions", tooltip="Number of sessions to show (1=current only, 2=current+previous)")

enableNewYork = input.bool(true, "New York", inline="NY", group="ðŸ“† Daily Sessions")
colorNewYork = input.color(#2962FF, "", inline="NY", group="ðŸ“† Daily Sessions")
nyVWAPCount = input.int(2, "Count", inline="NY", minval=1, maxval=5, group="ðŸ“† Daily Sessions", tooltip="Number of sessions to show (1=current only, 2=current+previous)")

enableGlobex = input.bool(true, "Globex", inline="GLX", group="ðŸ“† Daily Sessions")
colorGlobex = input.color(#4CAF50, "", inline="GLX", group="ðŸ“† Daily Sessions")
globexVWAPCount = input.int(5, "Count", inline="GLX", minval=1, maxval=5, group="ðŸ“† Daily Sessions", tooltip="Number of sessions to show (1=current only, 2=current+previous)")

enableSydney = input.bool(false, "Sydney", inline="SYD", group="ðŸ“† Daily Sessions")
colorSydney = input.color(#9C27B0, "", inline="SYD", group="ðŸ“† Daily Sessions")
sydneyVWAPCount = input.int(1, "Count", inline="SYD", minval=1, maxval=5, group="ðŸ“† Daily Sessions", tooltip="Number of sessions to show (1=current only, 2=current+previous)")

enableTokyo = input.bool(false, "Tokyo", inline="TKY", group="ðŸ“† Daily Sessions")
colorTokyo = input.color(#E91E63, "", inline="TKY", group="ðŸ“† Daily Sessions")
tokyoVWAPCount = input.int(1, "Count", inline="TKY", minval=1, maxval=5, group="ðŸ“† Daily Sessions", tooltip="Number of sessions to show (1=current only, 2=current+previous)")

// SESSION INTRADAY LEVELS
sessionIntradayLevelsMaxTimeframe = input.string("5m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ“ Session Intraday Levels", tooltip="Hide session intraday levels (Open/OR/IB) on timeframes above this")
sessionIntradayLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ðŸ“ Session Intraday Levels", tooltip="Width for Open/ORH/ORL/IBH/IBL lines")
sessionIntradayLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸ“ Session Intraday Levels")
sessionLineStartMode = input.string("Level Established", "Line Start", options=["Level Established", "Session Open", "Fixed Bars Back"], group="ðŸ“ Session Intraday Levels", tooltip="Level Established: From where level was created\nSession Open: From session start\nFixed Bars Back: Use global line length")

showOpenPrice = input.bool(true, "Show Open", inline="OP", group="ðŸ“ Session Intraday Levels")
colorOpenPrice = input.color(#fbbe30, "", inline="OP", group="ðŸ“ Session Intraday Levels", tooltip="First price at session open")

showOpenRange = input.bool(true, "Show Open Range", group="ðŸ“ Session Intraday Levels", tooltip="High/Low of first 15m-30m (early volatility)")
openRangePeriod = input.string("30m", "OR Period", options=["15m", "30m"], group="ðŸ“ Session Intraday Levels")
colorORH = input.color(#4682b4, "ORH", inline="OR", group="ðŸ“ Session Intraday Levels")
colorORL = input.color(#cd5c5c, "ORL", inline="OR", group="ðŸ“ Session Intraday Levels")
shadeOpenRange = input.bool(true, "Shade OR", group="ðŸ“ Session Intraday Levels")
colorOpenRangeShade = input.color(color.new(color.red, 98), "OR Shade", group="ðŸ“ Session Intraday Levels", tooltip="Fill between ORH/ORL")

showInitialBalance = input.bool(false, "Show Initial Balance", group="ðŸ“ Session Intraday Levels", tooltip="High/Low of first 30m-1h (institutional reference)")
initialBalancePeriod = input.string("1h", "IB Period", options=["30m", "1h"], group="ðŸ“ Session Intraday Levels")
colorIBH = input.color(#81ce6f, "IBH", inline="IB", group="ðŸ“ Session Intraday Levels")
colorIBL = input.color(#e43b38, "IBL", inline="IB", group="ðŸ“ Session Intraday Levels")
shadeInitialBalance = input.bool(true, "Shade IB", group="ðŸ“ Session Intraday Levels")
colorInitialBalanceShade = input.color(color.new(color.green, 98), "IB Shade", group="ðŸ“ Session Intraday Levels", tooltip="Fill between IBH/IBL")

// PIVOT POINTS
showPivots = input.bool(true, "Enable Pivot Points", group="ðŸ”„ Pivot Points", tooltip="Traditional pivots from previous day H/L/C")
pivotMaxTimeframe = input.string("4h", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ”„ Pivot Points", tooltip="Hide on timeframes above this")
pivotLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ðŸ”„ Pivot Points")
pivotLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸ”„ Pivot Points")

showPivotP = input.bool(false, "Show P", inline="pivotP", group="ðŸ”„ Pivot Points")
pivotColorP = input.color(#808080, "", inline="pivotP", group="ðŸ”„ Pivot Points", tooltip="Central pivot: (H+L+C)/3")

showPivotR1 = input.bool(false, "Show R1", inline="pivotR1", group="ðŸ”„ Pivot Points")
pivotColorR1 = input.color(#449955, "", inline="pivotR1", group="ðŸ”„ Pivot Points", tooltip="First resistance")
showPivotR2 = input.bool(true, "Show R2", inline="pivotR2", group="ðŸ”„ Pivot Points")
pivotColorR2 = input.color(#449955, "", inline="pivotR2", group="ðŸ”„ Pivot Points", tooltip="Second resistance")
showPivotR3 = input.bool(true, "Show R3", inline="pivotR3", group="ðŸ”„ Pivot Points")
pivotColorR3 = input.color(#81ce6f, "", inline="pivotR3", group="ðŸ”„ Pivot Points", tooltip="Third resistance")

showPivotS1 = input.bool(false, "Show S1", inline="pivotS1", group="ðŸ”„ Pivot Points")
pivotColorS1 = input.color(#b51b00, "", inline="pivotS1", group="ðŸ”„ Pivot Points", tooltip="First support")
showPivotS2 = input.bool(true, "Show S2", inline="pivotS2", group="ðŸ”„ Pivot Points")
pivotColorS2 = input.color(#b51b00, "", inline="pivotS2", group="ðŸ”„ Pivot Points", tooltip="Second support")
showPivotS3 = input.bool(true, "Show S3", inline="pivotS3", group="ðŸ”„ Pivot Points")
pivotColorS3 = input.color(#d37666, "", inline="pivotS3", group="ðŸ”„ Pivot Points", tooltip="Third support")

// KEY LEVELS
showKeyLevels = input.bool(true, "Enable Key Levels", group="ðŸ“ˆ Key Levels", tooltip="Master toggle for ATH/Year/Month/Week/Day levels")
keyLevelsMode = input.string("Only Futures", "Instrument Filter", options=["All Instruments", "Only Futures"], group="ðŸ“ˆ Key Levels", tooltip="Show on all markets or futures only")
keyLevelsMaxTimeframe = input.string("15m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ“ˆ Key Levels", tooltip="Hide on larger timeframes")
keyLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ðŸ“ˆ Key Levels")
keyLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸ“ˆ Key Levels")

showATH = input.bool(true, "Show ATH", inline="ATH", group="ðŸ“ˆ Key Levels")
colorATH = input.color(#00fcff, "", inline="ATH", group="ðŸ“ˆ Key Levels", tooltip="All-time high")

showPYH = input.bool(true, "Previous YH", inline="PY", group="ðŸ“ˆ Key Levels")
colorPYH = input.color(#1e6b28, "", inline="PY", group="ðŸ“ˆ Key Levels")
showPYL = input.bool(true, "YL", inline="PY", group="ðŸ“ˆ Key Levels")
colorPYL = input.color(#6b0f00, "", inline="PY", group="ðŸ“ˆ Key Levels", tooltip="Previous year high/low")

showCYH = input.bool(true, "Current YH", inline="CY", group="ðŸ“ˆ Key Levels")
colorCYH = input.color(#3a8540, "", inline="CY", group="ðŸ“ˆ Key Levels")
showCYL = input.bool(true, "YL", inline="CY", group="ðŸ“ˆ Key Levels")
colorCYL = input.color(#851a00, "", inline="CY", group="ðŸ“ˆ Key Levels", tooltip="Current year high/low")

showPMH = input.bool(true, "Previous MH", inline="PM", group="ðŸ“ˆ Key Levels")
colorPMH = input.color(#2e8b3a, "", inline="PM", group="ðŸ“ˆ Key Levels")
showPML = input.bool(true, "ML", inline="PM", group="ðŸ“ˆ Key Levels")
colorPML = input.color(#8b1500, "", inline="PM", group="ðŸ“ˆ Key Levels", tooltip="Previous month high/low")

showCMH = input.bool(true, "Current MH", inline="CM", group="ðŸ“ˆ Key Levels")
colorCMH = input.color(#50a555, "", inline="CM", group="ðŸ“ˆ Key Levels")
showCML = input.bool(true, "ML", inline="CM", group="ðŸ“ˆ Key Levels")
colorCML = input.color(#a83020, "", inline="CM", group="ðŸ“ˆ Key Levels", tooltip="Current month high/low")

showPWH = input.bool(true, "Previous WH", inline="PW", group="ðŸ“ˆ Key Levels")
colorPWH = input.color(#449955, "", inline="PW", group="ðŸ“ˆ Key Levels")
showPWL = input.bool(true, "WL", inline="PW", group="ðŸ“ˆ Key Levels")
colorPWL = input.color(#b51b00, "", inline="PW", group="ðŸ“ˆ Key Levels", tooltip="Previous week high/low")

showCWH = input.bool(true, "Current WH", inline="CW", group="ðŸ“ˆ Key Levels")
colorCWH = input.color(#6bb370, "", inline="CW", group="ðŸ“ˆ Key Levels")
showCWL = input.bool(true, "WL", inline="CW", group="ðŸ“ˆ Key Levels")
colorCWL = input.color(#d84530, "", inline="CW", group="ðŸ“ˆ Key Levels", tooltip="Current week high/low")

showPDH = input.bool(true, "Previous DH", inline="PD", group="ðŸ“ˆ Key Levels")
colorPDH = input.color(#81ce6f, "", inline="PD", group="ðŸ“ˆ Key Levels")
showPDL = input.bool(true, "DL", inline="PD", group="ðŸ“ˆ Key Levels")
colorPDL = input.color(#d37666, "", inline="PD", group="ðŸ“ˆ Key Levels", tooltip="Previous day high/low")

showCDH = input.bool(true, "Current DH", inline="CD", group="ðŸ“ˆ Key Levels")
colorCDH = input.color(#a8e6a1, "", inline="CD", group="ðŸ“ˆ Key Levels")
showCDL = input.bool(true, "DL", inline="CD", group="ðŸ“ˆ Key Levels")
colorCDL = input.color(#e8a090, "", inline="CD", group="ðŸ“ˆ Key Levels", tooltip="Current day high/low")

// HELPER FUNCTIONS


getLabelSize(string sizeStr) =>
    sizeStr == "Tiny" ? size.tiny : sizeStr == "Small" ? size.small : sizeStr == "Large" ? size.large : sizeStr == "Huge" ? size.huge : size.normal

getLineStyle(string styleStr) =>
    styleStr == "Solid" ? line.style_solid : styleStr == "Dashed" ? line.style_dashed : line.style_dotted

labelBgColor(color c) => color.new(c, 100)

roundToTick(float price) =>
    syminfo.mintick > 0 ? math.round(price / syminfo.mintick) * syminfo.mintick : price

updateBox(box boxRef, int x1, float y1, int x2, float y2, color bg) =>
    if na(boxRef)
        box.new(x1, y1, x2, y2, border_color=na, bgcolor=bg)
    else
        box.set_lefttop(boxRef, x1, y1)
        box.set_rightbottom(boxRef, x2, y2)
        boxRef

// RGB to HSL conversion
rgbToHsl(float r, float g, float b) =>
    float rNorm = r / 255.0
    float gNorm = g / 255.0
    float bNorm = b / 255.0

    float maxVal = math.max(rNorm, math.max(gNorm, bNorm))
    float minVal = math.min(rNorm, math.min(gNorm, bNorm))
    float delta = maxVal - minVal

    float h = 0.0
    float s = 0.0
    float l = (maxVal + minVal) / 2.0

    if delta != 0
        s := l > 0.5 ? delta / (2.0 - maxVal - minVal) : delta / (maxVal + minVal)

        if maxVal == rNorm
            h := ((gNorm - bNorm) / delta + (gNorm < bNorm ? 6.0 : 0.0)) / 6.0
        else if maxVal == gNorm
            h := ((bNorm - rNorm) / delta + 2.0) / 6.0
        else
            h := ((rNorm - gNorm) / delta + 4.0) / 6.0

    [h, s, l]

// HSL to RGB conversion helper
hueToRgb(float p, float q, float t) =>
    float tAdj = t < 0.0 ? t + 1.0 : (t > 1.0 ? t - 1.0 : t)
    float result = tAdj < 1.0/6.0 ? p + (q - p) * 6.0 * tAdj :
                  (tAdj < 1.0/2.0 ? q :
                  (tAdj < 2.0/3.0 ? p + (q - p) * (2.0/3.0 - tAdj) * 6.0 : p))
    result

// HSL to RGB conversion
hslToRgb(float h, float s, float l) =>
    if s == 0
        [int(l * 255.0), int(l * 255.0), int(l * 255.0)]
    else
        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s
        float p = 2.0 * l - q
        [int(hueToRgb(p, q, h + 1.0/3.0) * 255.0), int(hueToRgb(p, q, h) * 255.0), int(hueToRgb(p, q, h - 1.0/3.0) * 255.0)]

// Check if level price is within ATR distance from current price
isWithinATR(float levelPrice, float currentPrice, float threshold, bool filterEnabled) =>
    not filterEnabled or na(levelPrice) or math.abs(levelPrice - currentPrice) <= threshold

// Get compact session abbreviation for daily sessions
getSessionAbbr(string sessionName) =>
    sessionName == "London" ? "LN" : sessionName == "New York" ? "NY" : sessionName == "Globex" ? "GLX" : sessionName == "Sydney" ? "SYD" : "TKY"

// LEVEL RENDERER UDT


type LevelRenderer
    string name
    bool enabled
    float price
    float priceRounded
    int startBar
    color levelColor
    int lineWidth
    string lineStyle
    line lineRef
    label labelRef

// Render method for a single level with deduplication support
method render(LevelRenderer this, bool groupCondition, bool checkDuplicate, map<float, string> priceLabels, array<float> renderedPrices, bool globalShowPriceValues, string labelSizeActual, float atrThreshold, bool useATRFilter) =>
    if groupCondition and this.enabled and not na(this.price) and isWithinATR(this.price, close, atrThreshold, useATRFilter) and (not checkDuplicate or not array.includes(renderedPrices, this.priceRounded))
        string combinedLabel = map.contains(priceLabels, this.priceRounded) ? map.get(priceLabels, this.priceRounded) : this.name
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(this.price, format.mintick) + ")" : combinedLabel
        if na(this.lineRef)
            line tempLine = line.new(this.startBar, this.price, bar_index, this.price, color=this.levelColor, width=this.lineWidth, style=getLineStyle(this.lineStyle))
            label tempLabel = label.new(bar_index, this.price, labelText, color=labelBgColor(this.levelColor), textcolor=this.levelColor, style=label.style_label_left, size=labelSizeActual)
            this.lineRef := tempLine
            this.labelRef := tempLabel
            true
        else
            line.set_xy1(this.lineRef, this.startBar, this.price)
            line.set_xy2(this.lineRef, bar_index, this.price)
            label.set_xy(this.labelRef, bar_index, this.price)
            label.set_text(this.labelRef, labelText)
            true
        array.push(renderedPrices, this.priceRounded)
        true
    else if not na(this.lineRef)
        line.delete(this.lineRef)
        this.lineRef := na
        label.delete(this.labelRef)
        this.labelRef := na
        true
    else
        true

method update(LevelRenderer this, bool enabled, float price, float priceRounded, int startBar) =>
    this.enabled := enabled
    this.price := price
    this.priceRounded := priceRounded
    this.startBar := startBar
    true

deleteLabel(array<label> labelArray, int idx) =>
    label oldLabel = array.get(labelArray, idx)
    if not na(oldLabel)
        label.delete(oldLabel)



// Calculate color with transparency, hue shift, and desaturation based on VWAP position in history (0 = most recent)
getVWAPColor(color baseColor, int positionInHistory, bool useDifferentiation, int maxTransp, int hueShift, int desat) =>
    if not useDifferentiation or positionInHistory == 0
        baseColor
    else
        // Linear gradient for transparency
        float normalizedPos = positionInHistory / 4.0  // Normalize to 0-1 range (assuming max 5 visible)
        int transparency = int(normalizedPos * maxTransp)

        // Extract RGB components
        float origR = color.r(baseColor)
        float origG = color.g(baseColor)
        float origB = color.b(baseColor)

        // Convert to HSL for proper hue rotation
        [h, s, l] = rgbToHsl(origR, origG, origB)

        // Apply hue shift (rotate around color wheel)
        if hueShift != 0
            float hueShiftAmount = (normalizedPos * hueShift) / 50.0  // -1.0 to +1.0 range
            h := h + hueShiftAmount
            h := h < 0.0 ? h + 1.0 : (h > 1.0 ? h - 1.0 : h)  // Wrap around

        // Apply desaturation
        if desat > 0
            float desatFactor = (normalizedPos * desat) / 100.0
            s := s * (1.0 - desatFactor)

        // Convert back to RGB
        [newR, newG, newB] = hslToRgb(h, s, l)

        // Apply transparency
        color.rgb(newR, newG, newB, math.min(transparency, maxTransp))

// Session time definitions in session's local timezone
// LSE: 8:00 AM - 4:30 PM GMT
// NYSE/CME: 9:30 AM - 4:00 PM EST
// CME Globex: 6:00 PM - 5:00 PM ET (next day, spans 2 calendar days)
// ASX: 10:00 AM - 4:00 PM AEDT
// TSE: 9:00 AM - 3:00 PM JST

getSessionTimezone(string session) =>
    session == "London" ? "Europe/London" : session == "New York" ? "America/New_York" : session == "Globex" ? "America/New_York" : session == "Sydney" ? "Australia/Sydney" : "Asia/Tokyo"

getSessionStartHour(string session) =>
    session == "London" ? 8 : session == "New York" ? 9 : session == "Globex" ? 18 : session == "Sydney" ? 10 : 9

getSessionStartMinute(string session) =>
    session == "New York" ? 30 : 0

getSessionEndHour(string session) =>
    session == "London" ? 16 : session == "New York" ? 16 : session == "Globex" ? 17 : session == "Sydney" ? 16 : 15

getSessionEndMinute(string session) =>
    session == "London" ? 30 : 0

// Calculate session start timestamp for a specific date (calendar-based, pre-calculated)
getSessionStartForDate(string session, int y, int m, int d) =>
    string tz = getSessionTimezone(session)
    int sessionHour = getSessionStartHour(session)
    int sessionMinute = getSessionStartMinute(session)
    timestamp(tz, y, m, d, sessionHour, sessionMinute)

// Calculate session end timestamp for a specific date
// Note: For Globex, end is on NEXT calendar day (starts 6 PM, ends 5 PM next day)
getSessionEndForDate(string session, int y, int m, int d) =>
    string tz = getSessionTimezone(session)
    int sessionHour = getSessionEndHour(session)
    int sessionMinute = getSessionEndMinute(session)
    // Globex spans two days: starts evening, ends next afternoon
    if session == "Globex"
        // Add 24 hours in milliseconds to base timestamp instead of incrementing day
        int baseTimestamp = timestamp(tz, y, m, d, sessionHour, sessionMinute)
        baseTimestamp + 86400000  // Add 1 day in milliseconds
    else
        timestamp(tz, y, m, d, sessionHour, sessionMinute)

// Common helper to collect session timestamps (start or end) for last N sessions
// CRITICAL: Collects trading days but avoids duplicate timestamps
// - Tracks each day's session timestamp
// - For Globex: Mon-Fri all map to same Sunday start, so we deduplicate
getSessionTimestampsArray(string session, int sessionsBack, bool isStart) =>
    var array<int> timestamps = array.new<int>()
    array.clear(timestamps)

    // Get session timezone to ensure date calculations are consistent
    string tz = getSessionTimezone(session)

    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    int currentD = dayofmonth(timenow, tz)
    int currentDayOfWeek = dayofweek(timenow, tz)

    // Adjust weekend to Friday; Globex trades Sunday so don't adjust Sunday for Globex
    if currentDayOfWeek == dayofweek.saturday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)
    else if currentDayOfWeek == dayofweek.sunday and session != "Globex"
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 172800000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)

    // For Globex on Mon-Fri, the session for "today" actually starts yesterday evening
    // So we need to check yesterday's session start time
    int todaySessionStart = na
    if session == "Globex" and currentDayOfWeek >= dayofweek.monday and currentDayOfWeek <= dayofweek.friday
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        int prevY = year(yesterdayMidnight, tz)
        int prevM = month(yesterdayMidnight, tz)
        int prevD = dayofmonth(yesterdayMidnight, tz)
        todaySessionStart := getSessionStartForDate(session, prevY, prevM, prevD)
    else
        todaySessionStart := getSessionStartForDate(session, currentY, currentM, currentD)

    int mostRecentY = currentY
    int mostRecentM = currentM
    int mostRecentD = currentD

    if timenow < todaySessionStart
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        mostRecentY := year(yesterdayMidnight, tz)
        mostRecentM := month(yesterdayMidnight, tz)
        mostRecentD := dayofmonth(yesterdayMidnight, tz)

    int sessionsCollected = 0
    int daysBackOffset = 0
    int lastTimestamp = na

    while sessionsCollected < sessionsBack
        int targetMidnight = timestamp(tz, mostRecentY, mostRecentM, mostRecentD, 0, 0) - (daysBackOffset * 86400000)
        int y = year(targetMidnight, tz)
        int m = month(targetMidnight, tz)
        int d = dayofmonth(targetMidnight, tz)
        int dow = dayofweek(targetMidnight, tz)

        bool isTradingDay = false
        if session == "Globex"
            isTradingDay := dow == dayofweek.sunday or (dow >= dayofweek.monday and dow <= dayofweek.friday)
        else
            isTradingDay := dow >= dayofweek.monday and dow <= dayofweek.friday

        if isTradingDay
            // For Globex: session active on day D starts evening of day D-1, EXCEPT Sunday
            int ts = na
            if session == "Globex"
                if dow == dayofweek.sunday
                    ts := isStart ? getSessionStartForDate(session, y, m, d) : getSessionEndForDate(session, y, m, d)
                else
                    int prevDayMidnight = timestamp(tz, y, m, d, 0, 0) - 86400000
                    int prevY = year(prevDayMidnight, tz)
                    int prevM = month(prevDayMidnight, tz)
                    int prevD = dayofmonth(prevDayMidnight, tz)
                    ts := isStart ? getSessionStartForDate(session, prevY, prevM, prevD) : getSessionEndForDate(session, prevY, prevM, prevD)
            else
                ts := isStart ? getSessionStartForDate(session, y, m, d) : getSessionEndForDate(session, y, m, d)

            if na(lastTimestamp) or ts != lastTimestamp
                array.unshift(timestamps, ts)
                lastTimestamp := ts
                sessionsCollected := sessionsCollected + 1

        daysBackOffset := daysBackOffset + 1

    timestamps

getSessionStartsArray(string session, int sessionsBack) =>
    getSessionTimestampsArray(session, sessionsBack, true)

getSessionEndsArray(string session, int sessionsBack) =>
    getSessionTimestampsArray(session, sessionsBack, false)


// Weekly anchor start timestamps (Monday for most, Sunday for Globex)
getWeeklyAnchorStartsArray(string session, int weeksBack) =>
    var array<int> starts = array.new<int>()
    array.clear(starts)

    string tz = getSessionTimezone(session)

    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    int currentD = dayofmonth(timenow, tz)
    int currentDayOfWeek = dayofweek(timenow, tz)

    // Step 2: Adjust weekend to Friday (same as daily sessions)
    if currentDayOfWeek == dayofweek.saturday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)
    else if currentDayOfWeek == dayofweek.sunday and session != "Globex"
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 172800000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)

    // Step 3: Check if today's session has started
    int todaySessionStart = getSessionStartForDate(session, currentY, currentM, currentD)
    int mostRecentY = currentY
    int mostRecentM = currentM
    int mostRecentD = currentD

    if timenow < todaySessionStart
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        mostRecentY := year(yesterdayMidnight, tz)
        mostRecentM := month(yesterdayMidnight, tz)
        mostRecentD := dayofmonth(yesterdayMidnight, tz)

    // Step 4: Walk backwards collecting only week-start days (Monday or Sunday)
    int targetDayOfWeek = session == "Globex" ? dayofweek.sunday : dayofweek.monday
    int weeksCollected = 0
    int daysBackOffset = 0

    while weeksCollected < weeksBack
        int targetMidnight = timestamp(tz, mostRecentY, mostRecentM, mostRecentD, 0, 0) - (daysBackOffset * 86400000)
        int y = year(targetMidnight, tz)
        int m = month(targetMidnight, tz)
        int d = dayofmonth(targetMidnight, tz)
        int dow = dayofweek(targetMidnight, tz)

        if dow == targetDayOfWeek
            // This is a week-start day - add the session start
            int weekStart = getSessionStartForDate(session, y, m, d)
            array.unshift(starts, weekStart)
            weeksCollected := weeksCollected + 1

        daysBackOffset := daysBackOffset + 1

    starts

// Convert period string to minutes
periodToMinutes(string period) =>
    period == "1m" ? 1 : period == "2m" ? 2 : period == "3m" ? 3 : period == "5m" ? 5 : period == "15m" ? 15 : period == "30m" ? 30 : period == "1h" ? 60 : period == "65m" ? 65 : period == "2h" ? 120 : period == "4h" ? 240 : period == "1D" ? 1440 : 99999

// Get timeframe in minutes for comparison
getTimeframeMinutes() =>
    int tfSeconds = timeframe.in_seconds()
    if tfSeconds >= 86400
        // Daily or larger timeframes return as days
        int days = tfSeconds / 86400
        days * 1440  // Convert days to minutes
    else
        tfSeconds / 60

// Add level to priceLabels map with duplicate detection
addToMap(map<float, string> priceMap, float price, string label) =>
    float key = roundToTick(price)
    string existing = map.contains(priceMap, key) ? map.get(priceMap, key) : ""
    if existing != ""
        map.put(priceMap, key, existing + "/" + label)
    else
        map.put(priceMap, key, label)

// DISPLAY CONDITIONS & ATR FILTERING

float atrValue = request.security(syminfo.tickerid, "D", ta.atr(atrPeriod), lookahead=barmerge.lookahead_on)
float atrThreshold = atrValue * atrMultiplier

bool isFutures = syminfo.type == "futures"

// Check timeframe conditions
int currentTfMinutes = getTimeframeMinutes()
bool meetsMaxTimeframe = keyLevelsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(keyLevelsMaxTimeframe)

// Check if key levels should be shown (futures filter + max timeframe filter)
bool showKeyLevelsCondition = showKeyLevels and (keyLevelsMode == "All Instruments" or (keyLevelsMode == "Only Futures" and isFutures)) and meetsMaxTimeframe

// Determine primary session name (used for long-term anchor and primary session logic)
string primarySessionName = longTermAnchorSession == "Auto" ? (syminfo.type == "stock" ? "New York" : "Globex") : longTermAnchorSession

// Check timeframe conditions for session features
bool meetsOtherSessionsTimeframe = otherSessionsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(otherSessionsMaxTimeframe)
bool meetsLongTermAnchorSessionTimeframe = longTermAnchorSessionMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(longTermAnchorSessionMaxTimeframe)
bool sessionBaseCondition = showSessionMarkers and (sessionMarkersMode == "Always" or (sessionMarkersMode == "Only Futures" and isFutures))
bool showSessionMarkersCondition = sessionBaseCondition and meetsOtherSessionsTimeframe

// Individual session VWAP timeframe checks (long-term anchor session gets extended visibility, others are intraday-only)
bool meetsLondonVWAPTimeframe = primarySessionName == "London" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsNYVWAPTimeframe = primarySessionName == "New York" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsGlobexVWAPTimeframe = primarySessionName == "Globex" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsSydneyVWAPTimeframe = primarySessionName == "Sydney" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsTokyoVWAPTimeframe = primarySessionName == "Tokyo" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe

// Check timeframe conditions for session intraday and pivot features
bool meetsSessionIntradayMaxTimeframe = sessionIntradayLevelsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(sessionIntradayLevelsMaxTimeframe)
bool meetsPivotMaxTimeframe = pivotMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(pivotMaxTimeframe)
bool showPivotsCondition = showPivots and meetsPivotMaxTimeframe

// Check timeframe condition for weekly anchors
bool meetsWeeklyAnchorMaxTimeframe = weeklyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(weeklyAnchorMaxTimeframe)

// KEY LEVELS DATA - Conditional requests for performance
var float pdh = na, var float pdl = na
var float pwh = na, var float pwl = na
var float pmh = na, var float pml = na
var float pyh = na, var float pyl = na

// Previous period levels - only update on confirmed bars (static values don't change intrabar)
if barstate.isconfirmed and showKeyLevelsCondition and (showPDH or showPDL or showCDH or showCDL)
    [_pdh, _pdl] = request.security(syminfo.tickerid, "D", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pdh := _pdh, pdl := _pdl
if barstate.isconfirmed and showKeyLevelsCondition and (showPWH or showPWL or showCWH or showCWL)
    [_pwh, _pwl] = request.security(syminfo.tickerid, "W", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pwh := _pwh, pwl := _pwl
if barstate.isconfirmed and showKeyLevelsCondition and (showPMH or showPML or showCMH or showCML)
    [_pmh, _pml] = request.security(syminfo.tickerid, "M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pmh := _pmh, pml := _pml
if barstate.isconfirmed and showKeyLevelsCondition and (showPYH or showPYL or showCYH or showCYL)
    [_pyh, _pyl] = request.security(syminfo.tickerid, "12M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pyh := _pyh, pyl := _pyl

// Current period levels (developing periods)
var float cdh = na, var float cdl = na
var float cwh = na, var float cwl = na
var float cmh = na, var float cml = na
var float cyh = na, var float cyl = na

if showKeyLevelsCondition and (showCDH or showCDL)
    [_cdh, _cdl] = request.security(syminfo.tickerid, "D", [high, low], lookahead=barmerge.lookahead_on)
    cdh := _cdh, cdl := _cdl
if showKeyLevelsCondition and (showCWH or showCWL)
    [_cwh, _cwl] = request.security(syminfo.tickerid, "W", [high, low], lookahead=barmerge.lookahead_on)
    cwh := _cwh, cwl := _cwl
if showKeyLevelsCondition and (showCMH or showCML)
    [_cmh, _cml] = request.security(syminfo.tickerid, "M", [high, low], lookahead=barmerge.lookahead_on)
    cmh := _cmh, cml := _cml
if showKeyLevelsCondition and (showCYH or showCYL)
    [_cyh, _cyl] = request.security(syminfo.tickerid, "12M", [high, low], lookahead=barmerge.lookahead_on)
    cyh := _cyh, cyl := _cyl

var float ath = na
float _ath = ta.highest(high, bar_index + 1)
if barstate.isconfirmed
    ath := showKeyLevelsCondition and showATH ? request.security(syminfo.tickerid, "M", _ath, lookahead=barmerge.lookahead_on) : na

// PIVOT POINTS (from previous day's HLC)
var float dailyHigh = na, var float dailyLow = na, var float dailyClose = na
if barstate.isconfirmed
    [_dailyHigh, _dailyLow, _dailyClose] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    dailyHigh := _dailyHigh
    dailyLow := _dailyLow
    dailyClose := _dailyClose

float dailyRange = dailyHigh - dailyLow
float pivotP = (dailyHigh + dailyLow + dailyClose) / 3
float pivotR1 = 2 * pivotP - dailyLow
float pivotS1 = 2 * pivotP - dailyHigh
float pivotR2 = pivotP + dailyRange
float pivotS2 = pivotP - dailyRange
float pivotR3 = dailyHigh + 2 * (pivotP - dailyLow)
float pivotS3 = dailyLow - 2 * (dailyHigh - pivotP)

var array<LevelRenderer> keyLevels = array.new<LevelRenderer>()
var array<LevelRenderer> pivotLevels = array.new<LevelRenderer>()
var array<LevelRenderer> sessionLevels = array.new<LevelRenderer>()

// MULTI-SESSION INFRASTRUCTURE

const int MAX_VWAP_HISTORY = 10
const int MAX_WEEKLY_HISTORY = 5

var array<bool> sessionEnabled = array.from(enableLondon, enableNewYork, enableGlobex, enableSydney, enableTokyo)
var array<string> sessionNames = array.from("London", "New York", "Globex", "Sydney", "Tokyo")
var array<color> sessionColors = array.from(colorLondon, colorNewYork, colorGlobex, colorSydney, colorTokyo)

var array<int> londonStarts = array.new<int>()
var array<int> nyStarts = array.new<int>()
var array<int> globexStarts = array.new<int>()
var array<int> sydneyStarts = array.new<int>()
var array<int> tokyoStarts = array.new<int>()

var array<int> londonEnds = array.new<int>()
var array<int> nyEnds = array.new<int>()
var array<int> globexEnds = array.new<int>()
var array<int> sydneyEnds = array.new<int>()
var array<int> tokyoEnds = array.new<int>()

if barstate.isfirst
    londonStarts := getSessionStartsArray("London", MAX_VWAP_HISTORY)
    nyStarts := getSessionStartsArray("New York", MAX_VWAP_HISTORY)
    globexStarts := getSessionStartsArray("Globex", MAX_VWAP_HISTORY)
    sydneyStarts := getSessionStartsArray("Sydney", MAX_VWAP_HISTORY)
    tokyoStarts := getSessionStartsArray("Tokyo", MAX_VWAP_HISTORY)

    londonEnds := getSessionEndsArray("London", MAX_VWAP_HISTORY)
    nyEnds := getSessionEndsArray("New York", MAX_VWAP_HISTORY)
    globexEnds := getSessionEndsArray("Globex", MAX_VWAP_HISTORY)
    sydneyEnds := getSessionEndsArray("Sydney", MAX_VWAP_HISTORY)
    tokyoEnds := getSessionEndsArray("Tokyo", MAX_VWAP_HISTORY)

var array<float> londonSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> londonSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> nySumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> nySumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> globexSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> globexSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> sydneySumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> sydneySumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> tokyoSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> tokyoSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)

var array<int> sessionStartBars = array.new<int>(5, na)
var array<int> sessionStartTimes = array.new<int>(5, na)
var array<label> sessionLabels = array.new<label>(5, na)

var array<int> weeklyAnchorStartsArray = array.new<int>(MAX_WEEKLY_HISTORY, na)
var array<float> weeklyAnchorSumSrc = array.new<float>(MAX_WEEKLY_HISTORY, 0.0)
var array<float> weeklyAnchorSumVol = array.new<float>(MAX_WEEKLY_HISTORY, 0.0)
var array<float> weeklyAnchorVWAPs = array.new<float>(MAX_WEEKLY_HISTORY, na)
var array<label> weeklyAnchorLabels = array.new<label>(MAX_WEEKLY_HISTORY, na)
var bool currentSessionIsWeeklyAnchor = false

if barstate.isfirst
    weeklyAnchorStartsArray := getWeeklyAnchorStartsArray(primarySessionName, MAX_WEEKLY_HISTORY)

var int activeSessionIndex = na
var string activeSessionName = na

var float sessionOpen = na
var float openRangeHigh = na
var float openRangeLow = na
var float initialBalanceHigh = na
var float initialBalanceLow = na
var int sessionStartBar = na
var int sessionStartTime = na

var int openPriceBar = na
var int orhBar = na
var int orlBar = na
var int ibhBar = na
var int iblBar = na

int openRangeMinutes = periodToMinutes(openRangePeriod)
int ibMinutes = periodToMinutes(initialBalancePeriod)

// UNIFIED SESSION DETECTION (Calendar-based)

for i = 0 to 4
    if array.get(sessionEnabled, i)
        string sessionName = array.get(sessionNames, i)

        array<int> sessionStartsArray = switch i
            0 => londonStarts
            1 => nyStarts
            2 => globexStarts
            3 => sydneyStarts
            => tokyoStarts
        int mostRecentSessionStart = array.get(sessionStartsArray, MAX_VWAP_HISTORY - 1)

        bool thisSessionChange = time >= mostRecentSessionStart and time[1] < mostRecentSessionStart

        if thisSessionChange
            array.set(sessionStartBars, i, bar_index)
            array.set(sessionStartTimes, i, mostRecentSessionStart)

            activeSessionIndex := i
            activeSessionName := sessionName

            sessionOpen := open
            openRangeHigh := high
            openRangeLow := low
            initialBalanceHigh := high
            initialBalanceLow := low
            sessionStartBar := bar_index
            sessionStartTime := mostRecentSessionStart
            openPriceBar := bar_index
            orhBar := bar_index
            orlBar := bar_index
            ibhBar := bar_index
            iblBar := bar_index

if not na(activeSessionIndex) and not na(sessionOpen) and not na(sessionStartTime)
    array<int> activeSessionEnds = switch activeSessionIndex
        0 => londonEnds
        1 => nyEnds
        2 => globexEnds
        3 => sydneyEnds
        => tokyoEnds
    int currentSessionEnd = array.get(activeSessionEnds, MAX_VWAP_HISTORY - 1)

    bool stillInSession = time >= sessionStartTime and time < currentSessionEnd

    if stillInSession
        int elapsedMinutes = math.round((time - sessionStartTime) / 60000)
        if elapsedMinutes <= openRangeMinutes
            if high > openRangeHigh
                openRangeHigh := high
                orhBar := bar_index
            if low < openRangeLow
                openRangeLow := low
                orlBar := bar_index

        if elapsedMinutes <= ibMinutes
            if high > initialBalanceHigh
                initialBalanceHigh := high
                ibhBar := bar_index
            if low < initialBalanceLow
                initialBalanceLow := low
                iblBar := bar_index

// MULTI-SESSION VWAP CALCULATIONS

var array<float> londonVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> nyVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> globexVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> sydneyVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> tokyoVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)

var array<label> londonLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> nyLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> globexLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> sydneyLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> tokyoLabels = array.new<label>(MAX_VWAP_HISTORY, na)

for i = 0 to 4
    if array.get(sessionEnabled, i)
        // Get configuration for this session type
        int historyCount = i == 0 ? londonVWAPCount : i == 1 ? nyVWAPCount : i == 2 ? globexVWAPCount : i == 3 ? sydneyVWAPCount : tokyoVWAPCount
        array<int> sessionStartsArray = i == 0 ? londonStarts : i == 1 ? nyStarts : i == 2 ? globexStarts : i == 3 ? sydneyStarts : tokyoStarts
        array<float> sumSrcArray = i == 0 ? londonSumSrc : i == 1 ? nySumSrc : i == 2 ? globexSumSrc : i == 3 ? sydneySumSrc : tokyoSumSrc
        array<float> sumVolArray = i == 0 ? londonSumVol : i == 1 ? nySumVol : i == 2 ? globexSumVol : i == 3 ? sydneySumVol : tokyoSumVol
        array<float> vwapArray = i == 0 ? londonVWAPs : i == 1 ? nyVWAPs : i == 2 ? globexVWAPs : i == 3 ? sydneyVWAPs : tokyoVWAPs
        array<label> labelArray = i == 0 ? londonLabels : i == 1 ? nyLabels : i == 2 ? globexLabels : i == 3 ? sydneyLabels : tokyoLabels
        color sessionColor = i == 0 ? colorLondon : i == 1 ? colorNewYork : i == 2 ? colorGlobex : i == 3 ? colorSydney : colorTokyo
        string sessionName = array.get(sessionNames, i)
        bool meetsThisSessionVWAPTimeframe = i == 0 ? meetsLondonVWAPTimeframe : i == 1 ? meetsNYVWAPTimeframe : i == 2 ? meetsGlobexVWAPTimeframe : i == 3 ? meetsSydneyVWAPTimeframe : meetsTokyoVWAPTimeframe

        // Loop through all tracked sessions (MAX_VWAP_HISTORY)
        for arrayIdx = 0 to MAX_VWAP_HISTORY - 1
            int sessionStart = array.get(sessionStartsArray, arrayIdx)

            // Get the next session start (to know when to stop calculating this VWAP)
            int nextSessionStart = arrayIdx < MAX_VWAP_HISTORY - 1 ? array.get(sessionStartsArray, arrayIdx + 1) : int(na)

            // Check if we're at the start of this session
            bool isSessionStart = time >= sessionStart and time[1] < sessionStart

            // Check if this VWAP is within the configured history count
            // Array layout: [0=oldest ... 9=newest] with MAX_VWAP_HISTORY=10
            // If historyCount=1: only arrayIdx=9 is visible (sessionIndexInHistory >= 0)
            // If historyCount=2: arrayIdx=8,9 are visible
            // If historyCount=5: arrayIdx=5,6,7,8,9 are visible
            int sessionIndexInHistory = arrayIdx - (MAX_VWAP_HISTORY - historyCount)
            bool isInConfiguredRange = sessionIndexInHistory >= 0

            // VWAPs should calculate as long as they're in the configured range AND after their session started
            // They continue calculating even after the next session starts (unlike the old logic)
            bool shouldCalculate = time >= sessionStart and isInConfiguredRange

            if shouldCalculate
                // Get current accumulators for this session
                float currentSumSrc = array.get(sumSrcArray, arrayIdx)
                float currentSumVol = array.get(sumVolArray, arrayIdx)

                // Reset accumulators on new session start, otherwise accumulate continuously
                float newSumSrc = isSessionStart ? (ohlc4 * volume) : (currentSumSrc + ohlc4 * volume)
                float newSumVol = isSessionStart ? volume : (currentSumVol + volume)

                // Update accumulators
                array.set(sumSrcArray, arrayIdx, newSumSrc)
                array.set(sumVolArray, arrayIdx, newSumVol)

                // Calculate VWAP and store in array
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(vwapArray, arrayIdx, vwap)

                // Create session label at session start ONLY if within configured history count and timeframe
                if isSessionStart and sessionBaseCondition and meetsThisSessionVWAPTimeframe and showSessionLabels and isInConfiguredRange
                    deleteLabel(labelArray, arrayIdx)
                    int positionInHistory = (MAX_VWAP_HISTORY - 1) - arrayIdx
                    color labelColor = getVWAPColor(sessionColor, positionInHistory, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation)
                    bool isPrimarySession = sessionName == primarySessionName
                    // For Globex, show the trading day (session end day) not the start day
                    int labelTimestamp = sessionName == "Globex" ? sessionStart + 86400000 : sessionStart
                    string sessionLabelText = compactSessionLabels ? (isPrimarySession ? "D" + str.tostring(positionInHistory + 1) : getSessionAbbr(sessionName) + str.tostring(positionInHistory + 1)) : sessionName + " " + str.format_time(labelTimestamp, "d MMM", getSessionTimezone(sessionName))
                    label newLabel = label.new(bar_index, high, sessionLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=labelColor, textcolor=color.white, size=getLabelSize(globalLabelSize), style=label.style_label_down)
                    array.set(labelArray, arrayIdx, newLabel)
                    if arrayIdx == MAX_VWAP_HISTORY - 1
                        array.set(sessionLabels, i, newLabel)

            // Clean up labels that are outside the configured history count
            if not isInConfiguredRange
                deleteLabel(labelArray, arrayIdx)
                array.set(labelArray, arrayIdx, na)

// Plot VWAPs - up to 5 historical sessions per type
bool skipLondonMostRecent = showWeeklyAnchorVWAP and primarySessionName == "London" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondon and londonVWAPCount >= 1 and not skipLondonMostRecent ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 1) : na, "London VWAP 1", color=getVWAPColor(colorLondon, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondon and londonVWAPCount >= 2 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 2) : na, "London VWAP 2", color=getVWAPColor(colorLondon, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondon and londonVWAPCount >= 3 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 3) : na, "London VWAP 3", color=getVWAPColor(colorLondon, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondon and londonVWAPCount >= 4 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 4) : na, "London VWAP 4", color=getVWAPColor(colorLondon, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondon and londonVWAPCount >= 5 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 5) : na, "London VWAP 5", color=getVWAPColor(colorLondon, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipNYMostRecent = showWeeklyAnchorVWAP and primarySessionName == "New York" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYork and nyVWAPCount >= 1 and not skipNYMostRecent ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 1) : na, "NY VWAP 1", color=getVWAPColor(colorNewYork, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYork and nyVWAPCount >= 2 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 2) : na, "NY VWAP 2", color=getVWAPColor(colorNewYork, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYork and nyVWAPCount >= 3 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 3) : na, "NY VWAP 3", color=getVWAPColor(colorNewYork, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYork and nyVWAPCount >= 4 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 4) : na, "NY VWAP 4", color=getVWAPColor(colorNewYork, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYork and nyVWAPCount >= 5 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 5) : na, "NY VWAP 5", color=getVWAPColor(colorNewYork, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipGlobexMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Globex" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobex and globexVWAPCount >= 1 and not skipGlobexMostRecent ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 1) : na, "Globex VWAP 1", color=getVWAPColor(colorGlobex, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobex and globexVWAPCount >= 2 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 2) : na, "Globex VWAP 2", color=getVWAPColor(colorGlobex, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobex and globexVWAPCount >= 3 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 3) : na, "Globex VWAP 3", color=getVWAPColor(colorGlobex, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobex and globexVWAPCount >= 4 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 4) : na, "Globex VWAP 4", color=getVWAPColor(colorGlobex, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobex and globexVWAPCount >= 5 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 5) : na, "Globex VWAP 5", color=getVWAPColor(colorGlobex, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipSydneyMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Sydney" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydney and sydneyVWAPCount >= 1 and not skipSydneyMostRecent ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 1) : na, "Sydney VWAP 1", color=getVWAPColor(colorSydney, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydney and sydneyVWAPCount >= 2 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 2) : na, "Sydney VWAP 2", color=getVWAPColor(colorSydney, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydney and sydneyVWAPCount >= 3 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 3) : na, "Sydney VWAP 3", color=getVWAPColor(colorSydney, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydney and sydneyVWAPCount >= 4 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 4) : na, "Sydney VWAP 4", color=getVWAPColor(colorSydney, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydney and sydneyVWAPCount >= 5 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 5) : na, "Sydney VWAP 5", color=getVWAPColor(colorSydney, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipTokyoMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Tokyo" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 1 and not skipTokyoMostRecent ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 1) : na, "Tokyo VWAP 1", color=getVWAPColor(colorTokyo, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 2 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 2) : na, "Tokyo VWAP 2", color=getVWAPColor(colorTokyo, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 3 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 3) : na, "Tokyo VWAP 3", color=getVWAPColor(colorTokyo, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 4 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 4) : na, "Tokyo VWAP 4", color=getVWAPColor(colorTokyo, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 5 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 5) : na, "Tokyo VWAP 5", color=getVWAPColor(colorTokyo, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEEKLY ANCHOR VWAP CALCULATION (Multi-week support)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Get the session arrays for the anchor session type (for skip logic)
array<int> anchorSessionStarts = switch primarySessionName
    "London" => londonStarts
    "New York" => nyStarts
    "Globex" => globexStarts
    "Sydney" => sydneyStarts
    => tokyoStarts

if showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe
    string anchorTZ = getSessionTimezone(primarySessionName)

    // Process each week in the array
    for weekIdx = 0 to MAX_WEEKLY_HISTORY - 1
        int weekStart = array.get(weeklyAnchorStartsArray, weekIdx)

        if not na(weekStart)
            // Detect when we cross into this week's start
            bool atWeekStart = time >= weekStart and time[1] < weekStart

            if atWeekStart
                // Reset accumulators for this week
                array.set(weeklyAnchorSumSrc, weekIdx, 0.0)
                array.set(weeklyAnchorSumVol, weekIdx, 0.0)

                // Check if this is the most recent week and matches the most recent daily session
                if weekIdx == MAX_WEEKLY_HISTORY - 1
                    currentSessionIsWeeklyAnchor := (weekStart == array.get(anchorSessionStarts, MAX_VWAP_HISTORY - 1))

                // Create label at week start (only if within count)
                bool shouldShowLabel = weekIdx >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
                if showSessionLabels and shouldShowLabel
                    label oldLabel = array.get(weeklyAnchorLabels, weekIdx)
                    if not na(oldLabel)
                        label.delete(oldLabel)
                    int positionInWeeklyHistory = (MAX_WEEKLY_HISTORY - 1) - weekIdx
                    string weeklyLabelText = compactWeeklyLabels ? "W" + str.tostring(positionInWeeklyHistory + 1) : "Week " + str.tostring(weekofyear(weekStart, anchorTZ)) + " (" + primarySessionName + ")"
                    label newLabel = label.new(bar_index, high, weeklyLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=colorWeeklyAnchor, textcolor=color.white, size=getLabelSize(globalLabelSize), style=label.style_label_down)
                    array.set(weeklyAnchorLabels, weekIdx, newLabel)

            // Accumulate if we're at or after this week's start
            if time >= weekStart
                float currentSumSrc = array.get(weeklyAnchorSumSrc, weekIdx)
                float currentSumVol = array.get(weeklyAnchorSumVol, weekIdx)
                array.set(weeklyAnchorSumSrc, weekIdx, currentSumSrc + (ohlc4 * volume))
                array.set(weeklyAnchorSumVol, weekIdx, currentSumVol + volume)

                float newSumSrc = array.get(weeklyAnchorSumSrc, weekIdx)
                float newSumVol = array.get(weeklyAnchorSumVol, weekIdx)
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(weeklyAnchorVWAPs, weekIdx, vwap)

// Plot weekly anchor VWAPs (only plot the number specified by count)
// Index 4 = most recent (when MAX=5), Index 3 = 2nd most recent, etc.
bool shouldPlot0 = 0 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot1 = 1 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot2 = 2 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot3 = 3 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot4 = 4 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)

plot(shouldPlot0 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 0) : na, "Weekly Anchor 1", color=colorWeeklyAnchor, linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot1 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 1) : na, "Weekly Anchor 2", color=colorWeeklyAnchor, linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot2 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 2) : na, "Weekly Anchor 3", color=colorWeeklyAnchor, linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot3 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 3) : na, "Weekly Anchor 4", color=colorWeeklyAnchor, linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot4 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 4) : na, "Weekly Anchor 5", color=colorWeeklyAnchor, linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION LEVELS RENDERING (for active session only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box boxOpenRange = na
var box boxInitialBalanceUpper = na
var box boxInitialBalanceLower = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEY LEVELS RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Cache bar_index to prevent redundant updates on same bar (improves scrolling performance)
var int lastRenderBarIndex = na

if barstate.islast and (na(lastRenderBarIndex) or bar_index != lastRenderBarIndex)
    lastRenderBarIndex := bar_index

    // Calculate line start position with hard limit to prevent lines getting too long
    int startBar = math.max(0, bar_index - globalLineLengthBars)
    int maxLineDistance = 200  // Safe hard limit: must match max value of globalLineLengthBars input (prevents crashes on high-frequency charts)

    // Determine session line start based on user preference, but reset to configured length if beyond hard limit
    int sessionOpenBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
    int openPriceStartBar = sessionLineStartMode == "Level Established" and not na(openPriceBar) ? (bar_index - openPriceBar > maxLineDistance ? startBar : openPriceBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orhStartBar = sessionLineStartMode == "Level Established" and not na(orhBar) ? (bar_index - orhBar > maxLineDistance ? startBar : orhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orlStartBar = sessionLineStartMode == "Level Established" and not na(orlBar) ? (bar_index - orlBar > maxLineDistance ? startBar : orlBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int ibhStartBar = sessionLineStartMode == "Level Established" and not na(ibhBar) ? (bar_index - ibhBar > maxLineDistance ? startBar : ibhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int iblStartBar = sessionLineStartMode == "Level Established" and not na(iblBar) ? (bar_index - iblBar > maxLineDistance ? startBar : iblBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)

    string keyLevelsLineStyleActual = getLineStyle(keyLevelsLineStyle)
    string labelSizeActual = getLabelSize(globalLabelSize)

    // Round prices for map key consistency
    float athRounded = roundToTick(ath)
    float pyhRounded = roundToTick(pyh)
    float pylRounded = roundToTick(pyl)
    float pmhRounded = roundToTick(pmh)
    float pmlRounded = roundToTick(pml)
    float pwhRounded = roundToTick(pwh)
    float pwlRounded = roundToTick(pwl)
    float pdhRounded = roundToTick(pdh)
    float pdlRounded = roundToTick(pdl)
    float cyhRounded = roundToTick(cyh)
    float cylRounded = roundToTick(cyl)
    float cmhRounded = roundToTick(cmh)
    float cmlRounded = roundToTick(cml)
    float cwhRounded = roundToTick(cwh)
    float cwlRounded = roundToTick(cwl)
    float cdhRounded = roundToTick(cdh)
    float cdlRounded = roundToTick(cdl)

    // Pivot points rounded
    float pivotPRounded = roundToTick(pivotP)
    float pivotR1Rounded = roundToTick(pivotR1)
    float pivotR2Rounded = roundToTick(pivotR2)
    float pivotR3Rounded = roundToTick(pivotR3)
    float pivotS1Rounded = roundToTick(pivotS1)
    float pivotS2Rounded = roundToTick(pivotS2)
    float pivotS3Rounded = roundToTick(pivotS3)

    // Session levels rounded
    float ibhRounded = roundToTick(initialBalanceHigh)
    float iblRounded = roundToTick(initialBalanceLow)
    float orhRounded = roundToTick(openRangeHigh)
    float orlRounded = roundToTick(openRangeLow)
    float openRounded = roundToTick(sessionOpen)

    // Build price->label map (merges duplicates with "/")
    // Priority: Session Levels > Pivot Points > Key Levels
    var map<float, string> priceLabels = map.new<float, string>()
    map.clear(priceLabels)

    // Session levels first (highest priority)
    bool shouldAddSessionToMap = showSessionMarkersCondition and not na(sessionOpen)
    if shouldAddSessionToMap
        if showOpenPrice
            addToMap(priceLabels, sessionOpen, "Open")
        if showOpenRange and not na(openRangeHigh)
            addToMap(priceLabels, openRangeHigh, "ORH")
        if showOpenRange and not na(openRangeLow)
            addToMap(priceLabels, openRangeLow, "ORL")
        if showInitialBalance and not na(initialBalanceHigh)
            addToMap(priceLabels, initialBalanceHigh, "IBH")
        if showInitialBalance and not na(initialBalanceLow)
            addToMap(priceLabels, initialBalanceLow, "IBL")

    // Pivot points second (after session, before key levels)
    if showPivotsCondition
        if showPivotP
            addToMap(priceLabels, pivotP, "P")
        if showPivotR1
            addToMap(priceLabels, pivotR1, "R1")
        if showPivotR2
            addToMap(priceLabels, pivotR2, "R2")
        if showPivotR3
            addToMap(priceLabels, pivotR3, "R3")
        if showPivotS1
            addToMap(priceLabels, pivotS1, "S1")
        if showPivotS2
            addToMap(priceLabels, pivotS2, "S2")
        if showPivotS3
            addToMap(priceLabels, pivotS3, "S3")

    // Key levels (lower priority)
    if showKeyLevelsCondition
        if showATH
            addToMap(priceLabels, ath, "ATH")
        if showPYH
            addToMap(priceLabels, pyh, "PYH")
        if showPYL
            addToMap(priceLabels, pyl, "PYL")
        if showPMH
            addToMap(priceLabels, pmh, "PMH")
        if showPML
            addToMap(priceLabels, pml, "PML")
        if showPWH
            addToMap(priceLabels, pwh, "PWH")
        if showPWL
            addToMap(priceLabels, pwl, "PWL")
        if showPDH
            addToMap(priceLabels, pdh, "PDH")
        if showPDL
            addToMap(priceLabels, pdl, "PDL")
        if showCYH
            addToMap(priceLabels, cyh, "CYH")
        if showCYL
            addToMap(priceLabels, cyl, "CYL")
        if showCMH
            addToMap(priceLabels, cmh, "CMH")
        if showCML
            addToMap(priceLabels, cml, "CML")
        if showCWH
            addToMap(priceLabels, cwh, "CWH")
        if showCWL
            addToMap(priceLabels, cwl, "CWL")
        if showCDH
            addToMap(priceLabels, cdh, "CDH")
        if showCDL
            addToMap(priceLabels, cdl, "CDL")

    var array<float> renderedPrices = array.new<float>()
    array.clear(renderedPrices)

    // Initialize level arrays on first render
    if array.size(sessionLevels) == 0
        array.push(sessionLevels, LevelRenderer.new("Open", showOpenPrice, sessionOpen, openRounded, openPriceStartBar, colorOpenPrice, sessionIntradayLevelsLineWidth, sessionIntradayLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("ORH", showOpenRange, openRangeHigh, orhRounded, orhStartBar, colorORH, sessionIntradayLevelsLineWidth, sessionIntradayLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("ORL", showOpenRange, openRangeLow, orlRounded, orlStartBar, colorORL, sessionIntradayLevelsLineWidth, sessionIntradayLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("IBH", showInitialBalance, initialBalanceHigh, ibhRounded, ibhStartBar, colorIBH, sessionIntradayLevelsLineWidth, sessionIntradayLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("IBL", showInitialBalance, initialBalanceLow, iblRounded, iblStartBar, colorIBL, sessionIntradayLevelsLineWidth, sessionIntradayLevelsLineStyle, na, na))

        array.push(pivotLevels, LevelRenderer.new("P", showPivotP, pivotP, pivotPRounded, startBar, pivotColorP, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("R1", showPivotR1, pivotR1, pivotR1Rounded, startBar, pivotColorR1, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("R2", showPivotR2, pivotR2, pivotR2Rounded, startBar, pivotColorR2, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("R3", showPivotR3, pivotR3, pivotR3Rounded, startBar, pivotColorR3, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("S1", showPivotS1, pivotS1, pivotS1Rounded, startBar, pivotColorS1, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("S2", showPivotS2, pivotS2, pivotS2Rounded, startBar, pivotColorS2, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("S3", showPivotS3, pivotS3, pivotS3Rounded, startBar, pivotColorS3, pivotLineWidth, pivotLineStyle, na, na))

        array.push(keyLevels, LevelRenderer.new("ATH", showATH, ath, athRounded, startBar, colorATH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PYH", showPYH, pyh, pyhRounded, startBar, colorPYH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PYL", showPYL, pyl, pylRounded, startBar, colorPYL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PMH", showPMH, pmh, pmhRounded, startBar, colorPMH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PML", showPML, pml, pmlRounded, startBar, colorPML, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PWH", showPWH, pwh, pwhRounded, startBar, colorPWH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PWL", showPWL, pwl, pwlRounded, startBar, colorPWL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PDH", showPDH, pdh, pdhRounded, startBar, colorPDH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PDL", showPDL, pdl, pdlRounded, startBar, colorPDL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CYH", showCYH, cyh, cyhRounded, startBar, colorCYH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CYL", showCYL, cyl, cylRounded, startBar, colorCYL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CMH", showCMH, cmh, cmhRounded, startBar, colorCMH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CML", showCML, cml, cmlRounded, startBar, colorCML, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CWH", showCWH, cwh, cwhRounded, startBar, colorCWH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CWL", showCWL, cwl, cwlRounded, startBar, colorCWL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CDH", showCDH, cdh, cdhRounded, startBar, colorCDH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CDL", showCDL, cdl, cdlRounded, startBar, colorCDL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
    else
        // Update level data each bar
        array.get(sessionLevels, 0).update(showOpenPrice, sessionOpen, openRounded, openPriceStartBar)
        array.get(sessionLevels, 1).update(showOpenRange, openRangeHigh, orhRounded, orhStartBar)
        array.get(sessionLevels, 2).update(showOpenRange, openRangeLow, orlRounded, orlStartBar)
        array.get(sessionLevels, 3).update(showInitialBalance, initialBalanceHigh, ibhRounded, ibhStartBar)
        array.get(sessionLevels, 4).update(showInitialBalance, initialBalanceLow, iblRounded, iblStartBar)

        array.get(pivotLevels, 0).update(showPivotP, pivotP, pivotPRounded, startBar)
        array.get(pivotLevels, 1).update(showPivotR1, pivotR1, pivotR1Rounded, startBar)
        array.get(pivotLevels, 2).update(showPivotR2, pivotR2, pivotR2Rounded, startBar)
        array.get(pivotLevels, 3).update(showPivotR3, pivotR3, pivotR3Rounded, startBar)
        array.get(pivotLevels, 4).update(showPivotS1, pivotS1, pivotS1Rounded, startBar)
        array.get(pivotLevels, 5).update(showPivotS2, pivotS2, pivotS2Rounded, startBar)
        array.get(pivotLevels, 6).update(showPivotS3, pivotS3, pivotS3Rounded, startBar)

        array.get(keyLevels, 0).update(showATH, ath, athRounded, startBar)
        array.get(keyLevels, 1).update(showPYH, pyh, pyhRounded, startBar)
        array.get(keyLevels, 2).update(showPYL, pyl, pylRounded, startBar)
        array.get(keyLevels, 3).update(showPMH, pmh, pmhRounded, startBar)
        array.get(keyLevels, 4).update(showPML, pml, pmlRounded, startBar)
        array.get(keyLevels, 5).update(showPWH, pwh, pwhRounded, startBar)
        array.get(keyLevels, 6).update(showPWL, pwl, pwlRounded, startBar)
        array.get(keyLevels, 7).update(showPDH, pdh, pdhRounded, startBar)
        array.get(keyLevels, 8).update(showPDL, pdl, pdlRounded, startBar)
        array.get(keyLevels, 9).update(showCYH, cyh, cyhRounded, startBar)
        array.get(keyLevels, 10).update(showCYL, cyl, cylRounded, startBar)
        array.get(keyLevels, 11).update(showCMH, cmh, cmhRounded, startBar)
        array.get(keyLevels, 12).update(showCML, cml, cmlRounded, startBar)
        array.get(keyLevels, 13).update(showCWH, cwh, cwhRounded, startBar)
        array.get(keyLevels, 14).update(showCWL, cwl, cwlRounded, startBar)
        array.get(keyLevels, 15).update(showCDH, cdh, cdhRounded, startBar)
        array.get(keyLevels, 16).update(showCDL, cdl, cdlRounded, startBar)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION LEVELS RENDERING (FIRST - highest priority for line style)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    string sessionLineStyleActual = getLineStyle(sessionIntradayLevelsLineStyle)
    // Only show session intraday levels if we meet the session intraday timeframe filter
    bool shouldShowSessionIntradayLevels = sessionBaseCondition and meetsSessionIntradayMaxTimeframe and not na(activeSessionIndex) and not na(sessionOpen)

    // Render session levels using array-based approach
    for level in sessionLevels
        level.render(shouldShowSessionIntradayLevels, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)

    // Open Range Background Shading
    if shouldShowSessionIntradayLevels and showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        int boxORStartBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
        boxOpenRange := updateBox(boxOpenRange, boxORStartBar, openRangeHigh, bar_index, openRangeLow, colorOpenRangeShade)
    else if not na(boxOpenRange)
        box.delete(boxOpenRange), boxOpenRange := na



    // Initial Balance Background Shading
    if shouldShowSessionIntradayLevels and showInitialBalance and shadeInitialBalance and not na(initialBalanceHigh) and not na(initialBalanceLow)
        int boxIBStartBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
        bool splitIBBox = showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        if splitIBBox
            if initialBalanceHigh > openRangeHigh
                boxInitialBalanceUpper := updateBox(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh, bar_index, openRangeHigh, colorInitialBalanceShade)
            else if not na(boxInitialBalanceUpper)
                box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
            if initialBalanceLow < openRangeLow
                boxInitialBalanceLower := updateBox(boxInitialBalanceLower, boxIBStartBar, openRangeLow, bar_index, initialBalanceLow, colorInitialBalanceShade)
            else if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
        else
            boxInitialBalanceUpper := updateBox(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh, bar_index, initialBalanceLow, colorInitialBalanceShade)
            if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
    else
        if not na(boxInitialBalanceUpper)
            box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
        if not na(boxInitialBalanceLower)
            box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PIVOT POINTS RENDERING (SECOND - after session levels, before key levels)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Render pivot levels using array-based approach
    for level in pivotLevels
        level.render(showPivotsCondition, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // KEY LEVELS RENDERING (THIRD - after session levels and pivots)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Render key levels using array-based approach
    for level in keyLevels
        level.render(showKeyLevelsCondition, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)
