// MIT License
//
// Copyright (c) 2025 User-3090
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//@version=6
indicator("Key Levels", overlay=true, max_lines_count=500, max_boxes_count=100)

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS â€” PREMIUM PANEL (GROUPING/ORDER ONLY; RUNTIME LOGIC UNCHANGED)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸŒ Global â€¢ Labels
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
globalLabelSize = input.string("Normal", "Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="ðŸŒ Global â€¢ Labels", tooltip="Label size for all levels")
globalShowPriceValues = input.bool(false, "Show Prices in Labels", group="ðŸŒ Global â€¢ Labels", tooltip="Show price in labels: 'PDH (4523.50)' vs 'PDH'")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸŒ Global â€¢ Visibility Filter
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
useATRFilter = input.bool(true, "Hide Distant Levels", group="ðŸŒ Global â€¢ Visibility Filter", tooltip="Only show levels within specified ATR distance from current price")
atrMultiplier = input.float(1.5, "Distance (ATR)", minval=1.0, maxval=10.0, step=0.5, group="ðŸŒ Global â€¢ Visibility Filter", tooltip="Hide levels beyond this many ATRs from current price")
atrPeriod = input.int(20, "ATR Period (Days)", minval=1, maxval=500, group="ðŸŒ Global â€¢ Visibility Filter", tooltip="ATR calculated from daily bars (last N days), regardless of chart timeframe")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸŒ Global â€¢ Geometry
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
globalLineLengthBars = input.int(50, "Line Length (Bars)", minval=10, maxval=200, group="ðŸŒ Global â€¢ Geometry", tooltip="Bars to extend lines backward from current bar (used when Line Start = Fixed Bars Back). Hard limit for lines: 200")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ•’ Sessions â€¢ General
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showSessionMarkers = input.bool(true, "Enable Sessions", group="ðŸ•’ Sessions â€¢ General", tooltip="Master switch for all session features (daily/weekly session anchors, session levels, labels).")

showSessionLabels = input.bool(true, "Show Labels", group="ðŸ•’ Sessions â€¢ General", tooltip="Show labels at the start of each session anchor.")
compactSessionLabels = input.bool(true, "Compact Labels", group="ðŸ•’ Sessions â€¢ General", tooltip="Use abbreviated session labels (e.g., 'GLX1') instead of full names with dates.")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ•’ Sessions â€¢ Daily (per session)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showSessionVWAP = input.bool(true, "Show Daily Sessions", group="ðŸ•’ Sessions â€¢ Daily", tooltip="Show daily session anchors (each session start).")

enableGlobex = input.bool(true, "Globex", inline="SS_GLX", group="ðŸ•’ Sessions â€¢ Daily")
colorGlobex = input.color(#4CAF50, "", inline="SS_GLX", group="ðŸ•’ Sessions â€¢ Daily")
globexVWAPCount = input.int(5, "History", inline="SS_GLX", minval=1, maxval=5, group="ðŸ•’ Sessions â€¢ Daily", tooltip="Number of daily sessions to show (1=current only, 2=current+previous).")

enableSydney = input.bool(false, "Sydney", inline="SS_SYD", group="ðŸ•’ Sessions â€¢ Daily")
colorSydney = input.color(#9C27B0, "", inline="SS_SYD", group="ðŸ•’ Sessions â€¢ Daily")
sydneyVWAPCount = input.int(1, "History", inline="SS_SYD", minval=1, maxval=5, group="ðŸ•’ Sessions â€¢ Daily", tooltip="Number of daily sessions to show (1=current only, 2=current+previous).")

enableTokyo = input.bool(false, "Tokyo", inline="SS_TKY", group="ðŸ•’ Sessions â€¢ Daily")
colorTokyo = input.color(#E91E63, "", inline="SS_TKY", group="ðŸ•’ Sessions â€¢ Daily")
tokyoVWAPCount = input.int(1, "History", inline="SS_TKY", minval=1, maxval=5, group="ðŸ•’ Sessions â€¢ Daily", tooltip="Number of daily sessions to show (1=current only, 2=current+previous).")

enableLondon = input.bool(true, "London", inline="SS_LON", group="ðŸ•’ Sessions â€¢ Daily")
colorLondon = input.color(#FF9800, "", inline="SS_LON", group="ðŸ•’ Sessions â€¢ Daily")
londonVWAPCount = input.int(1, "History", inline="SS_LON", minval=1, maxval=5, group="ðŸ•’ Sessions â€¢ Daily", tooltip="Number of daily sessions to show (1=current only, 2=current+previous).")

enableNewYork = input.bool(true, "New York", inline="SS_NY", group="ðŸ•’ Sessions â€¢ Daily")
colorNewYork = input.color(#2962FF, "", inline="SS_NY", group="ðŸ•’ Sessions â€¢ Daily")
nyVWAPCount = input.int(2, "History", inline="SS_NY", minval=1, maxval=5, group="ðŸ•’ Sessions â€¢ Daily", tooltip="Number of daily sessions to show (1=current only, 2=current+previous).")

longTermAnchorSession = input.string("Auto", "Anchor Session", options=["Auto", "Globex", "Sydney", "Tokyo", "London", "New York"], group="ðŸ•’ Sessions â€¢ Daily", tooltip="Used to determine which daily session keeps extended visibility at higher timeframes. Auto = New York for stocks, Globex for futures.")
longTermAnchorSessionMaxTimeframe = input.string("30m", "Max TF (Anchor Session)", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ•’ Sessions â€¢ Daily", tooltip="Maximum chart timeframe where the Anchor Session remains visible. Above this TF, that sessionâ€™s lines/labels are hidden.")
otherSessionsMaxTimeframe = input.string("5m", "Max TF (Other Sessions)", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ•’ Sessions â€¢ Daily", tooltip="Maximum chart timeframe where all non-anchor sessions remain visible. Above this TF, other sessionsâ€™ lines/labels are hidden.")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ—“ï¸ Sessions â€¢ Weekly (anchor timeframe)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showWeeklyAnchorVWAP = input.bool(true, "Show Weekly", inline="ANC_W", group="ðŸ—“ï¸ Sessions â€¢ Weekly", tooltip="Show weekly session anchor (first Anchor Session of the trading week).")
colorWeeklyAnchor = input.color(#b51b00, "", inline="ANC_W", group="ðŸ—“ï¸ Sessions â€¢ Weekly")
weeklyAnchorCount = input.int(5, "History", inline="ANC_W", minval=1, maxval=5, group="ðŸ—“ï¸ Sessions â€¢ Weekly", tooltip="Number of anchored weeks to show (1=current only, 2=current+previous).")
weeklyAnchorMaxTimeframe = input.string("4h", "Max TF", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D"], group="ðŸ—“ï¸ Sessions â€¢ Weekly", tooltip="Maximum chart timeframe where Weekly session anchors remain visible.")
compactWeeklyLabels = input.bool(true, "Compact Labels", group="ðŸ—“ï¸ Sessions â€¢ Weekly", tooltip="Use short weekly labels (e.g., 'W1', 'W2').")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸŽ›ï¸ Sessions â€¢ Style
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sessionVWAPLineStyleInput = input.string("Dotted", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸŽ›ï¸ Sessions â€¢ Style", tooltip="Line appearance for session anchors.")
sessionVWAPLineWidth = input.int(3, "Line Width", minval=1, maxval=5, group="ðŸŽ›ï¸ Sessions â€¢ Style", tooltip="Line thickness for session anchors.")
sessionVWAPLineStyle = sessionVWAPLineStyleInput == "Solid" ? plot.linestyle_solid : sessionVWAPLineStyleInput == "Dashed" ? plot.linestyle_dashed : plot.linestyle_dotted

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸŽ¨ Sessions â€¢ History Style
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
vwapColorDifferentiation = input.bool(true, "Differentiate History (Daily)", group="ðŸŽ¨ Sessions â€¢ History Style", tooltip="Visually differentiate older daily sessions from the most recent.")
vwapMaxTransparency = input.int(0, "Oldest Transparency (Daily)", minval=0, maxval=95, group="ðŸŽ¨ Sessions â€¢ History Style", tooltip="Transparency applied to the oldest visible daily session (0=opaque).")
vwapDesaturation = input.int(0, "Desaturation (Daily)", minval=0, maxval=100, group="ðŸŽ¨ Sessions â€¢ History Style", tooltip="Reduce color vibrancy for older daily sessions (0=vibrant, 100=gray).")
vwapHueShift = input.int(-12, "Hue Shift (Daily)", minval=-50, maxval=50, group="ðŸŽ¨ Sessions â€¢ History Style", tooltip="Shift hue for older daily sessions (-=cooler, +=warmer).")

longTermAnchorColorDifferentiation = input.bool(true, "Differentiate History (Weekly)", group="ðŸŽ¨ Sessions â€¢ History Style", tooltip="Visually differentiate older weekly session anchors from the most recent.")
longTermAnchorMaxTransparency = input.int(0, "Oldest Transparency (Weekly)", minval=0, maxval=95, group="ðŸŽ¨ Sessions â€¢ History Style", tooltip="Transparency applied to the oldest visible weekly session anchor (0=opaque).")
longTermAnchorDesaturation = input.int(0, "Desaturation (Weekly)", minval=0, maxval=100, group="ðŸŽ¨ Sessions â€¢ History Style", tooltip="Reduce color vibrancy for older weekly session anchors (0=vibrant, 100=gray).")
longTermAnchorHueShift = input.int(-12, "Hue Shift (Weekly)", minval=-50, maxval=50, group="ðŸŽ¨ Sessions â€¢ History Style", tooltip="Shift hue for older weekly session anchors (-=cooler, +=warmer).")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ Sessions â€¢ Levels â€¢ Visibility
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sessionLevelsMaxTimeframe = input.string("5m", "Max TF", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ“ Sessions â€¢ Levels â€¢ Visibility", tooltip="Hide session levels on timeframes above this")
sessionLineStartMode = input.string("Level Established", "Line Start", options=["Session Open", "Level Established", "Fixed Bars Back"], group="ðŸ“ Sessions â€¢ Levels â€¢ Visibility", tooltip="Session Open: from session start\nLevel Established: from where level was created\nFixed Bars Back: use ðŸŒ Global â€¢ Geometry â†’ Line Length (Bars)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Sessions â€¢ Levels â€¢ Open
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showOpenPrice = input.bool(true, "Open", inline="SL_OP", group="ðŸ“ Sessions â€¢ Levels â€¢ Open")
colorOpenPrice = input.color(#fbbe30, "", inline="SL_OP", group="ðŸ“ Sessions â€¢ Levels â€¢ Open", tooltip="First price at session open")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Sessions â€¢ Levels â€¢ Opening Range
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showOpenRange = input.bool(true, "Opening Range", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range", tooltip="High/Low of the first 15â€“30 minutes (early volatility reference)")
openRangePeriod = input.string("30m", "Period", options=["15m", "30m"], group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range")
colorORH = input.color(#4682b4, "Opening Range High", inline="SL_OR", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range")
colorORL = input.color(#cd5c5c, "Opening Range Low", inline="SL_OR", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range")
shadeOpenRange = input.bool(true, "Shade", inline="SL_OR_SHADE", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range")
colorOpenRangeShade = input.color(color.new(color.red, 98), "Shade Color", inline="SL_OR_SHADE", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range", tooltip="Fill between Opening Range High/Low")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showInitialBalance = input.bool(false, "Initial Balance", group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance", tooltip="High/Low of the first 30â€“60 minutes (institutional reference)")
initialBalancePeriod = input.string("1h", "Period", options=["30m", "1h"], group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance")
colorIBH = input.color(#81ce6f, "Initial Balance High", inline="SL_IB", group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance")
colorIBL = input.color(#e43b38, "Initial Balance Low", inline="SL_IB", group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance")
shadeInitialBalance = input.bool(true, "Shade", inline="SL_IB_SHADE", group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance")
colorInitialBalanceShade = input.color(color.new(color.green, 98), "Shade Color", inline="SL_IB_SHADE", group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance", tooltip="Fill between Initial Balance High/Low")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸŽ›ï¸ Sessions â€¢ Levels â€¢ Style
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sessionLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸŽ›ï¸ Sessions â€¢ Levels â€¢ Style")
sessionLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ðŸŽ›ï¸ Sessions â€¢ Levels â€¢ Style", tooltip="Width for Open / Opening Range / Initial Balance lines")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ” Pivot Points â€¢ Enable
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showPivots = input.bool(true, "Enable Pivot Points", group="ðŸ” Pivot Points â€¢ Enable", tooltip="Traditional pivots from previous day H/L/C")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ” Pivot Points â€¢ Visibility
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pivotMaxTimeframe = input.string("4h", "Max TF", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ” Pivot Points â€¢ Visibility", tooltip="Hide on timeframes above this")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ” Pivot Points â€¢ Levels (topâ†’bottom on chart)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showPivotR3 = input.bool(true, "R3", inline="PV_R3", group="ðŸ” Pivot Points â€¢ Levels")
pivotColorR3 = input.color(#449955, "", inline="PV_R3", group="ðŸ” Pivot Points â€¢ Levels")
showPivotR2 = input.bool(true, "R2", inline="PV_R2", group="ðŸ” Pivot Points â€¢ Levels")
pivotColorR2 = input.color(#449955, "", inline="PV_R2", group="ðŸ” Pivot Points â€¢ Levels")
showPivotR1 = input.bool(false, "R1", inline="PV_R1", group="ðŸ” Pivot Points â€¢ Levels")
pivotColorR1 = input.color(#449955, "", inline="PV_R1", group="ðŸ” Pivot Points â€¢ Levels")

showPivotP = input.bool(false, "P", inline="PV_P", group="ðŸ” Pivot Points â€¢ Levels")
pivotColorP = input.color(#808080, "", inline="PV_P", group="ðŸ” Pivot Points â€¢ Levels")

showPivotS1 = input.bool(false, "S1", inline="PV_S1", group="ðŸ” Pivot Points â€¢ Levels")
pivotColorS1 = input.color(#b51b00, "", inline="PV_S1", group="ðŸ” Pivot Points â€¢ Levels")
showPivotS2 = input.bool(true, "S2", inline="PV_S2", group="ðŸ” Pivot Points â€¢ Levels")
pivotColorS2 = input.color(#b51b00, "", inline="PV_S2", group="ðŸ” Pivot Points â€¢ Levels")
showPivotS3 = input.bool(true, "S3", inline="PV_S3", group="ðŸ” Pivot Points â€¢ Levels")
pivotColorS3 = input.color(#b51b00, "", inline="PV_S3", group="ðŸ” Pivot Points â€¢ Levels")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ” Pivot Points â€¢ Style
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pivotLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸ” Pivot Points â€¢ Style")
pivotLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ðŸ” Pivot Points â€¢ Style")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ˆ Key Levels â€¢ Enable
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showKeyLevels = input.bool(true, "Enable Key Levels", group="ðŸ“ˆ Key Levels â€¢ Enable", tooltip="Master toggle for ATH/Year/Month/Week/Day levels")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ˆ Key Levels â€¢ Visibility
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
keyLevelsMaxTimeframe = input.string("15m", "Max TF", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ“ˆ Key Levels â€¢ Visibility", tooltip="Hide on larger timeframes")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ˆ Key Levels â€¢ Levels (longest horizonâ†’shortest; currentâ†’previous; Highâ†’Low)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showATH = input.bool(true, "ATH", inline="KL_ATH", group="ðŸ“ˆ Key Levels â€¢ Levels")
colorATH = input.color(#00fcff, "", inline="KL_ATH", group="ðŸ“ˆ Key Levels â€¢ Levels", tooltip="All-time high")

showCYH = input.bool(true, "Current YH", inline="KL_CY", group="Key Levels â€¢ Year")
colorCYH = input.color(#449955, "", inline="KL_CY", group="Key Levels â€¢ Year")
showCYL = input.bool(true, "Current YL", inline="KL_CY", group="Key Levels â€¢ Year")
colorCYL = input.color(#b51b00, "", inline="KL_CY", group="Key Levels â€¢ Year")

showPYH = input.bool(true, "Previous YH", inline="KL_PY", group="Key Levels â€¢ Year")
colorPYH = input.color(#449955, "", inline="KL_PY", group="Key Levels â€¢ Year")
showPYL = input.bool(true, "Previous YL", inline="KL_PY", group="Key Levels â€¢ Year")
colorPYL = input.color(#b51b00, "", inline="KL_PY", group="Key Levels â€¢ Year")

showCMH = input.bool(true, "Current MH", inline="KL_CM", group="Key Levels â€¢ Month")
colorCMH = input.color(#449955, "", inline="KL_CM", group="Key Levels â€¢ Month")
showCML = input.bool(true, "Current ML", inline="KL_CM", group="Key Levels â€¢ Month")
colorCML = input.color(#b51b00, "", inline="KL_CM", group="Key Levels â€¢ Month")

showPMH = input.bool(true, "Previous MH", inline="KL_PM", group="Key Levels â€¢ Month")
colorPMH = input.color(#449955, "", inline="KL_PM", group="Key Levels â€¢ Month")
showPML = input.bool(true, "Previous ML", inline="KL_PM", group="Key Levels â€¢ Month")
colorPML = input.color(#b51b00, "", inline="KL_PM", group="Key Levels â€¢ Month")

showCWH = input.bool(true, "Current WH", inline="KL_CW", group="Key Levels â€¢ Week")
colorCWH = input.color(#449955, "", inline="KL_CW", group="Key Levels â€¢ Week")
showCWL = input.bool(true, "Current WL", inline="KL_CW", group="Key Levels â€¢ Week")
colorCWL = input.color(#b51b00, "", inline="KL_CW", group="Key Levels â€¢ Week")

showPWH = input.bool(true, "Previous WH", inline="KL_PW", group="Key Levels â€¢ Week")
colorPWH = input.color(#449955, "", inline="KL_PW", group="Key Levels â€¢ Week")
showPWL = input.bool(true, "Previous WL", inline="KL_PW", group="Key Levels â€¢ Week")
colorPWL = input.color(#b51b00, "", inline="KL_PW", group="Key Levels â€¢ Week")

showCDH = input.bool(true, "Current DH", inline="KL_CD", group="Key Levels â€¢ Day")
colorCDH = input.color(#449955, "", inline="KL_CD", group="Key Levels â€¢ Day")
showCDL = input.bool(true, "Current DL", inline="KL_CD", group="Key Levels â€¢ Day")
colorCDL = input.color(#b51b00, "", inline="KL_CD", group="Key Levels â€¢ Day")

showPDH = input.bool(true, "Previous DH", inline="KL_PD", group="Key Levels â€¢ Day")
colorPDH = input.color(#449955, "", inline="KL_PD", group="Key Levels â€¢ Day")
showPDL = input.bool(true, "Previous DL", inline="KL_PD", group="Key Levels â€¢ Day")
colorPDL = input.color(#b51b00, "", inline="KL_PD", group="Key Levels â€¢ Day")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Key Levels â€¢ Style
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
keyLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="Key Levels â€¢ Style")
keyLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="Key Levels â€¢ Style")

// HELPER FUNCTIONS


getLabelSize(string sizeStr) =>
    sizeStr == "Tiny" ? size.tiny : sizeStr == "Small" ? size.small : sizeStr == "Large" ? size.large : sizeStr == "Huge" ? size.huge : size.normal

getLineStyle(string styleStr) =>
    styleStr == "Solid" ? line.style_solid : styleStr == "Dashed" ? line.style_dashed : line.style_dotted

labelBgColor(color c) => color.new(c, 100)

roundToTick(float price) =>
    syminfo.mintick > 0 ? math.round(price / syminfo.mintick) * syminfo.mintick : price

updateBox(box boxRef, int x1, float y1, int x2, float y2, color bg) =>
    if na(boxRef)
        box.new(x1, y1, x2, y2, border_color=na, bgcolor=bg)
    else
        box.set_lefttop(boxRef, x1, y1)
        box.set_rightbottom(boxRef, x2, y2)
        boxRef

// RGB to HSL conversion
rgbToHsl(float r, float g, float b) =>
    float rNorm = r / 255.0
    float gNorm = g / 255.0
    float bNorm = b / 255.0

    float maxVal = math.max(rNorm, math.max(gNorm, bNorm))
    float minVal = math.min(rNorm, math.min(gNorm, bNorm))
    float delta = maxVal - minVal

    float h = 0.0
    float s = 0.0
    float l = (maxVal + minVal) / 2.0

    if delta != 0
        s := l > 0.5 ? delta / (2.0 - maxVal - minVal) : delta / (maxVal + minVal)

        if maxVal == rNorm
            h := ((gNorm - bNorm) / delta + (gNorm < bNorm ? 6.0 : 0.0)) / 6.0
        else if maxVal == gNorm
            h := ((bNorm - rNorm) / delta + 2.0) / 6.0
        else
            h := ((rNorm - gNorm) / delta + 4.0) / 6.0

    [h, s, l]

// HSL to RGB conversion helper
hueToRgb(float p, float q, float t) =>
    float tAdj = t < 0.0 ? t + 1.0 : (t > 1.0 ? t - 1.0 : t)
    float result = tAdj < 1.0/6.0 ? p + (q - p) * 6.0 * tAdj :
                  (tAdj < 1.0/2.0 ? q :
                  (tAdj < 2.0/3.0 ? p + (q - p) * (2.0/3.0 - tAdj) * 6.0 : p))
    result

// HSL to RGB conversion
hslToRgb(float h, float s, float l) =>
    if s == 0
        [int(l * 255.0), int(l * 255.0), int(l * 255.0)]
    else
        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s
        float p = 2.0 * l - q
        [int(hueToRgb(p, q, h + 1.0/3.0) * 255.0), int(hueToRgb(p, q, h) * 255.0), int(hueToRgb(p, q, h - 1.0/3.0) * 255.0)]

// Check if level price is within ATR distance from current price
isWithinATR(float levelPrice, float currentPrice, float threshold, bool filterEnabled) =>
    not filterEnabled or na(levelPrice) or math.abs(levelPrice - currentPrice) <= threshold

// Get compact session abbreviation for daily sessions
getSessionAbbr(string sessionName) =>
    sessionName == "London" ? "LN" : sessionName == "New York" ? "NY" : sessionName == "Globex" ? "GLX" : sessionName == "Sydney" ? "SYD" : "TKY"

// LEVEL RENDERER UDT


type LevelRenderer
    string name
    bool enabled
    float price
    float priceRounded
    int startBar
    color levelColor
    int lineWidth
    string lineStyle
    line lineRef
    label labelRef

// Render method for a single level with deduplication support
method render(LevelRenderer this, bool groupCondition, bool checkDuplicate, map<float, string> priceLabels, array<float> renderedPrices, bool globalShowPriceValues, string labelSizeActual, float atrThreshold, bool useATRFilter) =>
    if groupCondition and this.enabled and not na(this.price) and isWithinATR(this.price, close, atrThreshold, useATRFilter) and (not checkDuplicate or not array.includes(renderedPrices, this.priceRounded))
        string combinedLabel = map.contains(priceLabels, this.priceRounded) ? map.get(priceLabels, this.priceRounded) : this.name
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(this.price, format.mintick) + ")" : combinedLabel
        if na(this.lineRef)
            line tempLine = line.new(this.startBar, this.price, bar_index, this.price, color=this.levelColor, width=this.lineWidth, style=getLineStyle(this.lineStyle))
            label tempLabel = label.new(bar_index, this.price, labelText, color=labelBgColor(this.levelColor), textcolor=this.levelColor, style=label.style_label_left, size=labelSizeActual)
            this.lineRef := tempLine
            this.labelRef := tempLabel
            true
        else
            line.set_xy1(this.lineRef, this.startBar, this.price)
            line.set_xy2(this.lineRef, bar_index, this.price)
            label.set_xy(this.labelRef, bar_index, this.price)
            label.set_text(this.labelRef, labelText)
            true
        array.push(renderedPrices, this.priceRounded)
        true
    else if not na(this.lineRef)
        line.delete(this.lineRef)
        this.lineRef := na
        label.delete(this.labelRef)
        this.labelRef := na
        true
    else
        true

method update(LevelRenderer this, bool enabled, float price, float priceRounded, int startBar) =>
    this.enabled := enabled
    this.price := price
    this.priceRounded := priceRounded
    this.startBar := startBar
    true

deleteLabel(array<label> labelArray, int idx) =>
    label oldLabel = array.get(labelArray, idx)
    if not na(oldLabel)
        label.delete(oldLabel)



// Calculate color with transparency, hue shift, and desaturation based on VWAP position in history (0 = most recent)
getVWAPColor(color baseColor, int positionInHistory, bool useDifferentiation, int maxTransp, int hueShift, int desat) =>
    if not useDifferentiation or positionInHistory == 0
        baseColor
    else
        // Linear gradient for transparency
        float normalizedPos = positionInHistory / 4.0  // Normalize to 0-1 range (assuming max 5 visible)
        int transparency = int(normalizedPos * maxTransp)

        // Extract RGB components
        float origR = color.r(baseColor)
        float origG = color.g(baseColor)
        float origB = color.b(baseColor)

        // Convert to HSL for proper hue rotation
        [h, s, l] = rgbToHsl(origR, origG, origB)

        // Apply hue shift (rotate around color wheel)
        if hueShift != 0
            float hueShiftAmount = (normalizedPos * hueShift) / 50.0  // -1.0 to +1.0 range
            h := h + hueShiftAmount
            h := h < 0.0 ? h + 1.0 : (h > 1.0 ? h - 1.0 : h)  // Wrap around

        // Apply desaturation
        if desat > 0
            float desatFactor = (normalizedPos * desat) / 100.0
            s := s * (1.0 - desatFactor)

        // Convert back to RGB
        [newR, newG, newB] = hslToRgb(h, s, l)

        // Apply transparency
        color.rgb(newR, newG, newB, math.min(transparency, maxTransp))

// Session time definitions in session's local timezone
// LSE: 8:00 AM - 4:30 PM GMT
// NYSE/CME: 9:30 AM - 4:00 PM EST
// CME Globex: 6:00 PM - 5:00 PM ET (next day, spans 2 calendar days)
// ASX: 10:00 AM - 4:00 PM AEDT
// TSE: 9:00 AM - 3:00 PM JST

getSessionTimezone(string session) =>
    session == "London" ? "Europe/London" : session == "New York" ? "America/New_York" : session == "Globex" ? "America/New_York" : session == "Sydney" ? "Australia/Sydney" : "Asia/Tokyo"

getSessionStartHour(string session) =>
    session == "London" ? 8 : session == "New York" ? 9 : session == "Globex" ? 18 : session == "Sydney" ? 10 : 9

getSessionStartMinute(string session) =>
    session == "New York" ? 30 : 0

getSessionEndHour(string session) =>
    session == "London" ? 16 : session == "New York" ? 16 : session == "Globex" ? 17 : session == "Sydney" ? 16 : 15

getSessionEndMinute(string session) =>
    session == "London" ? 30 : 0

// Calculate session start timestamp for a specific date (calendar-based, pre-calculated)
getSessionStartForDate(string session, int y, int m, int d) =>
    string tz = getSessionTimezone(session)
    int sessionHour = getSessionStartHour(session)
    int sessionMinute = getSessionStartMinute(session)
    timestamp(tz, y, m, d, sessionHour, sessionMinute)

// Calculate session end timestamp for a specific date
// Note: For Globex, end is on NEXT calendar day (starts 6 PM, ends 5 PM next day)
getSessionEndForDate(string session, int y, int m, int d) =>
    string tz = getSessionTimezone(session)
    int sessionHour = getSessionEndHour(session)
    int sessionMinute = getSessionEndMinute(session)
    // Globex spans two days: starts evening, ends next afternoon
    if session == "Globex"
        // Add 24 hours in milliseconds to base timestamp instead of incrementing day
        int baseTimestamp = timestamp(tz, y, m, d, sessionHour, sessionMinute)
        baseTimestamp + 86400000  // Add 1 day in milliseconds
    else
        timestamp(tz, y, m, d, sessionHour, sessionMinute)

// Common helper to collect session timestamps (start or end) for last N sessions
// CRITICAL: Collects trading days but avoids duplicate timestamps
// - Tracks each day's session timestamp
// - For Globex: Mon-Fri all map to same Sunday start, so we deduplicate
getSessionTimestampsArray(string session, int sessionsBack, bool isStart) =>
    var array<int> timestamps = array.new<int>()
    array.clear(timestamps)

    // Get session timezone to ensure date calculations are consistent
    string tz = getSessionTimezone(session)

    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    int currentD = dayofmonth(timenow, tz)
    int currentDayOfWeek = dayofweek(timenow, tz)

    // Adjust weekend to Friday; Globex trades Sunday so don't adjust Sunday for Globex
    if currentDayOfWeek == dayofweek.saturday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)
    else if currentDayOfWeek == dayofweek.sunday and session != "Globex"
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 172800000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)

    // For Globex on Mon-Fri, the session for "today" actually starts yesterday evening
    // So we need to check yesterday's session start time
    int todaySessionStart = na
    if session == "Globex" and currentDayOfWeek >= dayofweek.monday and currentDayOfWeek <= dayofweek.friday
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        int prevY = year(yesterdayMidnight, tz)
        int prevM = month(yesterdayMidnight, tz)
        int prevD = dayofmonth(yesterdayMidnight, tz)
        todaySessionStart := getSessionStartForDate(session, prevY, prevM, prevD)
    else
        todaySessionStart := getSessionStartForDate(session, currentY, currentM, currentD)

    int mostRecentY = currentY
    int mostRecentM = currentM
    int mostRecentD = currentD

    if timenow < todaySessionStart
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        mostRecentY := year(yesterdayMidnight, tz)
        mostRecentM := month(yesterdayMidnight, tz)
        mostRecentD := dayofmonth(yesterdayMidnight, tz)

    int sessionsCollected = 0
    int daysBackOffset = 0
    int lastTimestamp = na

    while sessionsCollected < sessionsBack
        int targetMidnight = timestamp(tz, mostRecentY, mostRecentM, mostRecentD, 0, 0) - (daysBackOffset * 86400000)
        int y = year(targetMidnight, tz)
        int m = month(targetMidnight, tz)
        int d = dayofmonth(targetMidnight, tz)
        int dow = dayofweek(targetMidnight, tz)

        bool isTradingDay = false
        if session == "Globex"
            isTradingDay := dow == dayofweek.sunday or (dow >= dayofweek.monday and dow <= dayofweek.friday)
        else
            isTradingDay := dow >= dayofweek.monday and dow <= dayofweek.friday

        if isTradingDay
            // For Globex: session active on day D starts evening of day D-1, EXCEPT Sunday
            int ts = na
            if session == "Globex"
                if dow == dayofweek.sunday
                    ts := isStart ? getSessionStartForDate(session, y, m, d) : getSessionEndForDate(session, y, m, d)
                else
                    int prevDayMidnight = timestamp(tz, y, m, d, 0, 0) - 86400000
                    int prevY = year(prevDayMidnight, tz)
                    int prevM = month(prevDayMidnight, tz)
                    int prevD = dayofmonth(prevDayMidnight, tz)
                    ts := isStart ? getSessionStartForDate(session, prevY, prevM, prevD) : getSessionEndForDate(session, prevY, prevM, prevD)
            else
                ts := isStart ? getSessionStartForDate(session, y, m, d) : getSessionEndForDate(session, y, m, d)

            if na(lastTimestamp) or ts != lastTimestamp
                array.unshift(timestamps, ts)
                lastTimestamp := ts
                sessionsCollected := sessionsCollected + 1

        daysBackOffset := daysBackOffset + 1

    timestamps

getSessionStartsArray(string session, int sessionsBack) =>
    getSessionTimestampsArray(session, sessionsBack, true)

getSessionEndsArray(string session, int sessionsBack) =>
    getSessionTimestampsArray(session, sessionsBack, false)


// Weekly anchor start timestamps (Monday for most, Sunday for Globex)
getWeeklyAnchorStartsArray(string session, int weeksBack) =>
    var array<int> starts = array.new<int>()
    array.clear(starts)

    string tz = getSessionTimezone(session)

    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    int currentD = dayofmonth(timenow, tz)
    int currentDayOfWeek = dayofweek(timenow, tz)

    // Step 2: Adjust weekend to Friday (same as daily sessions)
    if currentDayOfWeek == dayofweek.saturday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)
    else if currentDayOfWeek == dayofweek.sunday and session != "Globex"
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 172800000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)

    // Step 3: Check if today's session has started
    int todaySessionStart = getSessionStartForDate(session, currentY, currentM, currentD)
    int mostRecentY = currentY
    int mostRecentM = currentM
    int mostRecentD = currentD

    if timenow < todaySessionStart
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        mostRecentY := year(yesterdayMidnight, tz)
        mostRecentM := month(yesterdayMidnight, tz)
        mostRecentD := dayofmonth(yesterdayMidnight, tz)

    // Step 4: Walk backwards collecting only week-start days (Monday or Sunday)
    int targetDayOfWeek = session == "Globex" ? dayofweek.sunday : dayofweek.monday
    int weeksCollected = 0
    int daysBackOffset = 0

    while weeksCollected < weeksBack
        int targetMidnight = timestamp(tz, mostRecentY, mostRecentM, mostRecentD, 0, 0) - (daysBackOffset * 86400000)
        int y = year(targetMidnight, tz)
        int m = month(targetMidnight, tz)
        int d = dayofmonth(targetMidnight, tz)
        int dow = dayofweek(targetMidnight, tz)

        if dow == targetDayOfWeek
            // This is a week-start day - add the session start
            int weekStart = getSessionStartForDate(session, y, m, d)
            array.unshift(starts, weekStart)
            weeksCollected := weeksCollected + 1

        daysBackOffset := daysBackOffset + 1

    starts

// Convert period string to minutes
periodToMinutes(string period) =>
    period == "1m" ? 1 : period == "2m" ? 2 : period == "3m" ? 3 : period == "5m" ? 5 : period == "15m" ? 15 : period == "30m" ? 30 : period == "1h" ? 60 : period == "65m" ? 65 : period == "2h" ? 120 : period == "4h" ? 240 : period == "1D" ? 1440 : 99999

// Get timeframe in minutes for comparison
getTimeframeMinutes() =>
    int tfSeconds = timeframe.in_seconds()
    if tfSeconds >= 86400
        // Daily or larger timeframes return as days
        int days = tfSeconds / 86400
        days * 1440  // Convert days to minutes
    else
        tfSeconds / 60

// Add level to priceLabels map with duplicate detection
addToMap(map<float, string> priceMap, float price, string label) =>
    float key = roundToTick(price)
    string existing = map.contains(priceMap, key) ? map.get(priceMap, key) : ""
    if existing != ""
        map.put(priceMap, key, existing + "/" + label)
    else
        map.put(priceMap, key, label)

// DISPLAY CONDITIONS & ATR FILTERING

float atrValue = request.security(syminfo.tickerid, "D", ta.atr(atrPeriod), lookahead=barmerge.lookahead_on)
float atrThreshold = atrValue * atrMultiplier

bool isFutures = syminfo.type == "futures"

// Check timeframe conditions
int currentTfMinutes = getTimeframeMinutes()
bool meetsMaxTimeframe = keyLevelsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(keyLevelsMaxTimeframe)

// Check if key levels should be shown (max timeframe filter only)
bool showKeyLevelsCondition = showKeyLevels and meetsMaxTimeframe

// Determine primary session name (used for long-term anchor and primary session logic)
string primarySessionName = longTermAnchorSession == "Auto" ? (syminfo.type == "stock" ? "New York" : "Globex") : longTermAnchorSession

// Check timeframe conditions for session features
bool meetsOtherSessionsTimeframe = otherSessionsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(otherSessionsMaxTimeframe)
bool meetsLongTermAnchorSessionTimeframe = longTermAnchorSessionMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(longTermAnchorSessionMaxTimeframe)
bool sessionBaseCondition = showSessionMarkers
bool showSessionMarkersCondition = sessionBaseCondition and meetsOtherSessionsTimeframe

// Individual session VWAP timeframe checks (long-term anchor session gets extended visibility, others are intraday-only)
bool meetsLondonVWAPTimeframe = primarySessionName == "London" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsNYVWAPTimeframe = primarySessionName == "New York" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsGlobexVWAPTimeframe = primarySessionName == "Globex" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsSydneyVWAPTimeframe = primarySessionName == "Sydney" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsTokyoVWAPTimeframe = primarySessionName == "Tokyo" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe

// Check timeframe conditions for session levels and pivot features
bool meetsSessionLevelsMaxTimeframe = sessionLevelsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(sessionLevelsMaxTimeframe)
bool meetsPivotMaxTimeframe = pivotMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(pivotMaxTimeframe)
bool showPivotsCondition = showPivots and meetsPivotMaxTimeframe

// Check timeframe condition for weekly anchors
bool meetsWeeklyAnchorMaxTimeframe = weeklyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(weeklyAnchorMaxTimeframe)

// KEY LEVELS DATA - Conditional requests for performance
var float pdh = na, var float pdl = na
var float pwh = na, var float pwl = na
var float pmh = na, var float pml = na
var float pyh = na, var float pyl = na

// Previous period levels - only update on confirmed bars (static values don't change intrabar)
if barstate.isconfirmed and showKeyLevelsCondition and (showPDH or showPDL or showCDH or showCDL)
    [_pdh, _pdl] = request.security(syminfo.tickerid, "D", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pdh := _pdh, pdl := _pdl
if barstate.isconfirmed and showKeyLevelsCondition and (showPWH or showPWL or showCWH or showCWL)
    [_pwh, _pwl] = request.security(syminfo.tickerid, "W", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pwh := _pwh, pwl := _pwl
if barstate.isconfirmed and showKeyLevelsCondition and (showPMH or showPML or showCMH or showCML)
    [_pmh, _pml] = request.security(syminfo.tickerid, "M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pmh := _pmh, pml := _pml
if barstate.isconfirmed and showKeyLevelsCondition and (showPYH or showPYL or showCYH or showCYL)
    [_pyh, _pyl] = request.security(syminfo.tickerid, "12M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pyh := _pyh, pyl := _pyl

// Current period levels (developing periods)
var float cdh = na, var float cdl = na
var float cwh = na, var float cwl = na
var float cmh = na, var float cml = na
var float cyh = na, var float cyl = na

if showKeyLevelsCondition and (showCDH or showCDL)
    [_cdh, _cdl] = request.security(syminfo.tickerid, "D", [high, low], lookahead=barmerge.lookahead_on)
    cdh := _cdh, cdl := _cdl
if showKeyLevelsCondition and (showCWH or showCWL)
    [_cwh, _cwl] = request.security(syminfo.tickerid, "W", [high, low], lookahead=barmerge.lookahead_on)
    cwh := _cwh, cwl := _cwl
if showKeyLevelsCondition and (showCMH or showCML)
    [_cmh, _cml] = request.security(syminfo.tickerid, "M", [high, low], lookahead=barmerge.lookahead_on)
    cmh := _cmh, cml := _cml
if showKeyLevelsCondition and (showCYH or showCYL)
    [_cyh, _cyl] = request.security(syminfo.tickerid, "12M", [high, low], lookahead=barmerge.lookahead_on)
    cyh := _cyh, cyl := _cyl

var float ath = na
float _ath = ta.highest(high, bar_index + 1)
if barstate.isconfirmed
    ath := showKeyLevelsCondition and showATH ? request.security(syminfo.tickerid, "M", _ath, lookahead=barmerge.lookahead_on) : na

// PIVOT POINTS (from previous day's HLC)
var float dailyHigh = na, var float dailyLow = na, var float dailyClose = na
if barstate.isconfirmed
    [_dailyHigh, _dailyLow, _dailyClose] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    dailyHigh := _dailyHigh
    dailyLow := _dailyLow
    dailyClose := _dailyClose

float dailyRange = dailyHigh - dailyLow
float pivotP = (dailyHigh + dailyLow + dailyClose) / 3
float pivotR1 = 2 * pivotP - dailyLow
float pivotS1 = 2 * pivotP - dailyHigh
float pivotR2 = pivotP + dailyRange
float pivotS2 = pivotP - dailyRange
float pivotR3 = dailyHigh + 2 * (pivotP - dailyLow)
float pivotS3 = dailyLow - 2 * (dailyHigh - pivotP)

var array<LevelRenderer> keyLevels = array.new<LevelRenderer>()
var array<LevelRenderer> pivotLevels = array.new<LevelRenderer>()
var array<LevelRenderer> sessionLevels = array.new<LevelRenderer>()

// MULTI-SESSION INFRASTRUCTURE

const int MAX_VWAP_HISTORY = 10
const int MAX_WEEKLY_HISTORY = 5

var array<bool> sessionEnabled = array.from(enableLondon, enableNewYork, enableGlobex, enableSydney, enableTokyo)
var array<string> sessionNames = array.from("London", "New York", "Globex", "Sydney", "Tokyo")
var array<color> sessionColors = array.from(colorLondon, colorNewYork, colorGlobex, colorSydney, colorTokyo)

var array<int> londonStarts = array.new<int>()
var array<int> nyStarts = array.new<int>()
var array<int> globexStarts = array.new<int>()
var array<int> sydneyStarts = array.new<int>()
var array<int> tokyoStarts = array.new<int>()

var array<int> londonEnds = array.new<int>()
var array<int> nyEnds = array.new<int>()
var array<int> globexEnds = array.new<int>()
var array<int> sydneyEnds = array.new<int>()
var array<int> tokyoEnds = array.new<int>()

if barstate.isfirst
    londonStarts := getSessionStartsArray("London", MAX_VWAP_HISTORY)
    nyStarts := getSessionStartsArray("New York", MAX_VWAP_HISTORY)
    globexStarts := getSessionStartsArray("Globex", MAX_VWAP_HISTORY)
    sydneyStarts := getSessionStartsArray("Sydney", MAX_VWAP_HISTORY)
    tokyoStarts := getSessionStartsArray("Tokyo", MAX_VWAP_HISTORY)

    londonEnds := getSessionEndsArray("London", MAX_VWAP_HISTORY)
    nyEnds := getSessionEndsArray("New York", MAX_VWAP_HISTORY)
    globexEnds := getSessionEndsArray("Globex", MAX_VWAP_HISTORY)
    sydneyEnds := getSessionEndsArray("Sydney", MAX_VWAP_HISTORY)
    tokyoEnds := getSessionEndsArray("Tokyo", MAX_VWAP_HISTORY)

var array<float> londonSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> londonSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> nySumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> nySumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> globexSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> globexSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> sydneySumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> sydneySumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> tokyoSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> tokyoSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)

var array<int> sessionStartBars = array.new<int>(5, na)
var array<int> sessionStartTimes = array.new<int>(5, na)
var array<label> sessionLabels = array.new<label>(5, na)

var array<int> weeklyAnchorStartsArray = array.new<int>(MAX_WEEKLY_HISTORY, na)
var array<float> weeklyAnchorSumSrc = array.new<float>(MAX_WEEKLY_HISTORY, 0.0)
var array<float> weeklyAnchorSumVol = array.new<float>(MAX_WEEKLY_HISTORY, 0.0)
var array<float> weeklyAnchorVWAPs = array.new<float>(MAX_WEEKLY_HISTORY, na)
var array<label> weeklyAnchorLabels = array.new<label>(MAX_WEEKLY_HISTORY, na)
var bool currentSessionIsWeeklyAnchor = false

if barstate.isfirst
    weeklyAnchorStartsArray := getWeeklyAnchorStartsArray(primarySessionName, MAX_WEEKLY_HISTORY)

var int activeSessionIndex = na
var string activeSessionName = na

var float sessionOpen = na
var float openRangeHigh = na
var float openRangeLow = na
var float initialBalanceHigh = na
var float initialBalanceLow = na
var int sessionStartBar = na
var int sessionStartTime = na

var int openPriceBar = na
var int orhBar = na
var int orlBar = na
var int ibhBar = na
var int iblBar = na

int openRangeMinutes = periodToMinutes(openRangePeriod)
int ibMinutes = periodToMinutes(initialBalancePeriod)

// UNIFIED SESSION DETECTION (Calendar-based)

for i = 0 to 4
    if array.get(sessionEnabled, i)
        string sessionName = array.get(sessionNames, i)

        array<int> sessionStartsArray = switch i
            0 => londonStarts
            1 => nyStarts
            2 => globexStarts
            3 => sydneyStarts
            => tokyoStarts
        int mostRecentSessionStart = array.get(sessionStartsArray, MAX_VWAP_HISTORY - 1)

        bool thisSessionChange = time >= mostRecentSessionStart and time[1] < mostRecentSessionStart

        if thisSessionChange
            array.set(sessionStartBars, i, bar_index)
            array.set(sessionStartTimes, i, mostRecentSessionStart)

            activeSessionIndex := i
            activeSessionName := sessionName

            sessionOpen := open
            openRangeHigh := high
            openRangeLow := low
            initialBalanceHigh := high
            initialBalanceLow := low
            sessionStartBar := bar_index
            sessionStartTime := mostRecentSessionStart
            openPriceBar := bar_index
            orhBar := bar_index
            orlBar := bar_index
            ibhBar := bar_index
            iblBar := bar_index

if not na(activeSessionIndex) and not na(sessionOpen) and not na(sessionStartTime)
    array<int> activeSessionEnds = switch activeSessionIndex
        0 => londonEnds
        1 => nyEnds
        2 => globexEnds
        3 => sydneyEnds
        => tokyoEnds
    int currentSessionEnd = array.get(activeSessionEnds, MAX_VWAP_HISTORY - 1)

    bool stillInSession = time >= sessionStartTime and time < currentSessionEnd

    if stillInSession
        int elapsedMinutes = math.round((time - sessionStartTime) / 60000)
        if elapsedMinutes <= openRangeMinutes
            if high > openRangeHigh
                openRangeHigh := high
                orhBar := bar_index
            if low < openRangeLow
                openRangeLow := low
                orlBar := bar_index

        if elapsedMinutes <= ibMinutes
            if high > initialBalanceHigh
                initialBalanceHigh := high
                ibhBar := bar_index
            if low < initialBalanceLow
                initialBalanceLow := low
                iblBar := bar_index

// MULTI-SESSION VWAP CALCULATIONS

var array<float> londonVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> nyVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> globexVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> sydneyVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> tokyoVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)

var array<label> londonLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> nyLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> globexLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> sydneyLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> tokyoLabels = array.new<label>(MAX_VWAP_HISTORY, na)

for i = 0 to 4
    if array.get(sessionEnabled, i)
        // Get configuration for this session type
        int historyCount = i == 0 ? londonVWAPCount : i == 1 ? nyVWAPCount : i == 2 ? globexVWAPCount : i == 3 ? sydneyVWAPCount : tokyoVWAPCount
        array<int> sessionStartsArray = i == 0 ? londonStarts : i == 1 ? nyStarts : i == 2 ? globexStarts : i == 3 ? sydneyStarts : tokyoStarts
        array<float> sumSrcArray = i == 0 ? londonSumSrc : i == 1 ? nySumSrc : i == 2 ? globexSumSrc : i == 3 ? sydneySumSrc : tokyoSumSrc
        array<float> sumVolArray = i == 0 ? londonSumVol : i == 1 ? nySumVol : i == 2 ? globexSumVol : i == 3 ? sydneySumVol : tokyoSumVol
        array<float> vwapArray = i == 0 ? londonVWAPs : i == 1 ? nyVWAPs : i == 2 ? globexVWAPs : i == 3 ? sydneyVWAPs : tokyoVWAPs
        array<label> labelArray = i == 0 ? londonLabels : i == 1 ? nyLabels : i == 2 ? globexLabels : i == 3 ? sydneyLabels : tokyoLabels
        color sessionColor = i == 0 ? colorLondon : i == 1 ? colorNewYork : i == 2 ? colorGlobex : i == 3 ? colorSydney : colorTokyo
        string sessionName = array.get(sessionNames, i)
        bool meetsThisSessionVWAPTimeframe = i == 0 ? meetsLondonVWAPTimeframe : i == 1 ? meetsNYVWAPTimeframe : i == 2 ? meetsGlobexVWAPTimeframe : i == 3 ? meetsSydneyVWAPTimeframe : meetsTokyoVWAPTimeframe

        // Loop through all tracked sessions (MAX_VWAP_HISTORY)
        for arrayIdx = 0 to MAX_VWAP_HISTORY - 1
            int sessionStart = array.get(sessionStartsArray, arrayIdx)

            // Get the next session start (to know when to stop calculating this VWAP)
            int nextSessionStart = arrayIdx < MAX_VWAP_HISTORY - 1 ? array.get(sessionStartsArray, arrayIdx + 1) : int(na)

            // Check if we're at the start of this session
            bool isSessionStart = time >= sessionStart and time[1] < sessionStart

            // Check if this VWAP is within the configured history count
            // Array layout: [0=oldest ... 9=newest] with MAX_VWAP_HISTORY=10
            // If historyCount=1: only arrayIdx=9 is visible (sessionIndexInHistory >= 0)
            // If historyCount=2: arrayIdx=8,9 are visible
            // If historyCount=5: arrayIdx=5,6,7,8,9 are visible
            int sessionIndexInHistory = arrayIdx - (MAX_VWAP_HISTORY - historyCount)
            bool isInConfiguredRange = sessionIndexInHistory >= 0

            // VWAPs should calculate as long as they're in the configured range AND after their session started
            // They continue calculating even after the next session starts (unlike the old logic)
            bool shouldCalculate = time >= sessionStart and isInConfiguredRange

            if shouldCalculate
                // Get current accumulators for this session
                float currentSumSrc = array.get(sumSrcArray, arrayIdx)
                float currentSumVol = array.get(sumVolArray, arrayIdx)

                // Reset accumulators on new session start, otherwise accumulate continuously
                float newSumSrc = isSessionStart ? (ohlc4 * volume) : (currentSumSrc + ohlc4 * volume)
                float newSumVol = isSessionStart ? volume : (currentSumVol + volume)

                // Update accumulators
                array.set(sumSrcArray, arrayIdx, newSumSrc)
                array.set(sumVolArray, arrayIdx, newSumVol)

                // Calculate VWAP and store in array
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(vwapArray, arrayIdx, vwap)

                // Create session label at session start ONLY if within configured history count and timeframe
                if isSessionStart and sessionBaseCondition and meetsThisSessionVWAPTimeframe and showSessionLabels and isInConfiguredRange
                    deleteLabel(labelArray, arrayIdx)
                    int positionInHistory = (MAX_VWAP_HISTORY - 1) - arrayIdx
                    color labelColor = getVWAPColor(sessionColor, positionInHistory, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation)
                    bool isPrimarySession = sessionName == primarySessionName
                    // For Globex, show the trading day (session end day) not the start day
                    int labelTimestamp = sessionName == "Globex" ? sessionStart + 86400000 : sessionStart
                    string sessionLabelText = compactSessionLabels ? (isPrimarySession ? "D" + str.tostring(positionInHistory + 1) : getSessionAbbr(sessionName) + str.tostring(positionInHistory + 1)) : sessionName + " " + str.format_time(labelTimestamp, "d MMM", getSessionTimezone(sessionName))
                    label newLabel = label.new(bar_index, high, sessionLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=labelColor, textcolor=color.white, size=getLabelSize(globalLabelSize), style=label.style_label_down)
                    array.set(labelArray, arrayIdx, newLabel)
                    if arrayIdx == MAX_VWAP_HISTORY - 1
                        array.set(sessionLabels, i, newLabel)

            // Clean up labels that are outside the configured history count
            if not isInConfiguredRange
                deleteLabel(labelArray, arrayIdx)
                array.set(labelArray, arrayIdx, na)

// Plot VWAPs - up to 5 historical sessions per type
bool skipLondonMostRecent = showWeeklyAnchorVWAP and primarySessionName == "London" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondon and londonVWAPCount >= 1 and not skipLondonMostRecent ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 1) : na, "London VWAP 1", color=getVWAPColor(colorLondon, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondon and londonVWAPCount >= 2 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 2) : na, "London VWAP 2", color=getVWAPColor(colorLondon, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondon and londonVWAPCount >= 3 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 3) : na, "London VWAP 3", color=getVWAPColor(colorLondon, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondon and londonVWAPCount >= 4 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 4) : na, "London VWAP 4", color=getVWAPColor(colorLondon, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondon and londonVWAPCount >= 5 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 5) : na, "London VWAP 5", color=getVWAPColor(colorLondon, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipNYMostRecent = showWeeklyAnchorVWAP and primarySessionName == "New York" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYork and nyVWAPCount >= 1 and not skipNYMostRecent ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 1) : na, "NY VWAP 1", color=getVWAPColor(colorNewYork, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYork and nyVWAPCount >= 2 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 2) : na, "NY VWAP 2", color=getVWAPColor(colorNewYork, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYork and nyVWAPCount >= 3 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 3) : na, "NY VWAP 3", color=getVWAPColor(colorNewYork, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYork and nyVWAPCount >= 4 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 4) : na, "NY VWAP 4", color=getVWAPColor(colorNewYork, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYork and nyVWAPCount >= 5 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 5) : na, "NY VWAP 5", color=getVWAPColor(colorNewYork, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipGlobexMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Globex" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobex and globexVWAPCount >= 1 and not skipGlobexMostRecent ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 1) : na, "Globex VWAP 1", color=getVWAPColor(colorGlobex, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobex and globexVWAPCount >= 2 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 2) : na, "Globex VWAP 2", color=getVWAPColor(colorGlobex, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobex and globexVWAPCount >= 3 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 3) : na, "Globex VWAP 3", color=getVWAPColor(colorGlobex, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobex and globexVWAPCount >= 4 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 4) : na, "Globex VWAP 4", color=getVWAPColor(colorGlobex, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobex and globexVWAPCount >= 5 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 5) : na, "Globex VWAP 5", color=getVWAPColor(colorGlobex, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipSydneyMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Sydney" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydney and sydneyVWAPCount >= 1 and not skipSydneyMostRecent ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 1) : na, "Sydney VWAP 1", color=getVWAPColor(colorSydney, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydney and sydneyVWAPCount >= 2 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 2) : na, "Sydney VWAP 2", color=getVWAPColor(colorSydney, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydney and sydneyVWAPCount >= 3 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 3) : na, "Sydney VWAP 3", color=getVWAPColor(colorSydney, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydney and sydneyVWAPCount >= 4 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 4) : na, "Sydney VWAP 4", color=getVWAPColor(colorSydney, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydney and sydneyVWAPCount >= 5 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 5) : na, "Sydney VWAP 5", color=getVWAPColor(colorSydney, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipTokyoMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Tokyo" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 1 and not skipTokyoMostRecent ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 1) : na, "Tokyo VWAP 1", color=getVWAPColor(colorTokyo, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 2 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 2) : na, "Tokyo VWAP 2", color=getVWAPColor(colorTokyo, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 3 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 3) : na, "Tokyo VWAP 3", color=getVWAPColor(colorTokyo, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 4 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 4) : na, "Tokyo VWAP 4", color=getVWAPColor(colorTokyo, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 5 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 5) : na, "Tokyo VWAP 5", color=getVWAPColor(colorTokyo, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEEKLY ANCHOR VWAP CALCULATION (Multi-week support)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Get the session arrays for the anchor session type (for skip logic)
array<int> anchorSessionStarts = switch primarySessionName
    "London" => londonStarts
    "New York" => nyStarts
    "Globex" => globexStarts
    "Sydney" => sydneyStarts
    => tokyoStarts

if showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe
    string anchorTZ = getSessionTimezone(primarySessionName)

    // Process each week in the array
    for weekIdx = 0 to MAX_WEEKLY_HISTORY - 1
        int weekStart = array.get(weeklyAnchorStartsArray, weekIdx)

        if not na(weekStart)
            // Detect when we cross into this week's start
            bool atWeekStart = time >= weekStart and time[1] < weekStart

            if atWeekStart
                // Reset accumulators for this week
                array.set(weeklyAnchorSumSrc, weekIdx, 0.0)
                array.set(weeklyAnchorSumVol, weekIdx, 0.0)

                // Check if this is the most recent week and matches the most recent daily session
                if weekIdx == MAX_WEEKLY_HISTORY - 1
                    currentSessionIsWeeklyAnchor := (weekStart == array.get(anchorSessionStarts, MAX_VWAP_HISTORY - 1))

                // Create label at week start (only if within count)
                bool shouldShowLabel = weekIdx >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
                if showSessionLabels and shouldShowLabel
                    label oldLabel = array.get(weeklyAnchorLabels, weekIdx)
                    if not na(oldLabel)
                        label.delete(oldLabel)
                    int positionInWeeklyHistory = (MAX_WEEKLY_HISTORY - 1) - weekIdx
                    color weeklyLabelColor = getVWAPColor(colorWeeklyAnchor, positionInWeeklyHistory, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation)
                    string weeklyLabelText = compactWeeklyLabels ? "W" + str.tostring(positionInWeeklyHistory + 1) : "Week " + str.tostring(weekofyear(weekStart, anchorTZ)) + " (" + primarySessionName + ")"
                    label newLabel = label.new(bar_index, high, weeklyLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=weeklyLabelColor, textcolor=color.white, size=getLabelSize(globalLabelSize), style=label.style_label_down)
                    array.set(weeklyAnchorLabels, weekIdx, newLabel)

            // Accumulate if we're at or after this week's start
            if time >= weekStart
                float currentSumSrc = array.get(weeklyAnchorSumSrc, weekIdx)
                float currentSumVol = array.get(weeklyAnchorSumVol, weekIdx)
                array.set(weeklyAnchorSumSrc, weekIdx, currentSumSrc + (ohlc4 * volume))
                array.set(weeklyAnchorSumVol, weekIdx, currentSumVol + volume)

                float newSumSrc = array.get(weeklyAnchorSumSrc, weekIdx)
                float newSumVol = array.get(weeklyAnchorSumVol, weekIdx)
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(weeklyAnchorVWAPs, weekIdx, vwap)

// Plot weekly anchor VWAPs (only plot the number specified by count)
// Index 4 = most recent (when MAX=5), Index 3 = 2nd most recent, etc.
bool shouldPlot0 = 0 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot1 = 1 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot2 = 2 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot3 = 3 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot4 = 4 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)

plot(shouldPlot0 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 0) : na, "Weekly Anchor 1", color=getVWAPColor(colorWeeklyAnchor, 4, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot1 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 1) : na, "Weekly Anchor 2", color=getVWAPColor(colorWeeklyAnchor, 3, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot2 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 2) : na, "Weekly Anchor 3", color=getVWAPColor(colorWeeklyAnchor, 2, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot3 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 3) : na, "Weekly Anchor 4", color=getVWAPColor(colorWeeklyAnchor, 1, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot4 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 4) : na, "Weekly Anchor 5", color=getVWAPColor(colorWeeklyAnchor, 0, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION LEVELS RENDERING (for active session only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box boxOpenRange = na
var box boxInitialBalanceUpper = na
var box boxInitialBalanceLower = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEY LEVELS RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Cache bar_index to prevent redundant updates on same bar (improves scrolling performance)
var int lastRenderBarIndex = na

if barstate.islast and (na(lastRenderBarIndex) or bar_index != lastRenderBarIndex)
    lastRenderBarIndex := bar_index

    // Calculate line start position with hard limit to prevent lines getting too long
    int startBar = math.max(0, bar_index - globalLineLengthBars)
    int maxLineDistance = 200  // Safe hard limit: must match max value of globalLineLengthBars input (prevents crashes on high-frequency charts)

    // Determine session line start based on user preference, but reset to configured length if beyond hard limit
    int sessionOpenBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
    int openPriceStartBar = sessionLineStartMode == "Level Established" and not na(openPriceBar) ? (bar_index - openPriceBar > maxLineDistance ? startBar : openPriceBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orhStartBar = sessionLineStartMode == "Level Established" and not na(orhBar) ? (bar_index - orhBar > maxLineDistance ? startBar : orhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orlStartBar = sessionLineStartMode == "Level Established" and not na(orlBar) ? (bar_index - orlBar > maxLineDistance ? startBar : orlBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int ibhStartBar = sessionLineStartMode == "Level Established" and not na(ibhBar) ? (bar_index - ibhBar > maxLineDistance ? startBar : ibhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int iblStartBar = sessionLineStartMode == "Level Established" and not na(iblBar) ? (bar_index - iblBar > maxLineDistance ? startBar : iblBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)

    string labelSizeActual = getLabelSize(globalLabelSize)

    // Round prices for map key consistency
    float athRounded = roundToTick(ath)
    float pyhRounded = roundToTick(pyh)
    float pylRounded = roundToTick(pyl)
    float pmhRounded = roundToTick(pmh)
    float pmlRounded = roundToTick(pml)
    float pwhRounded = roundToTick(pwh)
    float pwlRounded = roundToTick(pwl)
    float pdhRounded = roundToTick(pdh)
    float pdlRounded = roundToTick(pdl)
    float cyhRounded = roundToTick(cyh)
    float cylRounded = roundToTick(cyl)
    float cmhRounded = roundToTick(cmh)
    float cmlRounded = roundToTick(cml)
    float cwhRounded = roundToTick(cwh)
    float cwlRounded = roundToTick(cwl)
    float cdhRounded = roundToTick(cdh)
    float cdlRounded = roundToTick(cdl)

    // Pivot points rounded
    float pivotPRounded = roundToTick(pivotP)
    float pivotR1Rounded = roundToTick(pivotR1)
    float pivotR2Rounded = roundToTick(pivotR2)
    float pivotR3Rounded = roundToTick(pivotR3)
    float pivotS1Rounded = roundToTick(pivotS1)
    float pivotS2Rounded = roundToTick(pivotS2)
    float pivotS3Rounded = roundToTick(pivotS3)

    // Session levels rounded
    float ibhRounded = roundToTick(initialBalanceHigh)
    float iblRounded = roundToTick(initialBalanceLow)
    float orhRounded = roundToTick(openRangeHigh)
    float orlRounded = roundToTick(openRangeLow)
    float openRounded = roundToTick(sessionOpen)

    // Build price->label map (merges duplicates with "/")
    // Priority: Session Levels > Pivot Points > Key Levels
    var map<float, string> priceLabels = map.new<float, string>()
    map.clear(priceLabels)

    // Session levels first (highest priority)
    bool shouldAddSessionToMap = showSessionMarkersCondition and not na(sessionOpen)
    if shouldAddSessionToMap
        if showOpenPrice
            addToMap(priceLabels, sessionOpen, "Open")
        if showOpenRange and not na(openRangeHigh)
            addToMap(priceLabels, openRangeHigh, "ORH")
        if showOpenRange and not na(openRangeLow)
            addToMap(priceLabels, openRangeLow, "ORL")
        if showInitialBalance and not na(initialBalanceHigh)
            addToMap(priceLabels, initialBalanceHigh, "IBH")
        if showInitialBalance and not na(initialBalanceLow)
            addToMap(priceLabels, initialBalanceLow, "IBL")

    // Pivot points second (after session, before key levels)
    if showPivotsCondition
        if showPivotP
            addToMap(priceLabels, pivotP, "P")
        if showPivotR1
            addToMap(priceLabels, pivotR1, "R1")
        if showPivotR2
            addToMap(priceLabels, pivotR2, "R2")
        if showPivotR3
            addToMap(priceLabels, pivotR3, "R3")
        if showPivotS1
            addToMap(priceLabels, pivotS1, "S1")
        if showPivotS2
            addToMap(priceLabels, pivotS2, "S2")
        if showPivotS3
            addToMap(priceLabels, pivotS3, "S3")

    // Key levels (lower priority)
    if showKeyLevelsCondition
        if showATH
            addToMap(priceLabels, ath, "ATH")
        if showPYH
            addToMap(priceLabels, pyh, "PYH")
        if showPYL
            addToMap(priceLabels, pyl, "PYL")
        if showPMH
            addToMap(priceLabels, pmh, "PMH")
        if showPML
            addToMap(priceLabels, pml, "PML")
        if showPWH
            addToMap(priceLabels, pwh, "PWH")
        if showPWL
            addToMap(priceLabels, pwl, "PWL")
        if showPDH
            addToMap(priceLabels, pdh, "PDH")
        if showPDL
            addToMap(priceLabels, pdl, "PDL")
        if showCYH
            addToMap(priceLabels, cyh, "CYH")
        if showCYL
            addToMap(priceLabels, cyl, "CYL")
        if showCMH
            addToMap(priceLabels, cmh, "CMH")
        if showCML
            addToMap(priceLabels, cml, "CML")
        if showCWH
            addToMap(priceLabels, cwh, "CWH")
        if showCWL
            addToMap(priceLabels, cwl, "CWL")
        if showCDH
            addToMap(priceLabels, cdh, "CDH")
        if showCDL
            addToMap(priceLabels, cdl, "CDL")

    var array<float> renderedPrices = array.new<float>()
    array.clear(renderedPrices)

    // Initialize level arrays on first render
    if array.size(sessionLevels) == 0
        array.push(sessionLevels, LevelRenderer.new("Open", showOpenPrice, sessionOpen, openRounded, openPriceStartBar, colorOpenPrice, sessionLevelsLineWidth, sessionLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("ORH", showOpenRange, openRangeHigh, orhRounded, orhStartBar, colorORH, sessionLevelsLineWidth, sessionLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("ORL", showOpenRange, openRangeLow, orlRounded, orlStartBar, colorORL, sessionLevelsLineWidth, sessionLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("IBH", showInitialBalance, initialBalanceHigh, ibhRounded, ibhStartBar, colorIBH, sessionLevelsLineWidth, sessionLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("IBL", showInitialBalance, initialBalanceLow, iblRounded, iblStartBar, colorIBL, sessionLevelsLineWidth, sessionLevelsLineStyle, na, na))

        array.push(pivotLevels, LevelRenderer.new("P", showPivotP, pivotP, pivotPRounded, startBar, pivotColorP, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("R1", showPivotR1, pivotR1, pivotR1Rounded, startBar, pivotColorR1, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("R2", showPivotR2, pivotR2, pivotR2Rounded, startBar, pivotColorR2, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("R3", showPivotR3, pivotR3, pivotR3Rounded, startBar, pivotColorR3, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("S1", showPivotS1, pivotS1, pivotS1Rounded, startBar, pivotColorS1, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("S2", showPivotS2, pivotS2, pivotS2Rounded, startBar, pivotColorS2, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("S3", showPivotS3, pivotS3, pivotS3Rounded, startBar, pivotColorS3, pivotLineWidth, pivotLineStyle, na, na))

        array.push(keyLevels, LevelRenderer.new("ATH", showATH, ath, athRounded, startBar, colorATH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PYH", showPYH, pyh, pyhRounded, startBar, colorPYH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PYL", showPYL, pyl, pylRounded, startBar, colorPYL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PMH", showPMH, pmh, pmhRounded, startBar, colorPMH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PML", showPML, pml, pmlRounded, startBar, colorPML, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PWH", showPWH, pwh, pwhRounded, startBar, colorPWH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PWL", showPWL, pwl, pwlRounded, startBar, colorPWL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PDH", showPDH, pdh, pdhRounded, startBar, colorPDH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PDL", showPDL, pdl, pdlRounded, startBar, colorPDL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CYH", showCYH, cyh, cyhRounded, startBar, colorCYH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CYL", showCYL, cyl, cylRounded, startBar, colorCYL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CMH", showCMH, cmh, cmhRounded, startBar, colorCMH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CML", showCML, cml, cmlRounded, startBar, colorCML, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CWH", showCWH, cwh, cwhRounded, startBar, colorCWH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CWL", showCWL, cwl, cwlRounded, startBar, colorCWL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CDH", showCDH, cdh, cdhRounded, startBar, colorCDH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CDL", showCDL, cdl, cdlRounded, startBar, colorCDL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
    else
        // Update level data each bar
        array.get(sessionLevels, 0).update(showOpenPrice, sessionOpen, openRounded, openPriceStartBar)
        array.get(sessionLevels, 1).update(showOpenRange, openRangeHigh, orhRounded, orhStartBar)
        array.get(sessionLevels, 2).update(showOpenRange, openRangeLow, orlRounded, orlStartBar)
        array.get(sessionLevels, 3).update(showInitialBalance, initialBalanceHigh, ibhRounded, ibhStartBar)
        array.get(sessionLevels, 4).update(showInitialBalance, initialBalanceLow, iblRounded, iblStartBar)

        array.get(pivotLevels, 0).update(showPivotP, pivotP, pivotPRounded, startBar)
        array.get(pivotLevels, 1).update(showPivotR1, pivotR1, pivotR1Rounded, startBar)
        array.get(pivotLevels, 2).update(showPivotR2, pivotR2, pivotR2Rounded, startBar)
        array.get(pivotLevels, 3).update(showPivotR3, pivotR3, pivotR3Rounded, startBar)
        array.get(pivotLevels, 4).update(showPivotS1, pivotS1, pivotS1Rounded, startBar)
        array.get(pivotLevels, 5).update(showPivotS2, pivotS2, pivotS2Rounded, startBar)
        array.get(pivotLevels, 6).update(showPivotS3, pivotS3, pivotS3Rounded, startBar)

        array.get(keyLevels, 0).update(showATH, ath, athRounded, startBar)
        array.get(keyLevels, 1).update(showPYH, pyh, pyhRounded, startBar)
        array.get(keyLevels, 2).update(showPYL, pyl, pylRounded, startBar)
        array.get(keyLevels, 3).update(showPMH, pmh, pmhRounded, startBar)
        array.get(keyLevels, 4).update(showPML, pml, pmlRounded, startBar)
        array.get(keyLevels, 5).update(showPWH, pwh, pwhRounded, startBar)
        array.get(keyLevels, 6).update(showPWL, pwl, pwlRounded, startBar)
        array.get(keyLevels, 7).update(showPDH, pdh, pdhRounded, startBar)
        array.get(keyLevels, 8).update(showPDL, pdl, pdlRounded, startBar)
        array.get(keyLevels, 9).update(showCYH, cyh, cyhRounded, startBar)
        array.get(keyLevels, 10).update(showCYL, cyl, cylRounded, startBar)
        array.get(keyLevels, 11).update(showCMH, cmh, cmhRounded, startBar)
        array.get(keyLevels, 12).update(showCML, cml, cmlRounded, startBar)
        array.get(keyLevels, 13).update(showCWH, cwh, cwhRounded, startBar)
        array.get(keyLevels, 14).update(showCWL, cwl, cwlRounded, startBar)
        array.get(keyLevels, 15).update(showCDH, cdh, cdhRounded, startBar)
        array.get(keyLevels, 16).update(showCDL, cdl, cdlRounded, startBar)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION LEVELS RENDERING (FIRST - highest priority for line style)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    string sessionLineStyleActual = getLineStyle(sessionLevelsLineStyle)
    // Only show session levels if we meet the session levels timeframe filter
    bool shouldShowSessionLevels = sessionBaseCondition and meetsSessionLevelsMaxTimeframe and not na(activeSessionIndex) and not na(sessionOpen)

    // Render session levels using array-based approach
    for level in sessionLevels
        level.render(shouldShowSessionLevels, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)

    // Open Range Background Shading
    if shouldShowSessionLevels and showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        int boxORStartBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
        boxOpenRange := updateBox(boxOpenRange, boxORStartBar, openRangeHigh, bar_index, openRangeLow, colorOpenRangeShade)
    else if not na(boxOpenRange)
        box.delete(boxOpenRange), boxOpenRange := na



    // Initial Balance Background Shading
    if shouldShowSessionLevels and showInitialBalance and shadeInitialBalance and not na(initialBalanceHigh) and not na(initialBalanceLow)
        int boxIBStartBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
        bool splitIBBox = showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        if splitIBBox
            if initialBalanceHigh > openRangeHigh
                boxInitialBalanceUpper := updateBox(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh, bar_index, openRangeHigh, colorInitialBalanceShade)
            else if not na(boxInitialBalanceUpper)
                box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
            if initialBalanceLow < openRangeLow
                boxInitialBalanceLower := updateBox(boxInitialBalanceLower, boxIBStartBar, openRangeLow, bar_index, initialBalanceLow, colorInitialBalanceShade)
            else if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
        else
            boxInitialBalanceUpper := updateBox(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh, bar_index, initialBalanceLow, colorInitialBalanceShade)
            if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
    else
        if not na(boxInitialBalanceUpper)
            box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
        if not na(boxInitialBalanceLower)
            box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PIVOT POINTS RENDERING (SECOND - after session levels, before key levels)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Render pivot levels using array-based approach
    for level in pivotLevels
        level.render(showPivotsCondition, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // KEY LEVELS RENDERING (THIRD - after session levels and pivots)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Render key levels using array-based approach
    for level in keyLevels
        level.render(showKeyLevelsCondition, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)
