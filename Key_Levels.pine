// MIT License
//
// Copyright (c) 2025 User-3090
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//@version=6
indicator("Key Levels", overlay=true, max_lines_count=500, max_boxes_count=100)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸŒ GLOBAL SETTINGS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
globalLabelSize = input.string("Normal", "Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="ğŸŒ Global Settings", tooltip="Label size for all levels")
globalShowPriceValues = input.bool(false, "Show Prices in Labels", group="ğŸŒ Global Settings", tooltip="Show price in labels: 'PDH (4523.50)' vs 'PDH'")
globalLineLengthBars = input.int(50, "Line Length (Bars)", minval=10, maxval=200, group="ğŸŒ Global Settings", tooltip="Bars to extend lines backward from current bar (hard limit for lines: 200)")

useATRFilter = input.bool(true, "Hide Distant Levels", group="ğŸŒ Global Settings", tooltip="Only show levels within specified ATR distance from current price")
atrMultiplier = input.float(1.5, "  Distance (ATR)", minval=1.0, maxval=10.0, step=0.5, group="ğŸŒ Global Settings", tooltip="Hide levels beyond this many ATRs from current price")
atrPeriod = input.int(20, "  ATR Period (Days)", minval=1, maxval=500, group="ğŸŒ Global Settings", tooltip="ATR calculated from daily bars (last N days), regardless of chart timeframe")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ• SESSIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showSessionMarkers = input.bool(true, "Enable Sessions", group="ğŸ• Sessions", tooltip="Master toggle for session tracking and VWAPs")
sessionMarkersMode = input.string("Only Futures", "Instrument Filter", options=["All Instruments", "Only Futures"], group="ğŸ• Sessions", tooltip="All Instruments: Show on all markets | Only Futures: Futures only")
sessionMarkersMaxTimeframe = input.string("30m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ• Sessions", tooltip="Hide session features on timeframes above this")

// Long-term Anchor Session
weeklyAnchorSession = input.string("Auto", "Long-term Anchor Session", options=["Auto", "London", "New York", "Globex", "Sydney", "Tokyo"], group="ğŸ• Sessions", tooltip="Auto=NY for stocks, Globex for futures")
showWeeklyAnchorVWAP = input.bool(true, "Weekly Anchor VWAP", inline="WAVWAP", group="ğŸ• Sessions", tooltip="VWAP anchored to first session of trading week")
colorWeeklyAnchor = input.color(#b51b00, "", inline="WAVWAP", group="ğŸ• Sessions")

enableLondon = input.bool(true, "London", inline="LON", group="ğŸ• Sessions")
colorLondon = input.color(#FF9800, "", inline="LON", group="ğŸ• Sessions")
londonVWAPCount = input.int(1, "Count", inline="LON", minval=1, maxval=5, group="ğŸ• Sessions", tooltip="Number of sessions to show (1=current only, 2=current+previous)")

enableNewYork = input.bool(true, "New York", inline="NY", group="ğŸ• Sessions")
colorNewYork = input.color(#2962FF, "", inline="NY", group="ğŸ• Sessions")
nyVWAPCount = input.int(2, "Count", inline="NY", minval=1, maxval=5, group="ğŸ• Sessions", tooltip="Number of sessions to show (1=current only, 2=current+previous)")

enableGlobex = input.bool(true, "Globex", inline="GLX", group="ğŸ• Sessions")
colorGlobex = input.color(#4CAF50, "", inline="GLX", group="ğŸ• Sessions")
globexVWAPCount = input.int(4, "Count", inline="GLX", minval=1, maxval=5, group="ğŸ• Sessions", tooltip="Number of sessions to show (1=current only, 2=current+previous)")

enableSydney = input.bool(false, "Sydney", inline="SYD", group="ğŸ• Sessions")
colorSydney = input.color(#9C27B0, "", inline="SYD", group="ğŸ• Sessions")
sydneyVWAPCount = input.int(1, "Count", inline="SYD", minval=1, maxval=5, group="ğŸ• Sessions", tooltip="Number of sessions to show (1=current only, 2=current+previous)")

enableTokyo = input.bool(false, "Tokyo", inline="TKY", group="ğŸ• Sessions")
colorTokyo = input.color(#E91E63, "", inline="TKY", group="ğŸ• Sessions")
tokyoVWAPCount = input.int(1, "Count", inline="TKY", minval=1, maxval=5, group="ğŸ• Sessions", tooltip="Number of sessions to show (1=current only, 2=current+previous)")

showSessionLabels = input.bool(true, "Show Session Labels", group="ğŸ• Sessions", tooltip="Show session start labels with date")

showSessionVWAP = input.bool(true, "Show Session VWAPs", group="ğŸ• Sessions", tooltip="Display volume-weighted average price per session")
sessionVWAPLineWidth = input.int(2, "VWAP Line Width", minval=1, maxval=5, group="ğŸ• Sessions", tooltip="Thickness of VWAP lines")
sessionVWAPLineStyleInput = input.string("Dotted", "VWAP Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ• Sessions", tooltip="VWAP line appearance")
sessionVWAPLineStyle = sessionVWAPLineStyleInput == "Solid" ? plot.linestyle_solid : sessionVWAPLineStyleInput == "Dashed" ? plot.linestyle_dashed : plot.linestyle_dotted

vwapColorDifferentiation = input.bool(true, "Fade Older Sessions", group="ğŸ• Sessions", tooltip="Make older sessions visually distinct")
vwapMaxTransparency = input.int(0, "Transparency", minval=0, maxval=95, group="ğŸ• Sessions", tooltip="Transparency for oldest session (0=opaque)")
vwapHueShift = input.int(-17, "Hue Shift", minval=-50, maxval=50, group="ğŸ• Sessions", tooltip="Color shift for older sessions (-=cooler, +=warmer)")
vwapDesaturation = input.int(0, "Desaturation", minval=0, maxval=100, group="ğŸ• Sessions", tooltip="Reduce color vibrancy (0=vibrant, 100=gray)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ INTRADAY LEVELS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showIntradayLevels = input.bool(true, "Enable Intraday Levels", group="ğŸ“ Intraday Levels", tooltip="Master toggle for Open/OR/IB levels")
intradayLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ“ Intraday Levels", tooltip="Width for Open/ORH/ORL/IBH/IBL lines")
intradayLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“ Intraday Levels")
intradayLineStartMode = input.string("Level Established", "Line Start", options=["Level Established", "Session Open", "Fixed Bars Back"], group="ğŸ“ Intraday Levels", tooltip="Level Established: From where level was created\nSession Open: From session start\nFixed Bars Back: Use global line length")

showOpenPrice = input.bool(true, "Show Open", inline="OP", group="ğŸ“ Intraday Levels")
colorOpenPrice = input.color(#fbbe30, "", inline="OP", group="ğŸ“ Intraday Levels", tooltip="First price at session open")

showOpenRange = input.bool(true, "Show Open Range", group="ğŸ“ Intraday Levels", tooltip="High/Low of first 15m-30m (early volatility)")
openRangePeriod = input.string("30m", "OR Period", options=["15m", "30m"], group="ğŸ“ Intraday Levels")
colorORH = input.color(#4682b4, "ORH", inline="OR", group="ğŸ“ Intraday Levels")
colorORL = input.color(#cd5c5c, "ORL", inline="OR", group="ğŸ“ Intraday Levels")
shadeOpenRange = input.bool(true, "Shade OR", group="ğŸ“ Intraday Levels")
colorOpenRangeShade = input.color(color.new(color.red, 98), "OR Shade", group="ğŸ“ Intraday Levels", tooltip="Fill between ORH/ORL")

showInitialBalance = input.bool(false, "Show Initial Balance", group="ğŸ“ Intraday Levels", tooltip="High/Low of first 30m-1h (institutional reference)")
initialBalancePeriod = input.string("1h", "IB Period", options=["30m", "1h"], group="ğŸ“ Intraday Levels")
colorIBH = input.color(#81ce6f, "IBH", inline="IB", group="ğŸ“ Intraday Levels")
colorIBL = input.color(#e43b38, "IBL", inline="IB", group="ğŸ“ Intraday Levels")
shadeInitialBalance = input.bool(true, "Shade IB", group="ğŸ“ Intraday Levels")
colorInitialBalanceShade = input.color(color.new(color.green, 98), "IB Shade", group="ğŸ“ Intraday Levels", tooltip="Fill between IBH/IBL")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ”„ PIVOT POINTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showPivots = input.bool(true, "Enable Pivot Points", group="ğŸ”„ Pivot Points", tooltip="Traditional pivots from previous day H/L/C")
pivotMaxTimeframe = input.string("4h", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ”„ Pivot Points", tooltip="Hide on timeframes above this")
pivotLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ”„ Pivot Points")
pivotLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ”„ Pivot Points")

showPivotP = input.bool(false, "P", inline="pivotP", group="ğŸ”„ Pivot Points")
pivotColorP = input.color(#808080, "", inline="pivotP", group="ğŸ”„ Pivot Points", tooltip="Central pivot: (H+L+C)/3")

showPivotR1 = input.bool(false, "R1", inline="pivotR", group="ğŸ”„ Pivot Points")
pivotColorR1 = input.color(#449955, "", inline="pivotR", group="ğŸ”„ Pivot Points")
showPivotR2 = input.bool(true, "R2", inline="pivotR", group="ğŸ”„ Pivot Points")
pivotColorR2 = input.color(#449955, "", inline="pivotR", group="ğŸ”„ Pivot Points")
showPivotR3 = input.bool(true, "R3", inline="pivotR", group="ğŸ”„ Pivot Points")
pivotColorR3 = input.color(#81ce6f, "", inline="pivotR", group="ğŸ”„ Pivot Points")

showPivotS1 = input.bool(false, "S1", inline="pivotS", group="ğŸ”„ Pivot Points")
pivotColorS1 = input.color(#b51b00, "", inline="pivotS", group="ğŸ”„ Pivot Points")
showPivotS2 = input.bool(true, "S2", inline="pivotS", group="ğŸ”„ Pivot Points")
pivotColorS2 = input.color(#b51b00, "", inline="pivotS", group="ğŸ”„ Pivot Points")
showPivotS3 = input.bool(true, "S3", inline="pivotS", group="ğŸ”„ Pivot Points")
pivotColorS3 = input.color(#d37666, "", inline="pivotS", group="ğŸ”„ Pivot Points")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ˆ KEY LEVELS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showKeyLevels = input.bool(true, "Enable Key Levels", group="ğŸ“ˆ Key Levels", tooltip="Master toggle for ATH/Year/Month/Week/Day levels")
keyLevelsMode = input.string("Only Futures", "Instrument Filter", options=["All Instruments", "Only Futures"], group="ğŸ“ˆ Key Levels", tooltip="Show on all markets or futures only")
keyLevelsMaxTimeframe = input.string("30m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ“ˆ Key Levels", tooltip="Hide on larger timeframes")
keyLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ“ˆ Key Levels")
keyLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“ˆ Key Levels")

showATH = input.bool(true, "Show ATH", inline="ATH", group="ğŸ“ˆ Key Levels")
colorATH = input.color(#00fcff, "", inline="ATH", group="ğŸ“ˆ Key Levels", tooltip="All-time high")

showPYH = input.bool(true, "Previous YH", inline="PY", group="ğŸ“ˆ Key Levels")
colorPYH = input.color(#1e6b28, "", inline="PY", group="ğŸ“ˆ Key Levels")
showPYL = input.bool(true, "YL", inline="PY", group="ğŸ“ˆ Key Levels")
colorPYL = input.color(#6b0f00, "", inline="PY", group="ğŸ“ˆ Key Levels", tooltip="Previous year high/low")

showCYH = input.bool(true, "Current YH", inline="CY", group="ğŸ“ˆ Key Levels")
colorCYH = input.color(#3a8540, "", inline="CY", group="ğŸ“ˆ Key Levels")
showCYL = input.bool(true, "YL", inline="CY", group="ğŸ“ˆ Key Levels")
colorCYL = input.color(#851a00, "", inline="CY", group="ğŸ“ˆ Key Levels", tooltip="Current year high/low")

showPMH = input.bool(true, "Previous MH", inline="PM", group="ğŸ“ˆ Key Levels")
colorPMH = input.color(#2e8b3a, "", inline="PM", group="ğŸ“ˆ Key Levels")
showPML = input.bool(true, "ML", inline="PM", group="ğŸ“ˆ Key Levels")
colorPML = input.color(#8b1500, "", inline="PM", group="ğŸ“ˆ Key Levels", tooltip="Previous month high/low")

showCMH = input.bool(true, "Current MH", inline="CM", group="ğŸ“ˆ Key Levels")
colorCMH = input.color(#50a555, "", inline="CM", group="ğŸ“ˆ Key Levels")
showCML = input.bool(true, "ML", inline="CM", group="ğŸ“ˆ Key Levels")
colorCML = input.color(#a83020, "", inline="CM", group="ğŸ“ˆ Key Levels", tooltip="Current month high/low")

showPWH = input.bool(true, "Previous WH", inline="PW", group="ğŸ“ˆ Key Levels")
colorPWH = input.color(#449955, "", inline="PW", group="ğŸ“ˆ Key Levels")
showPWL = input.bool(true, "WL", inline="PW", group="ğŸ“ˆ Key Levels")
colorPWL = input.color(#b51b00, "", inline="PW", group="ğŸ“ˆ Key Levels", tooltip="Previous week high/low")

showCWH = input.bool(true, "Current WH", inline="CW", group="ğŸ“ˆ Key Levels")
colorCWH = input.color(#6bb370, "", inline="CW", group="ğŸ“ˆ Key Levels")
showCWL = input.bool(true, "WL", inline="CW", group="ğŸ“ˆ Key Levels")
colorCWL = input.color(#d84530, "", inline="CW", group="ğŸ“ˆ Key Levels", tooltip="Current week high/low")

showPDH = input.bool(true, "Previous DH", inline="PD", group="ğŸ“ˆ Key Levels")
colorPDH = input.color(#81ce6f, "", inline="PD", group="ğŸ“ˆ Key Levels")
showPDL = input.bool(true, "DL", inline="PD", group="ğŸ“ˆ Key Levels")
colorPDL = input.color(#d37666, "", inline="PD", group="ğŸ“ˆ Key Levels", tooltip="Previous day high/low")

showCDH = input.bool(true, "Current DH", inline="CD", group="ğŸ“ˆ Key Levels")
colorCDH = input.color(#a8e6a1, "", inline="CD", group="ğŸ“ˆ Key Levels")
showCDL = input.bool(true, "DL", inline="CD", group="ğŸ“ˆ Key Levels")
colorCDL = input.color(#e8a090, "", inline="CD", group="ğŸ“ˆ Key Levels", tooltip="Current day high/low")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

getLabelSize(string sizeStr) =>
    sizeStr == "Tiny" ? size.tiny : sizeStr == "Small" ? size.small : sizeStr == "Large" ? size.large : sizeStr == "Huge" ? size.huge : size.normal

getLineStyle(string styleStr) =>
    styleStr == "Solid" ? line.style_solid : styleStr == "Dashed" ? line.style_dashed : line.style_dotted

labelBgColor(color c) => color.new(c, 100)

// Round price to mintick precision for consistent map keys
roundToTick(float price) =>
    syminfo.mintick > 0 ? math.round(price / syminfo.mintick) * syminfo.mintick : price

// RGB to HSL conversion
rgbToHsl(float r, float g, float b) =>
    float rNorm = r / 255.0
    float gNorm = g / 255.0
    float bNorm = b / 255.0

    float maxVal = math.max(rNorm, math.max(gNorm, bNorm))
    float minVal = math.min(rNorm, math.min(gNorm, bNorm))
    float delta = maxVal - minVal

    float h = 0.0
    float s = 0.0
    float l = (maxVal + minVal) / 2.0

    if delta != 0
        s := l > 0.5 ? delta / (2.0 - maxVal - minVal) : delta / (maxVal + minVal)

        if maxVal == rNorm
            h := ((gNorm - bNorm) / delta + (gNorm < bNorm ? 6.0 : 0.0)) / 6.0
        else if maxVal == gNorm
            h := ((bNorm - rNorm) / delta + 2.0) / 6.0
        else
            h := ((rNorm - gNorm) / delta + 4.0) / 6.0

    [h, s, l]

// HSL to RGB conversion helper
hueToRgb(float p, float q, float t) =>
    float tAdj = t < 0.0 ? t + 1.0 : (t > 1.0 ? t - 1.0 : t)
    float result = tAdj < 1.0/6.0 ? p + (q - p) * 6.0 * tAdj :
                  (tAdj < 1.0/2.0 ? q :
                  (tAdj < 2.0/3.0 ? p + (q - p) * (2.0/3.0 - tAdj) * 6.0 : p))
    result

// HSL to RGB conversion
hslToRgb(float h, float s, float l) =>
    float r = 0.0
    float g = 0.0
    float b = 0.0

    if s == 0
        r := l
        g := l
        b := l
    else
        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s
        float p = 2.0 * l - q

        r := hueToRgb(p, q, h + 1.0/3.0)
        g := hueToRgb(p, q, h)
        b := hueToRgb(p, q, h - 1.0/3.0)

    [int(r * 255.0), int(g * 255.0), int(b * 255.0)]

// Calculate color with transparency, hue shift, and desaturation based on VWAP position in history (0 = most recent)
getVWAPColor(color baseColor, int positionInHistory, bool useDifferentiation, int maxTransp, int hueShift, int desat) =>
    if not useDifferentiation or positionInHistory == 0
        baseColor
    else
        // Linear gradient for transparency
        float normalizedPos = positionInHistory / 4.0  // Normalize to 0-1 range (assuming max 5 visible)
        int transparency = int(normalizedPos * maxTransp)

        // Extract RGB components
        float origR = color.r(baseColor)
        float origG = color.g(baseColor)
        float origB = color.b(baseColor)

        // Convert to HSL for proper hue rotation
        [h, s, l] = rgbToHsl(origR, origG, origB)

        // Apply hue shift (rotate around color wheel)
        if hueShift != 0
            float hueShiftAmount = (normalizedPos * hueShift) / 50.0  // -1.0 to +1.0 range
            h := h + hueShiftAmount
            h := h < 0.0 ? h + 1.0 : (h > 1.0 ? h - 1.0 : h)  // Wrap around

        // Apply desaturation
        if desat > 0
            float desatFactor = (normalizedPos * desat) / 100.0
            s := s * (1.0 - desatFactor)

        // Convert back to RGB
        [newR, newG, newB] = hslToRgb(h, s, l)

        // Apply transparency
        color.rgb(newR, newG, newB, math.min(transparency, maxTransp))

// Session time definitions in session's local timezone
// LSE: 8:00 AM - 4:30 PM GMT
// NYSE/CME: 9:30 AM - 4:00 PM EST
// CME Globex: 6:00 PM - 5:00 PM ET (next day, spans 2 calendar days)
// ASX: 10:00 AM - 4:00 PM AEDT
// TSE: 9:00 AM - 3:00 PM JST

getSessionTimezone(string session) =>
    session == "London" ? "Europe/London" : session == "New York" ? "America/New_York" : session == "Globex" ? "America/New_York" : session == "Sydney" ? "Australia/Sydney" : "Asia/Tokyo"

getSessionStartHour(string session) =>
    session == "London" ? 8 : session == "New York" ? 9 : session == "Globex" ? 18 : session == "Sydney" ? 10 : 9

getSessionStartMinute(string session) =>
    session == "New York" ? 30 : 0

getSessionEndHour(string session) =>
    session == "London" ? 16 : session == "New York" ? 16 : session == "Globex" ? 17 : session == "Sydney" ? 16 : 15

getSessionEndMinute(string session) =>
    session == "London" ? 30 : 0

// Calculate session start timestamp for a specific date (calendar-based, pre-calculated)
getSessionStartForDate(string session, int y, int m, int d) =>
    string tz = getSessionTimezone(session)
    int sessionHour = getSessionStartHour(session)
    int sessionMinute = getSessionStartMinute(session)
    timestamp(tz, y, m, d, sessionHour, sessionMinute)

// Calculate session end timestamp for a specific date
// Note: For Globex, end is on NEXT calendar day (starts 6 PM, ends 5 PM next day)
getSessionEndForDate(string session, int y, int m, int d) =>
    string tz = getSessionTimezone(session)
    int sessionHour = getSessionEndHour(session)
    int sessionMinute = getSessionEndMinute(session)
    // Globex spans two days: starts evening, ends next afternoon
    if session == "Globex"
        // Add 24 hours in milliseconds to base timestamp instead of incrementing day
        int baseTimestamp = timestamp(tz, y, m, d, sessionHour, sessionMinute)
        baseTimestamp + 86400000  // Add 1 day in milliseconds
    else
        timestamp(tz, y, m, d, sessionHour, sessionMinute)

// Get array of session start timestamps for last N days (calendar-based pre-calculation)
// For Globex: Returns sessions that are ACTIVE during each day (started previous evening)
getSessionStartsArray(string session, int daysBack) =>
    var array<int> starts = array.new<int>()
    array.clear(starts)

    // Get session timezone to ensure date calculations are consistent
    string tz = getSessionTimezone(session)

    // FINAL ROBUST SOLUTION: Find most recent started session, then walk backwards
    // This works for ANY user timezone and ANY exchange timezone

    // Step 1: Get current date in exchange timezone
    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    int currentD = dayofmonth(timenow, tz)
    int currentDayOfWeek = dayofweek(timenow, tz)

    // Step 2: Skip weekends - if it's Saturday or Sunday, use Friday as reference
    // Saturday = 7, Sunday = 1 in Pine Script
    if currentDayOfWeek == dayofweek.saturday
        // Go back 1 day to Friday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)
    else if currentDayOfWeek == dayofweek.sunday
        // Go back 2 days to Friday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 172800000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)

    // Step 3: Calculate today's (or Friday's if weekend) session start time
    int todaySessionStart = na
    int todaySessionEnd = na
    if session == "Globex"
        // Globex session active during day D starts evening of day D-1
        todaySessionStart := getSessionStartForDate(session, currentY, currentM, currentD - 1)
        todaySessionEnd := getSessionEndForDate(session, currentY, currentM, currentD - 1)
    else
        todaySessionStart := getSessionStartForDate(session, currentY, currentM, currentD)
        todaySessionEnd := getSessionEndForDate(session, currentY, currentM, currentD)

    // Step 4: Check if today's session has started yet
    // If not, we need to start from yesterday's session
    int mostRecentY = currentY
    int mostRecentM = currentM
    int mostRecentD = currentD

    if timenow < todaySessionStart
        // Today's session hasn't started yet, use yesterday as most recent
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        mostRecentY := year(yesterdayMidnight, tz)
        mostRecentM := month(yesterdayMidnight, tz)
        mostRecentD := dayofmonth(yesterdayMidnight, tz)
    // else: today's session is active or we're between sessions - use currentD as reference

    // Step 5: Walk backwards N TRADING days from most recent started session
    // Fill array from oldest to newest, so most recent is at highest index
    // Skip weekends to ensure we only get actual trading sessions
    int tradingSessions = 0
    int calendarDaysBack = 0

    while tradingSessions < daysBack
        int targetMidnight = timestamp(tz, mostRecentY, mostRecentM, mostRecentD, 0, 0) - (calendarDaysBack * 86400000)
        int y = year(targetMidnight, tz)
        int m = month(targetMidnight, tz)
        int d = dayofmonth(targetMidnight, tz)
        int dow = dayofweek(targetMidnight, tz)

        // Check if this is a trading day
        bool isWeekend = dow == dayofweek.saturday or dow == dayofweek.sunday
        bool isTradingDay = not isWeekend

        // Special case: Globex trades Sunday evening (session starts Sunday 6 PM)
        if session == "Globex" and dow == dayofweek.sunday
            isTradingDay := true

        if isTradingDay
            // This is a trading day, add the session
            int sessionStart = na
            if session == "Globex"
                sessionStart := getSessionStartForDate(session, y, m, d - 1)
            else
                sessionStart := getSessionStartForDate(session, y, m, d)

            array.unshift(starts, sessionStart)
            tradingSessions := tradingSessions + 1

        calendarDaysBack := calendarDaysBack + 1

    starts

// Get array of session end timestamps (matches start array indices)
getSessionEndsArray(string session, int daysBack) =>
    var array<int> ends = array.new<int>()
    array.clear(ends)

    string tz = getSessionTimezone(session)

    // FINAL ROBUST SOLUTION: Find most recent started session, then walk backwards
    // This works for ANY user timezone and ANY exchange timezone

    // Step 1: Get current date in exchange timezone
    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    int currentD = dayofmonth(timenow, tz)
    int currentDayOfWeek = dayofweek(timenow, tz)

    // Step 2: Skip weekends - if it's Saturday or Sunday, use Friday as reference
    // Saturday = 7, Sunday = 1 in Pine Script
    if currentDayOfWeek == dayofweek.saturday
        // Go back 1 day to Friday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)
    else if currentDayOfWeek == dayofweek.sunday
        // Go back 2 days to Friday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 172800000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)

    // Step 3: Calculate today's (or Friday's if weekend) session start time
    int todaySessionStart = na
    int todaySessionEnd = na
    if session == "Globex"
        // Globex session active during day D starts evening of day D-1
        todaySessionStart := getSessionStartForDate(session, currentY, currentM, currentD - 1)
        todaySessionEnd := getSessionEndForDate(session, currentY, currentM, currentD - 1)
    else
        todaySessionStart := getSessionStartForDate(session, currentY, currentM, currentD)
        todaySessionEnd := getSessionEndForDate(session, currentY, currentM, currentD)

    // Step 4: Check if today's session has started yet
    // If not, we need to start from yesterday's session
    int mostRecentY = currentY
    int mostRecentM = currentM
    int mostRecentD = currentD

    if timenow < todaySessionStart
        // Today's session hasn't started yet, use yesterday as most recent
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        mostRecentY := year(yesterdayMidnight, tz)
        mostRecentM := month(yesterdayMidnight, tz)
        mostRecentD := dayofmonth(yesterdayMidnight, tz)
    // else: today's session is active or we're between sessions - use currentD as reference

    // Step 5: Walk backwards N TRADING days from most recent started session
    // Fill array from oldest to newest, so most recent is at highest index
    // Skip weekends to ensure we only get actual trading sessions
    int tradingSessions = 0
    int calendarDaysBack = 0

    while tradingSessions < daysBack
        int targetMidnight = timestamp(tz, mostRecentY, mostRecentM, mostRecentD, 0, 0) - (calendarDaysBack * 86400000)
        int y = year(targetMidnight, tz)
        int m = month(targetMidnight, tz)
        int d = dayofmonth(targetMidnight, tz)
        int dow = dayofweek(targetMidnight, tz)

        // Check if this is a trading day
        bool isWeekend = dow == dayofweek.saturday or dow == dayofweek.sunday
        bool isTradingDay = not isWeekend

        // Special case: Globex trades Sunday evening (session starts Sunday 6 PM)
        if session == "Globex" and dow == dayofweek.sunday
            isTradingDay := true

        if isTradingDay
            // This is a trading day, add the session
            int sessionEnd = na
            if session == "Globex"
                sessionEnd := getSessionEndForDate(session, y, m, d - 1)
            else
                sessionEnd := getSessionEndForDate(session, y, m, d)

            array.unshift(ends, sessionEnd)
            tradingSessions := tradingSessions + 1

        calendarDaysBack := calendarDaysBack + 1

    ends

// Convert period string to minutes
periodToMinutes(string period) =>
    period == "1m" ? 1 : period == "2m" ? 2 : period == "3m" ? 3 : period == "5m" ? 5 : period == "15m" ? 15 : period == "30m" ? 30 : period == "1h" ? 60 : period == "65m" ? 65 : period == "2h" ? 120 : period == "4h" ? 240 : 99999

// Get timeframe in minutes for comparison
getTimeframeMinutes() =>
    int localTfSeconds = timeframe.in_seconds()
    int tfMinutes = localTfSeconds / 60
    tfMinutes

// Add level to priceLabels map with duplicate detection
addToMap(map<float, string> priceMap, float price, string label) =>
    float key = roundToTick(price)
    string existing = map.contains(priceMap, key) ? map.get(priceMap, key) : ""
    if existing != ""
        map.put(priceMap, key, existing + "/" + label)
    else
        map.put(priceMap, key, label)

// Check if level price is within ATR distance from current price
isWithinATR(float levelPrice, float currentPrice, float threshold, bool filterEnabled) =>
    not filterEnabled or na(levelPrice) or math.abs(levelPrice - currentPrice) <= threshold

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DISPLAY CONDITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ATR CALCULATION (for distance filtering)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Use daily ATR calculated from last N daily bars (no offset needed for smoothed ATR indicator)
float atrValue = request.security(syminfo.tickerid, "D", ta.atr(atrPeriod), lookahead=barmerge.lookahead_off)
float atrThreshold = atrValue * atrMultiplier

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DISPLAY CONDITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check instrument type
bool isFutures = syminfo.type == "futures"

// Check timeframe conditions
int currentTfMinutes = getTimeframeMinutes()
int maxTfMinutes = periodToMinutes(keyLevelsMaxTimeframe)
bool meetsMaxTimeframe = keyLevelsMaxTimeframe == "None" or currentTfMinutes <= maxTfMinutes

// Check if key levels should be shown (futures filter + max timeframe filter)
bool showKeyLevelsCondition = showKeyLevels and (keyLevelsMode == "All Instruments" or (keyLevelsMode == "Only Futures" and isFutures)) and meetsMaxTimeframe

// Check if session levels should be shown (independent of key levels timeframe filter)
int sessionMaxTfMinutes = periodToMinutes(sessionMarkersMaxTimeframe)
bool meetsSessionMaxTimeframe = sessionMarkersMaxTimeframe == "None" or currentTfMinutes <= sessionMaxTfMinutes
bool showSessionMarkersCondition = showSessionMarkers and (sessionMarkersMode == "All Instruments" or (sessionMarkersMode == "Only Futures" and isFutures)) and meetsSessionMaxTimeframe

// Check if pivot points should be shown (timeframe filter only)
int pivotMaxTfMinutes = periodToMinutes(pivotMaxTimeframe)
bool meetsPivotMaxTimeframe = pivotMaxTimeframe == "None" or currentTfMinutes <= pivotMaxTfMinutes
bool showPivotsCondition = showPivots and meetsPivotMaxTimeframe

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEY LEVELS DATA - Works on any timeframe (10s to monthly)
// Conditional requests for performance (only fetch enabled levels)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Previous period levels (completed periods)
var float pdh = na, var float pdl = na
var float pwh = na, var float pwl = na
var float pmh = na, var float pml = na
var float pyh = na, var float pyl = na

// Previous period levels - only update on confirmed bars (static values don't change intrabar)
if barstate.isconfirmed and showKeyLevelsCondition and (showPDH or showPDL or showCDH or showCDL)
    [_pdh, _pdl] = request.security(syminfo.tickerid, "D", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pdh := _pdh, pdl := _pdl
if barstate.isconfirmed and showKeyLevelsCondition and (showPWH or showPWL or showCWH or showCWL)
    [_pwh, _pwl] = request.security(syminfo.tickerid, "W", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pwh := _pwh, pwl := _pwl
if barstate.isconfirmed and showKeyLevelsCondition and (showPMH or showPML or showCMH or showCML)
    [_pmh, _pml] = request.security(syminfo.tickerid, "M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pmh := _pmh, pml := _pml
if barstate.isconfirmed and showKeyLevelsCondition and (showPYH or showPYL or showCYH or showCYL)
    [_pyh, _pyl] = request.security(syminfo.tickerid, "12M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pyh := _pyh, pyl := _pyl

// Current period levels (developing periods)
var float cdh = na, var float cdl = na
var float cwh = na, var float cwl = na
var float cmh = na, var float cml = na
var float cyh = na, var float cyl = na

// Current period levels - use request.security() for consistency with previous periods
// All use exchange's official daily/weekly/monthly bars for consistency
if showKeyLevelsCondition and (showCDH or showCDL)
    [_cdh, _cdl] = request.security(syminfo.tickerid, "D", [high, low], lookahead=barmerge.lookahead_on)
    cdh := _cdh, cdl := _cdl
if showKeyLevelsCondition and (showCWH or showCWL)
    [_cwh, _cwl] = request.security(syminfo.tickerid, "W", [high, low], lookahead=barmerge.lookahead_on)
    cwh := _cwh, cwl := _cwl
if showKeyLevelsCondition and (showCMH or showCML)
    [_cmh, _cml] = request.security(syminfo.tickerid, "M", [high, low], lookahead=barmerge.lookahead_on)
    cmh := _cmh, cml := _cml
if showKeyLevelsCondition and (showCYH or showCYL)
    [_cyh, _cyl] = request.security(syminfo.tickerid, "12M", [high, low], lookahead=barmerge.lookahead_on)
    cyh := _cyh, cyl := _cyl

// All-time high (uses monthly for better performance) - only update on confirmed bars
var float ath = na
float _ath = ta.highest(high, bar_index + 1)
if barstate.isconfirmed
    ath := showKeyLevelsCondition and showATH ? request.security(syminfo.tickerid, "M", _ath, lookahead=barmerge.lookahead_on) : na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PIVOT POINTS CALCULATIONS (from previous day's HLC)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Fetch previous day's high, low, close for pivot calculations - only update on confirmed bars
var float dailyHigh = na, var float dailyLow = na, var float dailyClose = na
if barstate.isconfirmed
    [_dailyHigh, _dailyLow, _dailyClose] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    dailyHigh := _dailyHigh
    dailyLow := _dailyLow
    dailyClose := _dailyClose

// Traditional pivot point calculations
float dailyRange = dailyHigh - dailyLow
float pivotP = (dailyHigh + dailyLow + dailyClose) / 3
float pivotR1 = 2 * pivotP - dailyLow
float pivotS1 = 2 * pivotP - dailyHigh
float pivotR2 = pivotP + dailyRange
float pivotS2 = pivotP - dailyRange
float pivotR3 = dailyHigh + 2 * (pivotP - dailyLow)
float pivotS3 = dailyLow - 2 * (dailyHigh - pivotP)

var line linePDH = na, var line linePDL = na, var label labelPDH = na, var label labelPDL = na
var line linePWH = na, var line linePWL = na, var label labelPWH = na, var label labelPWL = na
var line linePMH = na, var line linePML = na, var label labelPMH = na, var label labelPML = na
var line linePYH = na, var line linePYL = na, var label labelPYH = na, var label labelPYL = na
var line lineATH = na, var label labelATH = na
var line lineCDH = na, var line lineCDL = na, var label labelCDH = na, var label labelCDL = na
var line lineCWH = na, var line lineCWL = na, var label labelCWH = na, var label labelCWL = na
var line lineCMH = na, var line lineCML = na, var label labelCMH = na, var label labelCML = na
var line lineCYH = na, var line lineCYL = na, var label labelCYH = na, var label labelCYL = na

// Pivot point line and label variables
var line lineP = na, var label labelP = na
var line lineR1 = na, var label labelR1 = na
var line lineR2 = na, var label labelR2 = na
var line lineR3 = na, var label labelR3 = na
var line lineS1 = na, var label labelS1 = na
var line lineS2 = na, var label labelS2 = na
var line lineS3 = na, var label labelS3 = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MULTI-SESSION INFRASTRUCTURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Configuration: Maximum VWAP history to track (must be >= max user input)
const int MAX_VWAP_HISTORY = 10  // Track VWAPs for last 10 sessions of each type (matches max input)

// Determine which session to use for weekly anchors
string weeklyAnchorSessionName = weeklyAnchorSession == "Auto" ? (syminfo.type == "stock" ? "New York" : "Globex") : weeklyAnchorSession

// Session arrays (indices: 0=London, 1=NY, 2=Globex, 3=Sydney, 4=Tokyo)
var array<bool> sessionEnabled = array.from(enableLondon, enableNewYork, enableGlobex, enableSydney, enableTokyo)
var array<string> sessionNames = array.from("London", "New York", "Globex", "Sydney", "Tokyo")
var array<color> sessionColors = array.from(colorLondon, colorNewYork, colorGlobex, colorSydney, colorTokyo)

// Pre-calculate session start and end timestamps for each session type (calendar-based)
var array<int> londonStarts = array.new<int>()
var array<int> nyStarts = array.new<int>()
var array<int> globexStarts = array.new<int>()
var array<int> sydneyStarts = array.new<int>()
var array<int> tokyoStarts = array.new<int>()

var array<int> londonEnds = array.new<int>()
var array<int> nyEnds = array.new<int>()
var array<int> globexEnds = array.new<int>()
var array<int> sydneyEnds = array.new<int>()
var array<int> tokyoEnds = array.new<int>()

// Initialize session start and end arrays on first bar
if barstate.isfirst
    londonStarts := getSessionStartsArray("London", MAX_VWAP_HISTORY)
    nyStarts := getSessionStartsArray("New York", MAX_VWAP_HISTORY)
    globexStarts := getSessionStartsArray("Globex", MAX_VWAP_HISTORY)
    sydneyStarts := getSessionStartsArray("Sydney", MAX_VWAP_HISTORY)
    tokyoStarts := getSessionStartsArray("Tokyo", MAX_VWAP_HISTORY)

    londonEnds := getSessionEndsArray("London", MAX_VWAP_HISTORY)
    nyEnds := getSessionEndsArray("New York", MAX_VWAP_HISTORY)
    globexEnds := getSessionEndsArray("Globex", MAX_VWAP_HISTORY)
    sydneyEnds := getSessionEndsArray("Sydney", MAX_VWAP_HISTORY)
    tokyoEnds := getSessionEndsArray("Tokyo", MAX_VWAP_HISTORY)

// VWAP accumulators: Separate arrays per session type, each containing accumulators for multiple days
var array<float> londonSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> londonSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> nySumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> nySumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> globexSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> globexSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> sydneySumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> sydneySumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> tokyoSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> tokyoSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)

// Per-session tracking (unified with calendar-based approach)
var array<int> sessionStartBars = array.new<int>(5, na)
var array<int> sessionStartTimes = array.new<int>(5, na)
var array<label> sessionLabels = array.new<label>(5, na)

// Weekly anchor VWAP tracking
var int weeklyAnchorStartTime = na
var float weeklyAnchorSumSrc = 0.0
var float weeklyAnchorSumVol = 0.0
var float weeklyAnchorVWAP = na
var label weeklyAnchorLabel = na
var bool currentSessionIsWeeklyAnchor = false

// Active session tracking (for session levels)
var int activeSessionIndex = na
var string activeSessionName = na

// Session levels (always track the most recently started selected session)
var float sessionOpen = na
var float openRangeHigh = na
var float openRangeLow = na
var float initialBalanceHigh = na
var float initialBalanceLow = na
var int sessionStartBar = na
var int sessionStartTime = na

// Track bar indices where each level was established
var int openPriceBar = na
var int orhBar = na
var int orlBar = na
var int ibhBar = na
var int iblBar = na

// Calculate elapsed minutes in session
int openRangeMinutes = periodToMinutes(openRangePeriod)
int ibMinutes = periodToMinutes(initialBalancePeriod)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UNIFIED SESSION DETECTION (Calendar-based for labels, levels, and VWAPs)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detect session changes using pre-calculated session start timestamps
for i = 0 to 4
    if array.get(sessionEnabled, i)
        string sessionName = array.get(sessionNames, i)

        // Get pre-calculated session starts for this session type (most recent session only)
        array<int> sessionStartsArray = i == 0 ? londonStarts : i == 1 ? nyStarts : i == 2 ? globexStarts : i == 3 ? sydneyStarts : tokyoStarts
        int mostRecentSessionStart = array.get(sessionStartsArray, MAX_VWAP_HISTORY - 1)

        // Detect session change: current bar crossed into this session
        bool thisSessionChange = time >= mostRecentSessionStart and time[1] < mostRecentSessionStart

        // When this session starts
        if thisSessionChange
            // Note: Labels are now created in the VWAP calculation loop below

            // Update session tracking (using calendar-based timestamp)
            array.set(sessionStartBars, i, bar_index)
            array.set(sessionStartTimes, i, mostRecentSessionStart)

            // This session becomes the active session for levels
            activeSessionIndex := i
            activeSessionName := sessionName

            // Reset session levels to this session
            sessionOpen := open
            openRangeHigh := high
            openRangeLow := low
            initialBalanceHigh := high
            initialBalanceLow := low
            sessionStartBar := bar_index
            sessionStartTime := mostRecentSessionStart
            openPriceBar := bar_index
            orhBar := bar_index
            orlBar := bar_index
            ibhBar := bar_index
            iblBar := bar_index

// Update session levels (only for active session, using calendar-based timestamps)
if not na(activeSessionIndex) and not na(sessionOpen) and not na(sessionStartTime)
    // Get session end time to check if session has closed
    array<int> activeSessionEnds = activeSessionIndex == 0 ? londonEnds : activeSessionIndex == 1 ? nyEnds : activeSessionIndex == 2 ? globexEnds : activeSessionIndex == 3 ? sydneyEnds : tokyoEnds
    int currentSessionEnd = array.get(activeSessionEnds, MAX_VWAP_HISTORY - 1)

    // Check if we're still in the current session (after start, before end)
    bool stillInSession = time >= sessionStartTime and time < currentSessionEnd

    if stillInSession
        // Calculate elapsed time since session start (calendar-based)
        int elapsedMinutes = math.round((time - sessionStartTime) / 60000)
        // Update Open Range
        if elapsedMinutes <= openRangeMinutes
            if high > openRangeHigh
                openRangeHigh := high
                orhBar := bar_index
            if low < openRangeLow
                openRangeLow := low
                orlBar := bar_index

        // Update Initial Balance
        if elapsedMinutes <= ibMinutes
            if high > initialBalanceHigh
                initialBalanceHigh := high
                ibhBar := bar_index
            if low < initialBalanceLow
                initialBalanceLow := low
                iblBar := bar_index

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MULTI-SESSION VWAP CALCULATIONS (Calendar-based pre-calculated anchors)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// VWAP arrays to store calculated values for plotting (up to MAX_VWAP_HISTORY per session)
var array<float> londonVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> nyVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> globexVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> sydneyVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> tokyoVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)

// Arrays to store label IDs for each historical VWAP
var array<label> londonLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> nyLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> globexLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> sydneyLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> tokyoLabels = array.new<label>(MAX_VWAP_HISTORY, na)

// Calculate VWAP for each enabled session using calendar-based pre-calculated session starts
for i = 0 to 4
    if array.get(sessionEnabled, i)
        // Get configuration for this session type
        int historyCount = i == 0 ? londonVWAPCount : i == 1 ? nyVWAPCount : i == 2 ? globexVWAPCount : i == 3 ? sydneyVWAPCount : tokyoVWAPCount
        array<int> sessionStartsArray = i == 0 ? londonStarts : i == 1 ? nyStarts : i == 2 ? globexStarts : i == 3 ? sydneyStarts : tokyoStarts
        array<float> sumSrcArray = i == 0 ? londonSumSrc : i == 1 ? nySumSrc : i == 2 ? globexSumSrc : i == 3 ? sydneySumSrc : tokyoSumSrc
        array<float> sumVolArray = i == 0 ? londonSumVol : i == 1 ? nySumVol : i == 2 ? globexSumVol : i == 3 ? sydneySumVol : tokyoSumVol
        array<float> vwapArray = i == 0 ? londonVWAPs : i == 1 ? nyVWAPs : i == 2 ? globexVWAPs : i == 3 ? sydneyVWAPs : tokyoVWAPs
        array<label> labelArray = i == 0 ? londonLabels : i == 1 ? nyLabels : i == 2 ? globexLabels : i == 3 ? sydneyLabels : tokyoLabels
        color sessionColor = i == 0 ? colorLondon : i == 1 ? colorNewYork : i == 2 ? colorGlobex : i == 3 ? colorSydney : colorTokyo
        string sessionName = i == 0 ? "London" : i == 1 ? "New York" : i == 2 ? "Globex" : i == 3 ? "Sydney" : "Tokyo"

        // Loop through all tracked sessions (MAX_VWAP_HISTORY)
        for arrayIdx = 0 to MAX_VWAP_HISTORY - 1
            int sessionStart = array.get(sessionStartsArray, arrayIdx)

            // Get the next session start (to know when to stop calculating this VWAP)
            int nextSessionStart = arrayIdx < MAX_VWAP_HISTORY - 1 ? array.get(sessionStartsArray, arrayIdx + 1) : int(na)

            // Check if we're at the start of this session
            bool isSessionStart = time >= sessionStart and time[1] < sessionStart

            // Check if this VWAP is within the configured history count
            // Array layout: [0=oldest ... 9=newest] with MAX_VWAP_HISTORY=10
            // If historyCount=1: only arrayIdx=9 is visible (sessionIndexInHistory >= 0)
            // If historyCount=2: arrayIdx=8,9 are visible
            // If historyCount=5: arrayIdx=5,6,7,8,9 are visible
            int sessionIndexInHistory = arrayIdx - (MAX_VWAP_HISTORY - historyCount)
            bool isInConfiguredRange = sessionIndexInHistory >= 0

            // VWAPs should calculate as long as they're in the configured range AND after their session started
            // They continue calculating even after the next session starts (unlike the old logic)
            bool shouldCalculate = time >= sessionStart and isInConfiguredRange

            if shouldCalculate
                // Get current accumulators for this session
                float currentSumSrc = array.get(sumSrcArray, arrayIdx)
                float currentSumVol = array.get(sumVolArray, arrayIdx)

                // Reset accumulators on new session start, otherwise accumulate continuously
                float newSumSrc = isSessionStart ? (ohlc4 * volume) : (currentSumSrc + ohlc4 * volume)
                float newSumVol = isSessionStart ? volume : (currentSumVol + volume)

                // Update accumulators
                array.set(sumSrcArray, arrayIdx, newSumSrc)
                array.set(sumVolArray, arrayIdx, newSumVol)

                // Calculate VWAP and store in array
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(vwapArray, arrayIdx, vwap)

                // Create session label at session start ONLY if within configured history count
                if isSessionStart and showSessionMarkersCondition and showSessionLabels and isInConfiguredRange
                    // Delete old label for this specific VWAP session
                    label oldLabel = array.get(labelArray, arrayIdx)
                    if not na(oldLabel)
                        label.delete(oldLabel)

                    // Calculate position in history for color matching
                    int positionInHistory = (MAX_VWAP_HISTORY - 1) - arrayIdx

                    // Get matching VWAP color
                    color labelColor = getVWAPColor(sessionColor, positionInHistory, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation)

                    // Create new label with session name + date
                    string labelSizeActual = getLabelSize(globalLabelSize)
                    string tz = getSessionTimezone(sessionName)
                    string sessionDate = str.format_time(sessionStart, "d MMM", tz)
                    string labelText = sessionName + " " + sessionDate

                    label newLabel = label.new(bar_index, high, labelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=labelColor, textcolor=color.white, size=labelSizeActual, style=label.style_label_down)
                    array.set(labelArray, arrayIdx, newLabel)

                    // Also update the main sessionLabels array for the most recent session (for backwards compatibility)
                    if arrayIdx == MAX_VWAP_HISTORY - 1
                        array.set(sessionLabels, i, newLabel)

            // Clean up labels that are outside the configured history count
            if not isInConfiguredRange
                label oldLabel = array.get(labelArray, arrayIdx)
                if not na(oldLabel)
                    label.delete(oldLabel)
                    array.set(labelArray, arrayIdx, na)

// Plot VWAPs - up to 10 historical sessions per type
// London VWAPs (position 0 = most recent, position 1 = 2nd most recent, etc.)
// Skip plotting most recent if it's the weekly anchor
bool skipLondonMostRecent = weeklyAnchorSessionName == "London" and currentSessionIsWeeklyAnchor
plot(showSessionMarkersCondition and showSessionVWAP and enableLondon and londonVWAPCount >= 1 and not skipLondonMostRecent ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 1) : na, "London VWAP 1", color=getVWAPColor(colorLondon, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableLondon and londonVWAPCount >= 2 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 2) : na, "London VWAP 2", color=getVWAPColor(colorLondon, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableLondon and londonVWAPCount >= 3 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 3) : na, "London VWAP 3", color=getVWAPColor(colorLondon, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableLondon and londonVWAPCount >= 4 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 4) : na, "London VWAP 4", color=getVWAPColor(colorLondon, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableLondon and londonVWAPCount >= 5 ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 5) : na, "London VWAP 5", color=getVWAPColor(colorLondon, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// NY VWAPs
bool skipNYMostRecent = weeklyAnchorSessionName == "New York" and currentSessionIsWeeklyAnchor
plot(showSessionMarkersCondition and showSessionVWAP and enableNewYork and nyVWAPCount >= 1 and not skipNYMostRecent ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 1) : na, "NY VWAP 1", color=getVWAPColor(colorNewYork, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableNewYork and nyVWAPCount >= 2 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 2) : na, "NY VWAP 2", color=getVWAPColor(colorNewYork, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableNewYork and nyVWAPCount >= 3 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 3) : na, "NY VWAP 3", color=getVWAPColor(colorNewYork, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableNewYork and nyVWAPCount >= 4 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 4) : na, "NY VWAP 4", color=getVWAPColor(colorNewYork, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableNewYork and nyVWAPCount >= 5 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 5) : na, "NY VWAP 5", color=getVWAPColor(colorNewYork, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// Globex VWAPs
bool skipGlobexMostRecent = weeklyAnchorSessionName == "Globex" and currentSessionIsWeeklyAnchor
plot(showSessionMarkersCondition and showSessionVWAP and enableGlobex and globexVWAPCount >= 1 and not skipGlobexMostRecent ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 1) : na, "Globex VWAP 1", color=getVWAPColor(colorGlobex, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableGlobex and globexVWAPCount >= 2 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 2) : na, "Globex VWAP 2", color=getVWAPColor(colorGlobex, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableGlobex and globexVWAPCount >= 3 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 3) : na, "Globex VWAP 3", color=getVWAPColor(colorGlobex, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableGlobex and globexVWAPCount >= 4 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 4) : na, "Globex VWAP 4", color=getVWAPColor(colorGlobex, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableGlobex and globexVWAPCount >= 5 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 5) : na, "Globex VWAP 5", color=getVWAPColor(colorGlobex, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// Sydney VWAPs
bool skipSydneyMostRecent = weeklyAnchorSessionName == "Sydney" and currentSessionIsWeeklyAnchor
plot(showSessionMarkersCondition and showSessionVWAP and enableSydney and sydneyVWAPCount >= 1 and not skipSydneyMostRecent ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 1) : na, "Sydney VWAP 1", color=getVWAPColor(colorSydney, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableSydney and sydneyVWAPCount >= 2 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 2) : na, "Sydney VWAP 2", color=getVWAPColor(colorSydney, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableSydney and sydneyVWAPCount >= 3 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 3) : na, "Sydney VWAP 3", color=getVWAPColor(colorSydney, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableSydney and sydneyVWAPCount >= 4 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 4) : na, "Sydney VWAP 4", color=getVWAPColor(colorSydney, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableSydney and sydneyVWAPCount >= 5 ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 5) : na, "Sydney VWAP 5", color=getVWAPColor(colorSydney, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// Tokyo VWAPs
bool skipTokyoMostRecent = weeklyAnchorSessionName == "Tokyo" and currentSessionIsWeeklyAnchor
plot(showSessionMarkersCondition and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 1 and not skipTokyoMostRecent ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 1) : na, "Tokyo VWAP 1", color=getVWAPColor(colorTokyo, 0, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 2 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 2) : na, "Tokyo VWAP 2", color=getVWAPColor(colorTokyo, 1, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 3 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 3) : na, "Tokyo VWAP 3", color=getVWAPColor(colorTokyo, 2, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 4 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 4) : na, "Tokyo VWAP 4", color=getVWAPColor(colorTokyo, 3, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(showSessionMarkersCondition and showSessionVWAP and enableTokyo and tokyoVWAPCount >= 5 ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 5) : na, "Tokyo VWAP 5", color=getVWAPColor(colorTokyo, 4, vwapColorDifferentiation, vwapMaxTransparency, vwapHueShift, vwapDesaturation), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEEKLY ANCHOR VWAP CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Get the session arrays for the anchor session type
array<int> anchorSessionStarts = weeklyAnchorSessionName == "London" ? londonStarts : weeklyAnchorSessionName == "New York" ? nyStarts : weeklyAnchorSessionName == "Globex" ? globexStarts : weeklyAnchorSessionName == "Sydney" ? sydneyStarts : tokyoStarts

// Detect first session of the week for anchor session type
bool isFirstSessionOfWeek = false
if showWeeklyAnchorVWAP and showSessionMarkersCondition
    string anchorTZ = getSessionTimezone(weeklyAnchorSessionName)

    // Search through all sessions to find the most recent Monday/Sunday session
    int currentWeekNumber = weekofyear(timenow, anchorTZ)
    int mondaySessionStart = na

    // Search backwards through all tracked sessions to find first session of current week
    for i = MAX_VWAP_HISTORY - 1 to 0
        int sessionStart = array.get(anchorSessionStarts, i)
        if not na(sessionStart)
            int sessionWeek = weekofyear(sessionStart, anchorTZ)
            int sessionDayOfWeek = dayofweek(sessionStart, anchorTZ)

            // Check if this is the week start day for this session type
            // Globex: Sunday evening (starts the trading week)
            // All others: Monday
            bool isWeekStartDay = false
            bool isCurrentWeek = false

            if weeklyAnchorSessionName == "Globex"
                // Globex anchors on Sunday evening
                bool isSunday = sessionDayOfWeek == dayofweek.sunday
                isWeekStartDay := isSunday
                // Sunday belongs to previous week number, but starts next week's trading
                // So check if sessionWeek + 1 equals current week
                isCurrentWeek := (sessionWeek + 1 == currentWeekNumber) or (sessionWeek == 52 and currentWeekNumber == 1)
            else
                // All other sessions anchor on Monday
                bool isMonday = sessionDayOfWeek == dayofweek.monday
                isWeekStartDay := isMonday
                isCurrentWeek := sessionWeek == currentWeekNumber

            if isCurrentWeek and isWeekStartDay
                mondaySessionStart := sessionStart
                break

    // If we found a Monday/Sunday session and it's different from our current anchor, update it
    if not na(mondaySessionStart) and (na(weeklyAnchorStartTime) or mondaySessionStart != weeklyAnchorStartTime)
        weeklyAnchorStartTime := mondaySessionStart
        weeklyAnchorSumSrc := 0.0
        weeklyAnchorSumVol := 0.0
        currentSessionIsWeeklyAnchor := (mondaySessionStart == array.get(anchorSessionStarts, MAX_VWAP_HISTORY - 1))

    // Accumulate VWAP for weekly anchor (from Monday session onwards)
    if not na(weeklyAnchorStartTime) and time >= weeklyAnchorStartTime
        weeklyAnchorSumSrc := weeklyAnchorSumSrc + (ohlc4 * volume)
        weeklyAnchorSumVol := weeklyAnchorSumVol + volume
        weeklyAnchorVWAP := weeklyAnchorSumVol > 0 ? weeklyAnchorSumSrc / weeklyAnchorSumVol : na

    // Create label at Monday session start (keep it there, don't move it)
    if showSessionLabels and not na(mondaySessionStart)
        bool mondaySessionJustStarted = time >= mondaySessionStart and time[1] < mondaySessionStart
        if mondaySessionJustStarted
            if not na(weeklyAnchorLabel)
                label.delete(weeklyAnchorLabel)
            string labelText = "Week " + str.tostring(currentWeekNumber) + " (" + weeklyAnchorSessionName + ")"
            weeklyAnchorLabel := label.new(bar_index, high, labelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=colorWeeklyAnchor, textcolor=color.white, size=getLabelSize(globalLabelSize), style=label.style_label_down)

// Plot weekly anchor VWAP
plot(showWeeklyAnchorVWAP and showSessionMarkersCondition and not na(weeklyAnchorVWAP) ? weeklyAnchorVWAP : na, "Weekly Anchor VWAP", color=colorWeeklyAnchor, linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION LEVELS RENDERING (for active session only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line lineOpenPrice = na, var label labelOpenPrice = na
var line lineORH = na, var line lineORL = na, var label labelORH = na, var label labelORL = na
var line lineIBH = na, var line lineIBL = na, var label labelIBH = na, var label labelIBL = na
var box boxOpenRange = na
var box boxInitialBalanceUpper = na
var box boxInitialBalanceLower = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEY LEVELS RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Cache bar_index to prevent redundant updates on same bar (improves scrolling performance)
var int lastRenderBarIndex = na

if barstate.islast and (na(lastRenderBarIndex) or bar_index != lastRenderBarIndex)
    lastRenderBarIndex := bar_index

    // Calculate line start position with hard limit to prevent lines getting too long
    int startBar = math.max(0, bar_index - globalLineLengthBars)
    int maxLineDistance = 200  // Safe hard limit: must match max value of globalLineLengthBars input (prevents crashes on high-frequency charts)

    // Determine session line start based on user preference, but reset to configured length if beyond hard limit
    int sessionOpenBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
    int openPriceStartBar = intradayLineStartMode == "Level Established" and not na(openPriceBar) ? (bar_index - openPriceBar > maxLineDistance ? startBar : openPriceBar) : (intradayLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orhStartBar = intradayLineStartMode == "Level Established" and not na(orhBar) ? (bar_index - orhBar > maxLineDistance ? startBar : orhBar) : (intradayLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orlStartBar = intradayLineStartMode == "Level Established" and not na(orlBar) ? (bar_index - orlBar > maxLineDistance ? startBar : orlBar) : (intradayLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int ibhStartBar = intradayLineStartMode == "Level Established" and not na(ibhBar) ? (bar_index - ibhBar > maxLineDistance ? startBar : ibhBar) : (intradayLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int iblStartBar = intradayLineStartMode == "Level Established" and not na(iblBar) ? (bar_index - iblBar > maxLineDistance ? startBar : iblBar) : (intradayLineStartMode == "Session Open" ? sessionOpenBar : startBar)

    string keyLevelsLineStyleActual = getLineStyle(keyLevelsLineStyle)
    string labelSizeActual = getLabelSize(globalLabelSize)

    // Round prices for map key consistency
    float athRounded = roundToTick(ath)
    float pyhRounded = roundToTick(pyh)
    float pylRounded = roundToTick(pyl)
    float pmhRounded = roundToTick(pmh)
    float pmlRounded = roundToTick(pml)
    float pwhRounded = roundToTick(pwh)
    float pwlRounded = roundToTick(pwl)
    float pdhRounded = roundToTick(pdh)
    float pdlRounded = roundToTick(pdl)
    float cyhRounded = roundToTick(cyh)
    float cylRounded = roundToTick(cyl)
    float cmhRounded = roundToTick(cmh)
    float cmlRounded = roundToTick(cml)
    float cwhRounded = roundToTick(cwh)
    float cwlRounded = roundToTick(cwl)
    float cdhRounded = roundToTick(cdh)
    float cdlRounded = roundToTick(cdl)

    // Pivot points rounded
    float pivotPRounded = roundToTick(pivotP)
    float pivotR1Rounded = roundToTick(pivotR1)
    float pivotR2Rounded = roundToTick(pivotR2)
    float pivotR3Rounded = roundToTick(pivotR3)
    float pivotS1Rounded = roundToTick(pivotS1)
    float pivotS2Rounded = roundToTick(pivotS2)
    float pivotS3Rounded = roundToTick(pivotS3)

    // Session levels rounded
    float ibhRounded = roundToTick(initialBalanceHigh)
    float iblRounded = roundToTick(initialBalanceLow)
    float orhRounded = roundToTick(openRangeHigh)
    float orlRounded = roundToTick(openRangeLow)
    float openRounded = roundToTick(sessionOpen)

    // Build price->label map (merges duplicates with "/")
    // Priority: Session Levels > Pivot Points > Key Levels
    var map<float, string> priceLabels = map.new<float, string>()
    map.clear(priceLabels)

    // Session levels first (highest priority)
    bool shouldAddSessionToMap = showSessionMarkersCondition and not na(sessionOpen)
    if shouldAddSessionToMap
        if showOpenPrice
            addToMap(priceLabels, sessionOpen, "Open")
        if showOpenRange and not na(openRangeHigh)
            addToMap(priceLabels, openRangeHigh, "ORH")
        if showOpenRange and not na(openRangeLow)
            addToMap(priceLabels, openRangeLow, "ORL")
        if showInitialBalance and not na(initialBalanceHigh)
            addToMap(priceLabels, initialBalanceHigh, "IBH")
        if showInitialBalance and not na(initialBalanceLow)
            addToMap(priceLabels, initialBalanceLow, "IBL")

    // Pivot points second (after session, before key levels)
    if showPivotsCondition
        if showPivotP
            addToMap(priceLabels, pivotP, "P")
        if showPivotR1
            addToMap(priceLabels, pivotR1, "R1")
        if showPivotR2
            addToMap(priceLabels, pivotR2, "R2")
        if showPivotR3
            addToMap(priceLabels, pivotR3, "R3")
        if showPivotS1
            addToMap(priceLabels, pivotS1, "S1")
        if showPivotS2
            addToMap(priceLabels, pivotS2, "S2")
        if showPivotS3
            addToMap(priceLabels, pivotS3, "S3")

    // Key levels (lower priority)
    if showKeyLevelsCondition
        if showATH
            addToMap(priceLabels, ath, "ATH")
        if showPYH
            addToMap(priceLabels, pyh, "PYH")
        if showPYL
            addToMap(priceLabels, pyl, "PYL")
        if showPMH
            addToMap(priceLabels, pmh, "PMH")
        if showPML
            addToMap(priceLabels, pml, "PML")
        if showPWH
            addToMap(priceLabels, pwh, "PWH")
        if showPWL
            addToMap(priceLabels, pwl, "PWL")
        if showPDH
            addToMap(priceLabels, pdh, "PDH")
        if showPDL
            addToMap(priceLabels, pdl, "PDL")
        if showCYH
            addToMap(priceLabels, cyh, "CYH")
        if showCYL
            addToMap(priceLabels, cyl, "CYL")
        if showCMH
            addToMap(priceLabels, cmh, "CMH")
        if showCML
            addToMap(priceLabels, cml, "CML")
        if showCWH
            addToMap(priceLabels, cwh, "CWH")
        if showCWL
            addToMap(priceLabels, cwl, "CWL")
        if showCDH
            addToMap(priceLabels, cdh, "CDH")
        if showCDL
            addToMap(priceLabels, cdl, "CDL")

    var array<float> renderedPrices = array.new<float>()
    array.clear(renderedPrices)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION LEVELS RENDERING (FIRST - highest priority for line style)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    string sessionLineStyleActual = getLineStyle(intradayLevelsLineStyle)
    // Only show session levels if we have an active session
    bool shouldShowSessionLevels = showSessionMarkersCondition and not na(activeSessionIndex) and not na(sessionOpen)

    // Opening Price
    if shouldShowSessionLevels and showIntradayLevels and showOpenPrice and isWithinATR(sessionOpen, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, openRounded)
            string combinedLabel = map.contains(priceLabels, openRounded) ? map.get(priceLabels, openRounded) : "Open"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(sessionOpen, format.mintick) + ")" : combinedLabel
            if na(lineOpenPrice)
                lineOpenPrice := line.new(openPriceStartBar, sessionOpen, bar_index, sessionOpen, color=colorOpenPrice, width=intradayLevelsLineWidth, style=sessionLineStyleActual)
                labelOpenPrice := label.new(bar_index, sessionOpen, labelText, color=labelBgColor(colorOpenPrice), textcolor=colorOpenPrice, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineOpenPrice, openPriceStartBar, sessionOpen), line.set_xy2(lineOpenPrice, bar_index, sessionOpen)
                label.set_xy(labelOpenPrice, bar_index, sessionOpen), label.set_text(labelOpenPrice, labelText)
            array.push(renderedPrices, openRounded)
    else if not na(lineOpenPrice)
        line.delete(lineOpenPrice), lineOpenPrice := na, label.delete(labelOpenPrice), labelOpenPrice := na

    // Open Range High
    if shouldShowSessionLevels and showIntradayLevels and showOpenRange and not na(openRangeHigh) and isWithinATR(openRangeHigh, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, orhRounded)
            string combinedLabel = map.contains(priceLabels, orhRounded) ? map.get(priceLabels, orhRounded) : "ORH"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(openRangeHigh, format.mintick) + ")" : combinedLabel
            if na(lineORH)
                lineORH := line.new(orhStartBar, openRangeHigh, bar_index, openRangeHigh, color=colorORH, width=intradayLevelsLineWidth, style=sessionLineStyleActual)
                labelORH := label.new(bar_index, openRangeHigh, labelText, color=labelBgColor(colorORH), textcolor=colorORH, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineORH, orhStartBar, openRangeHigh), line.set_xy2(lineORH, bar_index, openRangeHigh)
                label.set_xy(labelORH, bar_index, openRangeHigh), label.set_text(labelORH, labelText)
            array.push(renderedPrices, orhRounded)
    else if not na(lineORH)
        line.delete(lineORH), lineORH := na, label.delete(labelORH), labelORH := na

    // Open Range Low
    if shouldShowSessionLevels and showIntradayLevels and showOpenRange and not na(openRangeLow) and isWithinATR(openRangeLow, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, orlRounded)
            string combinedLabel = map.contains(priceLabels, orlRounded) ? map.get(priceLabels, orlRounded) : "ORL"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(openRangeLow, format.mintick) + ")" : combinedLabel
            if na(lineORL)
                lineORL := line.new(orlStartBar, openRangeLow, bar_index, openRangeLow, color=colorORL, width=intradayLevelsLineWidth, style=sessionLineStyleActual)
                labelORL := label.new(bar_index, openRangeLow, labelText, color=labelBgColor(colorORL), textcolor=colorORL, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineORL, orlStartBar, openRangeLow), line.set_xy2(lineORL, bar_index, openRangeLow)
                label.set_xy(labelORL, bar_index, openRangeLow), label.set_text(labelORL, labelText)
            array.push(renderedPrices, orlRounded)
    else if not na(lineORL)
        line.delete(lineORL), lineORL := na, label.delete(labelORL), labelORL := na

    // Open Range Background Shading (boxes represent time periods, always start from session start)
    if shouldShowSessionLevels and showIntradayLevels and showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        // Box always starts from session start but truncate if beyond hard limit
        int boxORStartBar = not na(sessionStartBar) ? sessionStartBar : startBar
        // Apply hard limit: if box would be too long, truncate to configured length
        if bar_index - boxORStartBar > maxLineDistance
            boxORStartBar := startBar
        if na(boxOpenRange)
            boxOpenRange := box.new(boxORStartBar, openRangeHigh, bar_index, openRangeLow, border_color=na, bgcolor=colorOpenRangeShade)
        else
            box.set_lefttop(boxOpenRange, boxORStartBar, openRangeHigh)
            box.set_rightbottom(boxOpenRange, bar_index, openRangeLow)
    else if not na(boxOpenRange)
        box.delete(boxOpenRange), boxOpenRange := na

    // Initial Balance High
    if shouldShowSessionLevels and showIntradayLevels and showInitialBalance and not na(initialBalanceHigh) and isWithinATR(initialBalanceHigh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, ibhRounded)
        string combinedLabel = map.contains(priceLabels, ibhRounded) ? map.get(priceLabels, ibhRounded) : "IBH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(initialBalanceHigh, format.mintick) + ")" : combinedLabel
        if na(lineIBH)
            lineIBH := line.new(ibhStartBar, initialBalanceHigh, bar_index, initialBalanceHigh, color=colorIBH, width=intradayLevelsLineWidth, style=sessionLineStyleActual)
            labelIBH := label.new(bar_index, initialBalanceHigh, labelText, color=labelBgColor(colorIBH), textcolor=colorIBH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineIBH, ibhStartBar, initialBalanceHigh), line.set_xy2(lineIBH, bar_index, initialBalanceHigh)
            label.set_xy(labelIBH, bar_index, initialBalanceHigh), label.set_text(labelIBH, labelText)
        array.push(renderedPrices, ibhRounded)
    else if not na(lineIBH)
        line.delete(lineIBH), lineIBH := na, label.delete(labelIBH), labelIBH := na

    // Initial Balance Low
    if shouldShowSessionLevels and showIntradayLevels and showInitialBalance and not na(initialBalanceLow) and isWithinATR(initialBalanceLow, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, iblRounded)
        string combinedLabel = map.contains(priceLabels, iblRounded) ? map.get(priceLabels, iblRounded) : "IBL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(initialBalanceLow, format.mintick) + ")" : combinedLabel
        if na(lineIBL)
            lineIBL := line.new(iblStartBar, initialBalanceLow, bar_index, initialBalanceLow, color=colorIBL, width=intradayLevelsLineWidth, style=sessionLineStyleActual)
            labelIBL := label.new(bar_index, initialBalanceLow, labelText, color=labelBgColor(colorIBL), textcolor=colorIBL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineIBL, iblStartBar, initialBalanceLow), line.set_xy2(lineIBL, bar_index, initialBalanceLow)
            label.set_xy(labelIBL, bar_index, initialBalanceLow), label.set_text(labelIBL, labelText)
        array.push(renderedPrices, iblRounded)
    else if not na(lineIBL)
        line.delete(lineIBL), lineIBL := na, label.delete(labelIBL), labelIBL := na

    // Initial Balance Background Shading (boxes represent time periods, always start from session start)
    if shouldShowSessionLevels and showIntradayLevels and showInitialBalance and shadeInitialBalance and not na(initialBalanceHigh) and not na(initialBalanceLow)
        // Box always starts from session start but truncate if beyond hard limit
        int boxIBStartBar = not na(sessionStartBar) ? sessionStartBar : startBar
        // Apply hard limit: if box would be too long, truncate to configured length
        if bar_index - boxIBStartBar > maxLineDistance
            boxIBStartBar := startBar

        // If both OR and IB boxes enabled, split IB into upper/lower to avoid overlap
        bool splitIBBox = showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)

        if splitIBBox
            // Create upper box: IBH to ORH
            if initialBalanceHigh > openRangeHigh
                if na(boxInitialBalanceUpper)
                    boxInitialBalanceUpper := box.new(boxIBStartBar, initialBalanceHigh, bar_index, openRangeHigh, border_color=na, bgcolor=colorInitialBalanceShade)
                else
                    box.set_lefttop(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh)
                    box.set_rightbottom(boxInitialBalanceUpper, bar_index, openRangeHigh)
            else if not na(boxInitialBalanceUpper)
                box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na

            // Create lower box: ORL to IBL
            if initialBalanceLow < openRangeLow
                if na(boxInitialBalanceLower)
                    boxInitialBalanceLower := box.new(boxIBStartBar, openRangeLow, bar_index, initialBalanceLow, border_color=na, bgcolor=colorInitialBalanceShade)
                else
                    box.set_lefttop(boxInitialBalanceLower, boxIBStartBar, openRangeLow)
                    box.set_rightbottom(boxInitialBalanceLower, bar_index, initialBalanceLow)
            else if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
        else
            // Single IB box when OR box not shown
            if na(boxInitialBalanceUpper)
                boxInitialBalanceUpper := box.new(boxIBStartBar, initialBalanceHigh, bar_index, initialBalanceLow, border_color=na, bgcolor=colorInitialBalanceShade)
            else
                box.set_lefttop(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh)
                box.set_rightbottom(boxInitialBalanceUpper, bar_index, initialBalanceLow)

            // Delete lower box if it exists
            if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
    else
        // Delete both boxes when IB shading disabled
        if not na(boxInitialBalanceUpper)
            box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
        if not na(boxInitialBalanceLower)
            box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PIVOT POINTS RENDERING (SECOND - after session levels, before key levels)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    string pivotLineStyleActual = getLineStyle(pivotLineStyle)

    // Pivot P
    if showPivotsCondition and showPivotP and not na(pivotP) and isWithinATR(pivotP, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotPRounded)
            string combinedLabel = map.contains(priceLabels, pivotPRounded) ? map.get(priceLabels, pivotPRounded) : "P"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotP, format.mintick) + ")" : combinedLabel
            if na(lineP)
                lineP := line.new(startBar, pivotP, bar_index, pivotP, color=pivotColorP, width=pivotLineWidth, style=pivotLineStyleActual)
                labelP := label.new(bar_index, pivotP, labelText, color=labelBgColor(pivotColorP), textcolor=pivotColorP, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineP, startBar, pivotP), line.set_xy2(lineP, bar_index, pivotP)
                label.set_xy(labelP, bar_index, pivotP), label.set_text(labelP, labelText)
            array.push(renderedPrices, pivotPRounded)
        else
            if not na(lineP)
                line.delete(lineP), lineP := na, label.delete(labelP), labelP := na
    else if not na(lineP)
        line.delete(lineP), lineP := na, label.delete(labelP), labelP := na

    // Pivot R1
    if showPivotsCondition and showPivotR1 and not na(pivotR1) and isWithinATR(pivotR1, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotR1Rounded)
            string combinedLabel = map.contains(priceLabels, pivotR1Rounded) ? map.get(priceLabels, pivotR1Rounded) : "R1"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotR1, format.mintick) + ")" : combinedLabel
            if na(lineR1)
                lineR1 := line.new(startBar, pivotR1, bar_index, pivotR1, color=pivotColorR1, width=pivotLineWidth, style=pivotLineStyleActual)
                labelR1 := label.new(bar_index, pivotR1, labelText, color=labelBgColor(pivotColorR1), textcolor=pivotColorR1, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineR1, startBar, pivotR1), line.set_xy2(lineR1, bar_index, pivotR1)
                label.set_xy(labelR1, bar_index, pivotR1), label.set_text(labelR1, labelText)
            array.push(renderedPrices, pivotR1Rounded)
        else
            if not na(lineR1)
                line.delete(lineR1), lineR1 := na, label.delete(labelR1), labelR1 := na
    else if not na(lineR1)
        line.delete(lineR1), lineR1 := na, label.delete(labelR1), labelR1 := na

    // Pivot R2
    if showPivotsCondition and showPivotR2 and not na(pivotR2) and isWithinATR(pivotR2, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotR2Rounded)
            string combinedLabel = map.contains(priceLabels, pivotR2Rounded) ? map.get(priceLabels, pivotR2Rounded) : "R2"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotR2, format.mintick) + ")" : combinedLabel
            if na(lineR2)
                lineR2 := line.new(startBar, pivotR2, bar_index, pivotR2, color=pivotColorR2, width=pivotLineWidth, style=pivotLineStyleActual)
                labelR2 := label.new(bar_index, pivotR2, labelText, color=labelBgColor(pivotColorR2), textcolor=pivotColorR2, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineR2, startBar, pivotR2), line.set_xy2(lineR2, bar_index, pivotR2)
                label.set_xy(labelR2, bar_index, pivotR2), label.set_text(labelR2, labelText)
            array.push(renderedPrices, pivotR2Rounded)
        else
            if not na(lineR2)
                line.delete(lineR2), lineR2 := na, label.delete(labelR2), labelR2 := na
    else if not na(lineR2)
        line.delete(lineR2), lineR2 := na, label.delete(labelR2), labelR2 := na

    // Pivot R3
    if showPivotsCondition and showPivotR3 and not na(pivotR3) and isWithinATR(pivotR3, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotR3Rounded)
            string combinedLabel = map.contains(priceLabels, pivotR3Rounded) ? map.get(priceLabels, pivotR3Rounded) : "R3"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotR3, format.mintick) + ")" : combinedLabel
            if na(lineR3)
                lineR3 := line.new(startBar, pivotR3, bar_index, pivotR3, color=pivotColorR3, width=pivotLineWidth, style=pivotLineStyleActual)
                labelR3 := label.new(bar_index, pivotR3, labelText, color=labelBgColor(pivotColorR3), textcolor=pivotColorR3, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineR3, startBar, pivotR3), line.set_xy2(lineR3, bar_index, pivotR3)
                label.set_xy(labelR3, bar_index, pivotR3), label.set_text(labelR3, labelText)
            array.push(renderedPrices, pivotR3Rounded)
        else
            if not na(lineR3)
                line.delete(lineR3), lineR3 := na, label.delete(labelR3), labelR3 := na
    else if not na(lineR3)
        line.delete(lineR3), lineR3 := na, label.delete(labelR3), labelR3 := na

    // Pivot S1
    if showPivotsCondition and showPivotS1 and not na(pivotS1) and isWithinATR(pivotS1, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotS1Rounded)
            string combinedLabel = map.contains(priceLabels, pivotS1Rounded) ? map.get(priceLabels, pivotS1Rounded) : "S1"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotS1, format.mintick) + ")" : combinedLabel
            if na(lineS1)
                lineS1 := line.new(startBar, pivotS1, bar_index, pivotS1, color=pivotColorS1, width=pivotLineWidth, style=pivotLineStyleActual)
                labelS1 := label.new(bar_index, pivotS1, labelText, color=labelBgColor(pivotColorS1), textcolor=pivotColorS1, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineS1, startBar, pivotS1), line.set_xy2(lineS1, bar_index, pivotS1)
                label.set_xy(labelS1, bar_index, pivotS1), label.set_text(labelS1, labelText)
            array.push(renderedPrices, pivotS1Rounded)
        else
            if not na(lineS1)
                line.delete(lineS1), lineS1 := na, label.delete(labelS1), labelS1 := na
    else if not na(lineS1)
        line.delete(lineS1), lineS1 := na, label.delete(labelS1), labelS1 := na

    // Pivot S2
    if showPivotsCondition and showPivotS2 and not na(pivotS2) and isWithinATR(pivotS2, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotS2Rounded)
            string combinedLabel = map.contains(priceLabels, pivotS2Rounded) ? map.get(priceLabels, pivotS2Rounded) : "S2"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotS2, format.mintick) + ")" : combinedLabel
            if na(lineS2)
                lineS2 := line.new(startBar, pivotS2, bar_index, pivotS2, color=pivotColorS2, width=pivotLineWidth, style=pivotLineStyleActual)
                labelS2 := label.new(bar_index, pivotS2, labelText, color=labelBgColor(pivotColorS2), textcolor=pivotColorS2, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineS2, startBar, pivotS2), line.set_xy2(lineS2, bar_index, pivotS2)
                label.set_xy(labelS2, bar_index, pivotS2), label.set_text(labelS2, labelText)
            array.push(renderedPrices, pivotS2Rounded)
        else
            if not na(lineS2)
                line.delete(lineS2), lineS2 := na, label.delete(labelS2), labelS2 := na
    else if not na(lineS2)
        line.delete(lineS2), lineS2 := na, label.delete(labelS2), labelS2 := na

    // Pivot S3
    if showPivotsCondition and showPivotS3 and not na(pivotS3) and isWithinATR(pivotS3, close, atrThreshold, useATRFilter)
        if not array.includes(renderedPrices, pivotS3Rounded)
            string combinedLabel = map.contains(priceLabels, pivotS3Rounded) ? map.get(priceLabels, pivotS3Rounded) : "S3"
            string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pivotS3, format.mintick) + ")" : combinedLabel
            if na(lineS3)
                lineS3 := line.new(startBar, pivotS3, bar_index, pivotS3, color=pivotColorS3, width=pivotLineWidth, style=pivotLineStyleActual)
                labelS3 := label.new(bar_index, pivotS3, labelText, color=labelBgColor(pivotColorS3), textcolor=pivotColorS3, style=label.style_label_left, size=labelSizeActual)
            else
                line.set_xy1(lineS3, startBar, pivotS3), line.set_xy2(lineS3, bar_index, pivotS3)
                label.set_xy(labelS3, bar_index, pivotS3), label.set_text(labelS3, labelText)
            array.push(renderedPrices, pivotS3Rounded)
        else
            if not na(lineS3)
                line.delete(lineS3), lineS3 := na, label.delete(labelS3), labelS3 := na
    else if not na(lineS3)
        line.delete(lineS3), lineS3 := na, label.delete(labelS3), labelS3 := na

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // KEY LEVELS RENDERING (THIRD - after session levels and pivots)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // ATH
    if showKeyLevelsCondition and showATH and not na(ath) and isWithinATR(ath, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, athRounded)
        string combinedLabel = map.contains(priceLabels, athRounded) ? map.get(priceLabels, athRounded) : "ATH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(ath, format.mintick) + ")" : combinedLabel
        if na(lineATH)
            lineATH := line.new(startBar, ath, bar_index, ath, color=colorATH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelATH := label.new(bar_index, ath, labelText, color=labelBgColor(colorATH), textcolor=colorATH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineATH, startBar, ath), line.set_xy2(lineATH, bar_index, ath)
            label.set_xy(labelATH, bar_index, ath), label.set_text(labelATH, labelText)
        array.push(renderedPrices, athRounded)
    else if not na(lineATH)
        line.delete(lineATH), lineATH := na, label.delete(labelATH), labelATH := na

    // PYH
    if showKeyLevelsCondition and showPYH and not na(pyh) and isWithinATR(pyh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pyhRounded)
        string combinedLabel = map.contains(priceLabels, pyhRounded) ? map.get(priceLabels, pyhRounded) : "PYH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pyh, format.mintick) + ")" : combinedLabel
        if na(linePYH)
            linePYH := line.new(startBar, pyh, bar_index, pyh, color=colorPYH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPYH := label.new(bar_index, pyh, labelText, color=labelBgColor(colorPYH), textcolor=colorPYH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePYH, startBar, pyh), line.set_xy2(linePYH, bar_index, pyh)
            label.set_xy(labelPYH, bar_index, pyh), label.set_text(labelPYH, labelText)
        array.push(renderedPrices, pyhRounded)
    else if not na(linePYH)
        line.delete(linePYH), linePYH := na, label.delete(labelPYH), labelPYH := na

    // PYL
    if showKeyLevelsCondition and showPYL and not na(pyl) and isWithinATR(pyl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pylRounded)
        string combinedLabel = map.contains(priceLabels, pylRounded) ? map.get(priceLabels, pylRounded) : "PYL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pyl, format.mintick) + ")" : combinedLabel
        if na(linePYL)
            linePYL := line.new(startBar, pyl, bar_index, pyl, color=colorPYL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPYL := label.new(bar_index, pyl, labelText, color=labelBgColor(colorPYL), textcolor=colorPYL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePYL, startBar, pyl), line.set_xy2(linePYL, bar_index, pyl)
            label.set_xy(labelPYL, bar_index, pyl), label.set_text(labelPYL, labelText)
        array.push(renderedPrices, pylRounded)
    else if not na(linePYL)
        line.delete(linePYL), linePYL := na, label.delete(labelPYL), labelPYL := na

    // PMH
    if showKeyLevelsCondition and showPMH and not na(pmh) and isWithinATR(pmh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pmhRounded)
        string combinedLabel = map.contains(priceLabels, pmhRounded) ? map.get(priceLabels, pmhRounded) : "PMH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pmh, format.mintick) + ")" : combinedLabel
        if na(linePMH)
            linePMH := line.new(startBar, pmh, bar_index, pmh, color=colorPMH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPMH := label.new(bar_index, pmh, labelText, color=labelBgColor(colorPMH), textcolor=colorPMH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePMH, startBar, pmh), line.set_xy2(linePMH, bar_index, pmh)
            label.set_xy(labelPMH, bar_index, pmh), label.set_text(labelPMH, labelText)
        array.push(renderedPrices, pmhRounded)
    else if not na(linePMH)
        line.delete(linePMH), linePMH := na, label.delete(labelPMH), labelPMH := na

    // PML
    if showKeyLevelsCondition and showPML and not na(pml) and isWithinATR(pml, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pmlRounded)
        string combinedLabel = map.contains(priceLabels, pmlRounded) ? map.get(priceLabels, pmlRounded) : "PML"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pml, format.mintick) + ")" : combinedLabel
        if na(linePML)
            linePML := line.new(startBar, pml, bar_index, pml, color=colorPML, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPML := label.new(bar_index, pml, labelText, color=labelBgColor(colorPML), textcolor=colorPML, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePML, startBar, pml), line.set_xy2(linePML, bar_index, pml)
            label.set_xy(labelPML, bar_index, pml), label.set_text(labelPML, labelText)
        array.push(renderedPrices, pmlRounded)
    else if not na(linePML)
        line.delete(linePML), linePML := na, label.delete(labelPML), labelPML := na

    // PWH
    if showKeyLevelsCondition and showPWH and not na(pwh) and isWithinATR(pwh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pwhRounded)
        string combinedLabel = map.contains(priceLabels, pwhRounded) ? map.get(priceLabels, pwhRounded) : "PWH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pwh, format.mintick) + ")" : combinedLabel
        if na(linePWH)
            linePWH := line.new(startBar, pwh, bar_index, pwh, color=colorPWH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPWH := label.new(bar_index, pwh, labelText, color=labelBgColor(colorPWH), textcolor=colorPWH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePWH, startBar, pwh), line.set_xy2(linePWH, bar_index, pwh)
            label.set_xy(labelPWH, bar_index, pwh), label.set_text(labelPWH, labelText)
        array.push(renderedPrices, pwhRounded)
    else if not na(linePWH)
        line.delete(linePWH), linePWH := na, label.delete(labelPWH), labelPWH := na

    // PWL
    if showKeyLevelsCondition and showPWL and not na(pwl) and isWithinATR(pwl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pwlRounded)
        string combinedLabel = map.contains(priceLabels, pwlRounded) ? map.get(priceLabels, pwlRounded) : "PWL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pwl, format.mintick) + ")" : combinedLabel
        if na(linePWL)
            linePWL := line.new(startBar, pwl, bar_index, pwl, color=colorPWL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPWL := label.new(bar_index, pwl, labelText, color=labelBgColor(colorPWL), textcolor=colorPWL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePWL, startBar, pwl), line.set_xy2(linePWL, bar_index, pwl)
            label.set_xy(labelPWL, bar_index, pwl), label.set_text(labelPWL, labelText)
        array.push(renderedPrices, pwlRounded)
    else if not na(linePWL)
        line.delete(linePWL), linePWL := na, label.delete(labelPWL), labelPWL := na

    // PDH
    if showKeyLevelsCondition and showPDH and not na(pdh) and isWithinATR(pdh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pdhRounded)
        string combinedLabel = map.contains(priceLabels, pdhRounded) ? map.get(priceLabels, pdhRounded) : "PDH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pdh, format.mintick) + ")" : combinedLabel
        if na(linePDH)
            linePDH := line.new(startBar, pdh, bar_index, pdh, color=colorPDH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPDH := label.new(bar_index, pdh, labelText, color=labelBgColor(colorPDH), textcolor=colorPDH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePDH, startBar, pdh), line.set_xy2(linePDH, bar_index, pdh)
            label.set_xy(labelPDH, bar_index, pdh), label.set_text(labelPDH, labelText)
        array.push(renderedPrices, pdhRounded)
    else if not na(linePDH)
        line.delete(linePDH), linePDH := na, label.delete(labelPDH), labelPDH := na

    // PDL
    if showKeyLevelsCondition and showPDL and not na(pdl) and isWithinATR(pdl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, pdlRounded)
        string combinedLabel = map.contains(priceLabels, pdlRounded) ? map.get(priceLabels, pdlRounded) : "PDL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(pdl, format.mintick) + ")" : combinedLabel
        if na(linePDL)
            linePDL := line.new(startBar, pdl, bar_index, pdl, color=colorPDL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPDL := label.new(bar_index, pdl, labelText, color=labelBgColor(colorPDL), textcolor=colorPDL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePDL, startBar, pdl), line.set_xy2(linePDL, bar_index, pdl)
            label.set_xy(labelPDL, bar_index, pdl), label.set_text(labelPDL, labelText)
        array.push(renderedPrices, pdlRounded)
    else if not na(linePDL)
        line.delete(linePDL), linePDL := na, label.delete(labelPDL), labelPDL := na


    // CYH
    if showKeyLevelsCondition and showCYH and not na(cyh) and isWithinATR(cyh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cyhRounded)
        string combinedLabel = map.contains(priceLabels, cyhRounded) ? map.get(priceLabels, cyhRounded) : "CYH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cyh, format.mintick) + ")" : combinedLabel
        if na(lineCYH)
            lineCYH := line.new(startBar, cyh, bar_index, cyh, color=colorCYH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCYH := label.new(bar_index, cyh, labelText, color=labelBgColor(colorCYH), textcolor=colorCYH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCYH, startBar, cyh), line.set_xy2(lineCYH, bar_index, cyh)
            label.set_xy(labelCYH, bar_index, cyh), label.set_text(labelCYH, labelText)
        array.push(renderedPrices, cyhRounded)
    else if not na(lineCYH)
        line.delete(lineCYH), lineCYH := na, label.delete(labelCYH), labelCYH := na

    // CYL
    if showKeyLevelsCondition and showCYL and not na(cyl) and isWithinATR(cyl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cylRounded)
        string combinedLabel = map.contains(priceLabels, cylRounded) ? map.get(priceLabels, cylRounded) : "CYL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cyl, format.mintick) + ")" : combinedLabel
        if na(lineCYL)
            lineCYL := line.new(startBar, cyl, bar_index, cyl, color=colorCYL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCYL := label.new(bar_index, cyl, labelText, color=labelBgColor(colorCYL), textcolor=colorCYL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCYL, startBar, cyl), line.set_xy2(lineCYL, bar_index, cyl)
            label.set_xy(labelCYL, bar_index, cyl), label.set_text(labelCYL, labelText)
        array.push(renderedPrices, cylRounded)
    else if not na(lineCYL)
        line.delete(lineCYL), lineCYL := na, label.delete(labelCYL), labelCYL := na

    // CMH
    if showKeyLevelsCondition and showCMH and not na(cmh) and isWithinATR(cmh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cmhRounded)
        string combinedLabel = map.contains(priceLabels, cmhRounded) ? map.get(priceLabels, cmhRounded) : "CMH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cmh, format.mintick) + ")" : combinedLabel
        if na(lineCMH)
            lineCMH := line.new(startBar, cmh, bar_index, cmh, color=colorCMH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCMH := label.new(bar_index, cmh, labelText, color=labelBgColor(colorCMH), textcolor=colorCMH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCMH, startBar, cmh), line.set_xy2(lineCMH, bar_index, cmh)
            label.set_xy(labelCMH, bar_index, cmh), label.set_text(labelCMH, labelText)
        array.push(renderedPrices, cmhRounded)
    else if not na(lineCMH)
        line.delete(lineCMH), lineCMH := na, label.delete(labelCMH), labelCMH := na

    // CWH
    if showKeyLevelsCondition and showCWH and not na(cwh) and isWithinATR(cwh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cwhRounded)
        string combinedLabel = map.contains(priceLabels, cwhRounded) ? map.get(priceLabels, cwhRounded) : "CWH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cwh, format.mintick) + ")" : combinedLabel
        if na(lineCWH)
            lineCWH := line.new(startBar, cwh, bar_index, cwh, color=colorCWH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCWH := label.new(bar_index, cwh, labelText, color=labelBgColor(colorCWH), textcolor=colorCWH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCWH, startBar, cwh), line.set_xy2(lineCWH, bar_index, cwh)
            label.set_xy(labelCWH, bar_index, cwh), label.set_text(labelCWH, labelText)
        array.push(renderedPrices, cwhRounded)
    else if not na(lineCWH)
        line.delete(lineCWH), lineCWH := na, label.delete(labelCWH), labelCWH := na

    // CWL
    if showKeyLevelsCondition and showCWL and not na(cwl) and isWithinATR(cwl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cwlRounded)
        string combinedLabel = map.contains(priceLabels, cwlRounded) ? map.get(priceLabels, cwlRounded) : "CWL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cwl, format.mintick) + ")" : combinedLabel
        if na(lineCWL)
            lineCWL := line.new(startBar, cwl, bar_index, cwl, color=colorCWL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCWL := label.new(bar_index, cwl, labelText, color=labelBgColor(colorCWL), textcolor=colorCWL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCWL, startBar, cwl), line.set_xy2(lineCWL, bar_index, cwl)
            label.set_xy(labelCWL, bar_index, cwl), label.set_text(labelCWL, labelText)
        array.push(renderedPrices, cwlRounded)
    else if not na(lineCWL)
        line.delete(lineCWL), lineCWL := na, label.delete(labelCWL), labelCWL := na

    // CML
    if showKeyLevelsCondition and showCML and not na(cml) and isWithinATR(cml, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cmlRounded)
        string combinedLabel = map.contains(priceLabels, cmlRounded) ? map.get(priceLabels, cmlRounded) : "CML"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cml, format.mintick) + ")" : combinedLabel
        if na(lineCML)
            lineCML := line.new(startBar, cml, bar_index, cml, color=colorCML, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCML := label.new(bar_index, cml, labelText, color=labelBgColor(colorCML), textcolor=colorCML, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCML, startBar, cml), line.set_xy2(lineCML, bar_index, cml)
            label.set_xy(labelCML, bar_index, cml), label.set_text(labelCML, labelText)
        array.push(renderedPrices, cmlRounded)
    else if not na(lineCML)
        line.delete(lineCML), lineCML := na, label.delete(labelCML), labelCML := na

    // CDH
    if showKeyLevelsCondition and showCDH and not na(cdh) and isWithinATR(cdh, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cdhRounded)
        string combinedLabel = map.contains(priceLabels, cdhRounded) ? map.get(priceLabels, cdhRounded) : "CDH"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cdh, format.mintick) + ")" : combinedLabel
        if na(lineCDH)
            lineCDH := line.new(startBar, cdh, bar_index, cdh, color=colorCDH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCDH := label.new(bar_index, cdh, labelText, color=labelBgColor(colorCDH), textcolor=colorCDH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCDH, startBar, cdh), line.set_xy2(lineCDH, bar_index, cdh)
            label.set_xy(labelCDH, bar_index, cdh), label.set_text(labelCDH, labelText)
        array.push(renderedPrices, cdhRounded)
    else if not na(lineCDH)
        line.delete(lineCDH), lineCDH := na, label.delete(labelCDH), labelCDH := na

    // CDL
    if showKeyLevelsCondition and showCDL and not na(cdl) and isWithinATR(cdl, close, atrThreshold, useATRFilter) and not array.includes(renderedPrices, cdlRounded)
        string combinedLabel = map.contains(priceLabels, cdlRounded) ? map.get(priceLabels, cdlRounded) : "CDL"
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(cdl, format.mintick) + ")" : combinedLabel
        if na(lineCDL)
            lineCDL := line.new(startBar, cdl, bar_index, cdl, color=colorCDL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelCDL := label.new(bar_index, cdl, labelText, color=labelBgColor(colorCDL), textcolor=colorCDL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineCDL, startBar, cdl), line.set_xy2(lineCDL, bar_index, cdl)
            label.set_xy(labelCDL, bar_index, cdl), label.set_text(labelCDL, labelText)
        array.push(renderedPrices, cdlRounded)
    else if not na(lineCDL)
        line.delete(lineCDL), lineCDL := na, label.delete(labelCDL), labelCDL := na
