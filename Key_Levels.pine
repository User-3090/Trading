// MIT License
//
// Copyright (c) 2025 User-3090
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//@version=6
indicator("Key Levels", overlay=true, max_lines_count=500, max_boxes_count=100, max_labels_count=200)

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIME CONSTANTS
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const int MS_PER_MINUTE = 60000
const int MS_PER_HOUR = 3600000
const int MS_PER_DAY = 86400000

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS â€” PREMIUM PANEL (GROUPING/ORDER ONLY; RUNTIME LOGIC UNCHANGED)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

showSessionMarkers = input.bool(true, "Enable Session Features", group="ğŸ•’ Sessions â€¢ General", tooltip="Master switch for all session features")

showSessionLabels = input.bool(true, "Enable Anchor Labels", group="ğŸ•’ Sessions â€¢ General", tooltip="Show VWAP anchor labels")
compactLabels = input.bool(true, "Compact Anchor Labels", group="ğŸ•’ Sessions â€¢ General", tooltip="Abbreviated labels (D1/W1 vs full)")
anchorLabelSize = input.string("Normal", "Anchor Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="ğŸ•’ Sessions â€¢ General", tooltip="Label size for session anchor labels")
longTermAnchorSession = input.string("Auto", "Primary Anchor Session", options=["Auto", "Globex", "Sydney", "Tokyo", "London", "New York"], group="ğŸ•’ Sessions â€¢ General", tooltip="Session for weekly/monthly/yearly anchors")
rthOnlyForStocks = input.bool(true, "RTH Only for NY Sessions (Stocks)", group="ğŸ•’ Sessions â€¢ General", tooltip="Stocks: filter NY to RTH 9:30-4:00 ET")
rthOnlyForIndices = input.bool(false, "RTH Only for NY Sessions (Indices)", group="ğŸ•’ Sessions â€¢ General", tooltip="Index futures: filter NY to RTH 9:30-4:00 ET")

showSessionVWAP = input.bool(true, "Enable Daily VWAP Anchors", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Show daily session VWAPs")

longTermAnchorSessionMaxTimeframe = input.string("30m", "Max Timeframe (Primary)", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Hide primary session above this TF")
otherSessionsMaxTimeframe = input.string("5m", "Max Timeframe (Other)", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Hide other sessions above this TF")

sessionVWAPLineStyleInput = input.string("Dotted", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="VWAP line style")
sessionVWAPLineWidth = input.int(3, "Line Width", minval=1, maxval=5, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="VWAP line width")
sessionVWAPLineStyle = sessionVWAPLineStyleInput == "Solid" ? plot.linestyle_solid : sessionVWAPLineStyleInput == "Dashed" ? plot.linestyle_dashed : plot.linestyle_dotted

// Stock-specific session settings
enableGlobexStock = input.bool(false, "Globex", inline="SS_GLX_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorGlobexStock = input.color(#4CAF50, "", inline="SS_GLX_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorGlobexStockEnd = input.color(#3FA8A8, "", inline="SS_GLX_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
globexVWAPCountStock = input.int(1, "History", inline="SS_GLX_STK", minval=1, maxval=5, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Daily Globex anchors count")

enableSydneyStock = input.bool(false, "Sydney", inline="SS_SYD_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorSydneyStock = input.color(#800080, "", inline="SS_SYD_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorSydneyStockEnd = input.color(#6E0080, "", inline="SS_SYD_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
sydneyVWAPCountStock = input.int(1, "History", inline="SS_SYD_STK", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Daily Sydney anchors count")

enableTokyoStock = input.bool(false, "Tokyo", inline="SS_TKY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorTokyoStock = input.color(#FF0000, "", inline="SS_TKY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorTokyoStockEnd = input.color(#FF0080, "", inline="SS_TKY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
tokyoVWAPCountStock = input.int(1, "History", inline="SS_TKY_STK", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Daily Tokyo anchors count")

enableLondonStock = input.bool(false, "London", inline="SS_LON_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorLondonStock = input.color(#FFA500, "", inline="SS_LON_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorLondonStockEnd = input.color(#FF8A3F, "", inline="SS_LON_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
londonVWAPCountStock = input.int(1, "History", inline="SS_LON_STK", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Daily London anchors count")

enableNewYorkStock = input.bool(true, "New York", inline="SS_NY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorNewYorkStock = input.color(#0000FF, "", inline="SS_NY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorNewYorkStockEnd = input.color(#0080FF, "", inline="SS_NY_STK", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
nyVWAPCountStock = input.int(3, "History", inline="SS_NY_STK", minval=1, maxval=5, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Daily NY anchors count")



// Non-stock (futures, crypto, etc.) session settings
enableGlobex = input.bool(true, "Globex", inline="SS_GLX", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorGlobex = input.color(#4CAF50, "", inline="SS_GLX", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorGlobexEnd = input.color(#3FA8A8, "", inline="SS_GLX", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
globexVWAPCount = input.int(3, "History", inline="SS_GLX", minval=1, maxval=5, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Daily Globex anchors count")

enableSydney = input.bool(false, "Sydney", inline="SS_SYD", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorSydney = input.color(#800080, "", inline="SS_SYD", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorSydneyEnd = input.color(#6E0080, "", inline="SS_SYD", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
sydneyVWAPCount = input.int(1, "History", inline="SS_SYD", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Daily Sydney anchors count")

enableTokyo = input.bool(false, "Tokyo", inline="SS_TKY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorTokyo = input.color(#FF0000, "", inline="SS_TKY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorTokyoEnd = input.color(#FF0080, "", inline="SS_TKY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
tokyoVWAPCount = input.int(1, "History", inline="SS_TKY", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Daily Tokyo anchors count")

enableLondon = input.bool(true, "London", inline="SS_LON", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorLondon = input.color(#FFA500, "", inline="SS_LON", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorLondonEnd = input.color(#FF8A3F, "", inline="SS_LON", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
londonVWAPCount = input.int(1, "History", inline="SS_LON", minval=1, maxval=1, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Daily London anchors count")

enableNewYork = input.bool(true, "New York", inline="SS_NY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorNewYork = input.color(#0000FF, "", inline="SS_NY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorNewYorkEnd = input.color(#0080FF, "", inline="SS_NY", group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
nyVWAPCount = input.int(2, "History", inline="SS_NY", minval=1, maxval=5, group="ğŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Daily NY anchors count")



// Select which settings to use based on symbol type
bool isStock = syminfo.type == "stock"
bool enableGlobexActive = isStock ? enableGlobexStock : enableGlobex
color colorGlobexActive = isStock ? colorGlobexStock : colorGlobex
color colorGlobexActiveEnd = isStock ? colorGlobexStockEnd : colorGlobexEnd
int globexVWAPCountActive = isStock ? globexVWAPCountStock : globexVWAPCount
bool enableSydneyActive = isStock ? enableSydneyStock : enableSydney
color colorSydneyActive = isStock ? colorSydneyStock : colorSydney
color colorSydneyActiveEnd = isStock ? colorSydneyStockEnd : colorSydneyEnd
int sydneyVWAPCountActive = isStock ? sydneyVWAPCountStock : sydneyVWAPCount
bool enableTokyoActive = isStock ? enableTokyoStock : enableTokyo
color colorTokyoActive = isStock ? colorTokyoStock : colorTokyo
color colorTokyoActiveEnd = isStock ? colorTokyoStockEnd : colorTokyoEnd
int tokyoVWAPCountActive = isStock ? tokyoVWAPCountStock : tokyoVWAPCount
bool enableLondonActive = isStock ? enableLondonStock : enableLondon
color colorLondonActive = isStock ? colorLondonStock : colorLondon
color colorLondonActiveEnd = isStock ? colorLondonStockEnd : colorLondonEnd
int londonVWAPCountActive = isStock ? londonVWAPCountStock : londonVWAPCount
bool enableNewYorkActive = isStock ? enableNewYorkStock : enableNewYork
color colorNewYorkActive = isStock ? colorNewYorkStock : colorNewYork
color colorNewYorkActiveEnd = isStock ? colorNewYorkStockEnd : colorNewYorkEnd
int nyVWAPCountActive = isStock ? nyVWAPCountStock : nyVWAPCount

showWeeklyAnchorVWAP = input.bool(true, "Enable Weekly VWAP Anchor", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Show weekly VWAP anchors")
weeklyAnchorMaxTimeframe = input.string("2h", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Hide above this TF")
colorWeeklyAnchor = input.color(#B01200, "Color", inline="WK_COL", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly")
colorWeeklyAnchorEnd = input.color(#8A0080, "", inline="WK_COL", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly")
weeklyAnchorCount = input.int(6, "History", minval=1, maxval=6, group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Weeks to show (1=current only)")

showMonthlyAnchorVWAP = input.bool(true, "Enable Monthly VWAP Anchor", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly")
monthlyAnchorMinTimeframe = input.string("4h", "Min Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Show above this TF")
monthlyAnchorMaxTimeframe = input.string("1D", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Hide above this TF")
colorMonthlyAnchor = input.color(#3B5BFF, "Color", inline="MN_COL", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly")
colorMonthlyAnchorEnd = input.color(#8E91A6, "", inline="MN_COL", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly")
monthlyAnchorCount = input.int(6, "History", minval=1, maxval=6, group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Months to show (1=current only)")

showYearlyAnchorVWAP = input.bool(true, "Enable Yearly VWAP Anchor", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly")
yearlyAnchorMinTimeframe = input.string("15m", "Min Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W", "1M"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Show above this TF")
yearlyAnchorMaxTimeframe = input.string("1W", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W", "1M"], group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Hide above this TF")
colorYearlyAnchor = input.color(#000000, "Color", inline="YR_COL", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly")
colorYearlyAnchorEnd = input.color(#7F4D7F, "", inline="YR_COL", group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly")
yearlyAnchorCount = input.int(2, "History", minval=1, maxval=2, group="ğŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Years to show (1=current only)")


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ Levels â€¢ Global Settings
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
globalShowPriceValues = input.bool(false, "Show Prices in Level Labels", group="ğŸ“ Levels â€¢ Global Settings", tooltip="Include price values in labels")

useATRFilter = input.bool(true, "Hide Distant Levels", group="ğŸ“ Levels â€¢ Global Settings", tooltip="Show levels within ATR range only")
atrMultiplier = input.float(1.5, "Distance (ATR)", minval=1.0, maxval=10.0, step=0.5, group="ğŸ“ Levels â€¢ Global Settings", tooltip="Max ATR distance from price")
atrPeriod = input.int(20, "ATR Period (Days)", minval=1, maxval=500, group="ğŸ“ Levels â€¢ Global Settings", tooltip="Daily ATR lookback period")

globalLabelSize = input.string("Normal", "Level Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="ğŸ“ Levels â€¢ Global Settings", tooltip="Label size for all level lines")
globalLineLengthBars = input.int(50, "Line Length (Bars)", minval=10, maxval=200, group="ğŸ“ Levels â€¢ Global Settings", tooltip="Bars back for Fixed mode (max 200)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ Levels â€¢ Session â€¢ Visibility
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showSessionLevelsInput = input.string("Futures Only", "Enable Session Levels", options=["Always", "Futures Only", "Off"], group="ğŸ“ Levels â€¢ Session â€¢ Visibility", tooltip="Open/ORB/IB levels visibility")
sessionLevelsMaxTimeframe = input.string("5m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ“ Levels â€¢ Session â€¢ Visibility", tooltip="Hide above this TF")
sessionLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“ Levels â€¢ Session â€¢ Visibility")
sessionLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ“ Levels â€¢ Session â€¢ Visibility", tooltip="Line width for session levels")
sessionLineStartMode = input.string("Level Established", "Line Start", options=["Session Open", "Level Established", "Fixed Bars Back"], group="ğŸ“ Levels â€¢ Session â€¢ Visibility", tooltip="Line start point mode")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ Levels â€¢ Session â€¢ Opening Price
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showOpenPrice = input.bool(true, "Enable Opening Price", group="ğŸ“ Levels â€¢ Session â€¢ Opening Price")
colorOpenPrice = input.color(#fbbe30, "Color", group="ğŸ“ Levels â€¢ Session â€¢ Opening Price", tooltip="First bar open price")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showOpenRange = input.bool(true, "Enable Opening Range (ORB)", group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)", tooltip="First 15-30min high/low")
openRangeLength = input.string("15m", "Length", options=["15m", "30m"], group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)")
colorORH = input.color(#4682b4, "High", inline="SL_ORC", group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)")
colorORL = input.color(#cd5c5c, "Low", inline="SL_ORC", group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)")
shadeOpenRange = input.bool(true, "Shade", inline="SL_ORC", group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)")
colorOpenRangeShade = input.color(color.new(color.black, 98), "", inline="SL_ORC", group="ğŸ“ Levels â€¢ Session â€¢ Opening Range (ORB)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showInitialBalance = input.bool(false, "Enable Initial Balance (IB)", group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)", tooltip="First 30-60min high/low")
initialBalanceLength = input.string("1h", "Length", options=["30m", "1h"], group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)")
colorIBH = input.color(#81ce6f, "High", inline="SL_IBC", group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)")
colorIBL = input.color(#e43b38, "Low", inline="SL_IBC", group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)")
shadeInitialBalance = input.bool(true, "Shade", inline="SL_IBC", group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)")
colorInitialBalanceShade = input.color(color.new(color.green, 95), "", inline="SL_IBC", group="ğŸ“ Levels â€¢ Session â€¢ Initial Balance (IB)")



showPivots = input.bool(true, "Enable Pivot Points", group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Traditional pivots from prev day HLC")
pivotMaxTimeframe = input.string("4h", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ“ Levels â€¢ Pivot Points", tooltip="Hide above this TF")
pivotLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“ Levels â€¢ Pivot Points")
pivotLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ“ Levels â€¢ Pivot Points")

showPivotR3 = input.bool(true, "R3", inline="PV_R3", group="ğŸ“ Levels â€¢ Pivot Points")
pivotColorR3 = input.color(#449955, "", inline="PV_R3", group="ğŸ“ Levels â€¢ Pivot Points")
showPivotR2 = input.bool(true, "R2", inline="PV_R2", group="ğŸ“ Levels â€¢ Pivot Points")
pivotColorR2 = input.color(#449955, "", inline="PV_R2", group="ğŸ“ Levels â€¢ Pivot Points")
showPivotR1 = input.bool(false, "R1", inline="PV_R1", group="ğŸ“ Levels â€¢ Pivot Points")
pivotColorR1 = input.color(#449955, "", inline="PV_R1", group="ğŸ“ Levels â€¢ Pivot Points")

showPivotP = input.bool(false, "Pivot (P)", inline="PV_P", group="ğŸ“ Levels â€¢ Pivot Points")
pivotColorP = input.color(#808080, "", inline="PV_P", group="ğŸ“ Levels â€¢ Pivot Points")

showPivotS1 = input.bool(false, "S1", inline="PV_S1", group="ğŸ“ Levels â€¢ Pivot Points")
pivotColorS1 = input.color(#b51b00, "", inline="PV_S1", group="ğŸ“ Levels â€¢ Pivot Points")
showPivotS2 = input.bool(true, "S2", inline="PV_S2", group="ğŸ“ Levels â€¢ Pivot Points")
pivotColorS2 = input.color(#b51b00, "", inline="PV_S2", group="ğŸ“ Levels â€¢ Pivot Points")
showPivotS3 = input.bool(true, "S3", inline="PV_S3", group="ğŸ“ Levels â€¢ Pivot Points")
pivotColorS3 = input.color(#b51b00, "", inline="PV_S3", group="ğŸ“ Levels â€¢ Pivot Points")



showKeyLevels = input.bool(true, "Enable Key Levels", group="ğŸ“ Levels â€¢ Key Levels", tooltip="ATH/Year/Month/Week/Day high/low")
keyLevelsMaxTimeframe = input.string("15m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ğŸ“ Levels â€¢ Key Levels", tooltip="Hide above this TF")
keyLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ğŸ“ Levels â€¢ Key Levels")
keyLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ğŸ“ Levels â€¢ Key Levels")

showATH = input.bool(true, "All-Time High", inline="KL_ATH", group="ğŸ“ Levels â€¢ Key Levels â€¢ All-Time High")
colorATH = input.color(#00fcff, "Color", inline="KL_ATH", group="ğŸ“ Levels â€¢ Key Levels â€¢ All-Time High")

showCYH = input.bool(true, "Current", inline="KL_CY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
colorCYH = input.color(#449955, "High", inline="KL_CY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
showCYL = input.bool(true, "", inline="KL_CY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
colorCYL = input.color(#b51b00, "Low", inline="KL_CY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")

showPYH = input.bool(true, "Previous", inline="KL_PY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
colorPYH = input.color(#449955, "High", inline="KL_PY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
showPYL = input.bool(true, "", inline="KL_PY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")
colorPYL = input.color(#b51b00, "Low", inline="KL_PY", group="ğŸ“ Levels â€¢ Key Levels â€¢ Year")

showCMH = input.bool(true, "Current", inline="KL_CM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
colorCMH = input.color(#449955, "High", inline="KL_CM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
showCML = input.bool(true, "", inline="KL_CM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
colorCML = input.color(#b51b00, "Low", inline="KL_CM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")

showPMH = input.bool(true, "Previous", inline="KL_PM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
colorPMH = input.color(#449955, "High", inline="KL_PM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
showPML = input.bool(true, "", inline="KL_PM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")
colorPML = input.color(#b51b00, "Low", inline="KL_PM", group="ğŸ“ Levels â€¢ Key Levels â€¢ Month")

showCWH = input.bool(true, "Current", inline="KL_CW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
colorCWH = input.color(#449955, "High", inline="KL_CW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
showCWL = input.bool(true, "", inline="KL_CW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
colorCWL = input.color(#b51b00, "Low", inline="KL_CW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")

showPWH = input.bool(true, "Previous", inline="KL_PW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
colorPWH = input.color(#449955, "High", inline="KL_PW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
showPWL = input.bool(true, "", inline="KL_PW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")
colorPWL = input.color(#b51b00, "Low", inline="KL_PW", group="ğŸ“ Levels â€¢ Key Levels â€¢ Week")

showCDH = input.bool(true, "Current", inline="KL_CD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
colorCDH = input.color(#449955, "High", inline="KL_CD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
showCDL = input.bool(true, "", inline="KL_CD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
colorCDL = input.color(#b51b00, "Low", inline="KL_CD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")

showPDH = input.bool(true, "Previous", inline="KL_PD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
colorPDH = input.color(#449955, "High", inline="KL_PD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
showPDL = input.bool(true, "", inline="KL_PD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")
colorPDL = input.color(#b51b00, "Low", inline="KL_PD", group="ğŸ“ Levels â€¢ Key Levels â€¢ Day")



// HELPER FUNCTIONS


getLabelSize(string sizeStr) =>
    sizeStr == "Tiny" ? size.tiny : sizeStr == "Small" ? size.small : sizeStr == "Large" ? size.large : sizeStr == "Huge" ? size.huge : size.normal

getLineStyle(string styleStr) =>
    styleStr == "Solid" ? line.style_solid : styleStr == "Dashed" ? line.style_dashed : line.style_dotted

labelBgColor(color c) => color.new(c, 100)

roundToTick(float price) =>
    syminfo.mintick > 0 ? math.round(price / syminfo.mintick) * syminfo.mintick : price

priceToTicks(float price) =>
    syminfo.mintick > 0 ? int(math.round(price / syminfo.mintick)) : int(price)

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HOLIDAY HANDLING
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var array<int> stockFullHolidays = array.from(20250101,20250120,20250217,20250418,20250526,20250619,20250704,20250901,20251127,20251225,20260101,20260119,20260216,20260403,20260525,20260619,20260703,20260907,20261126,20261225,20270101,20270118,20270215,20270326,20270531,20270618,20270705,20270906,20271125,20271224,20280117,20280221,20280414,20280529,20280619,20280704,20280904,20281123,20281225)
var array<int> stockEarlyClose = array.from(20250703,20251128,20251224,20261127,20261224,20271126,20280703,20281124)
var array<int> futuresFullHolidays = array.from(20250101,20250120,20250217,20250418,20250526,20250619,20250704,20250901,20251013,20251111,20251127,20251225,20260101,20260119,20260216,20260403,20260525,20260619,20260703,20260907,20261012,20261111,20261126,20261225)
var array<int> futuresEarlyClose = array.from(20250417,20250523,20250703,20251128,20251224,20251231,20260402,20260522,20260702,20261127,20261224)

timestampToYYYYMMDD(int ts, string tz) =>
    int y = year(ts, tz)
    int m = month(ts, tz)
    int d = dayofmonth(ts, tz)
    y * 10000 + m * 100 + d

isFullHoliday(int ts, string tz, bool isStock) =>
    int dateInt = timestampToYYYYMMDD(ts, tz)
    array<int> holidays = isStock ? stockFullHolidays : futuresFullHolidays
    array.includes(holidays, dateInt)

isEarlyClose(int ts, string tz, bool isStock) =>
    int dateInt = timestampToYYYYMMDD(ts, tz)
    array<int> earlyCloses = isStock ? stockEarlyClose : futuresEarlyClose
    array.includes(earlyCloses, dateInt)

isTradingDay(int ts, string tz, string session, bool isStock) =>
    int dow = dayofweek(ts, tz)
    bool isWeekday = session == "Globex" ? (dow == dayofweek.sunday or (dow >= dayofweek.monday and dow <= dayofweek.friday)) : (dow >= dayofweek.monday and dow <= dayofweek.friday)
    isWeekday and not isFullHoliday(ts, tz, isStock)

updateBox(box boxRef, int x1, float y1, int x2, float y2, color bg) =>
    if na(boxRef)
        box.new(x1, y1, x2, y2, border_color=na, bgcolor=bg)
    else
        box.set_lefttop(boxRef, x1, y1)
        box.set_rightbottom(boxRef, x2, y2)
        boxRef

// RGB to HSL conversion
rgbToHsl(float r, float g, float b) =>
    float rNorm = r / 255.0
    float gNorm = g / 255.0
    float bNorm = b / 255.0

    float maxVal = math.max(rNorm, math.max(gNorm, bNorm))
    float minVal = math.min(rNorm, math.min(gNorm, bNorm))
    float delta = maxVal - minVal

    float h = 0.0
    float s = 0.0
    float l = (maxVal + minVal) / 2.0

    if delta != 0
        s := l > 0.5 ? delta / (2.0 - maxVal - minVal) : delta / (maxVal + minVal)

        if maxVal == rNorm
            h := ((gNorm - bNorm) / delta + (gNorm < bNorm ? 6.0 : 0.0)) / 6.0
        else if maxVal == gNorm
            h := ((bNorm - rNorm) / delta + 2.0) / 6.0
        else
            h := ((rNorm - gNorm) / delta + 4.0) / 6.0

    [h, s, l]

// HSL to RGB conversion helper
hueToRgb(float p, float q, float t) =>
    float tAdj = t < 0.0 ? t + 1.0 : (t > 1.0 ? t - 1.0 : t)
    float result = tAdj < 1.0/6.0 ? p + (q - p) * 6.0 * tAdj :
                  (tAdj < 1.0/2.0 ? q :
                  (tAdj < 2.0/3.0 ? p + (q - p) * (2.0/3.0 - tAdj) * 6.0 : p))
    result

// HSL to RGB conversion
hslToRgb(float h, float s, float l) =>
    if s == 0
        [int(l * 255.0), int(l * 255.0), int(l * 255.0)]
    else
        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s
        float p = 2.0 * l - q
        [int(hueToRgb(p, q, h + 1.0/3.0) * 255.0), int(hueToRgb(p, q, h) * 255.0), int(hueToRgb(p, q, h - 1.0/3.0) * 255.0)]

// Check if level price is within ATR distance from current price
isWithinATR(float levelPrice, float currentPrice, float threshold, bool filterEnabled) =>
    not filterEnabled or na(levelPrice) or math.abs(levelPrice - currentPrice) <= threshold

// Get compact session abbreviation for daily sessions
getSessionAbbr(string sessionName) =>
    sessionName == "London" ? "LN" : sessionName == "New York" ? "NY" : sessionName == "Globex" ? "GLX" : sessionName == "Sydney" ? "SYD" : "TKY"

// LEVEL RENDERER UDT

type LevelRenderer
    string name
    bool enabled
    float price
    int priceTicks
    int startBar
    color levelColor
    int lineWidth
    string lineStyle
    line lineRef
    label labelRef

addLevel(array<LevelRenderer> arr, string name, bool show, float price, int priceTicks, int startBar, color col, int width, string style) =>
    array.push(arr, LevelRenderer.new(name, show, price, priceTicks, startBar, col, width, style, na, na))

// Render method for a single level with deduplication support
method render(LevelRenderer this, bool groupCondition, bool checkDuplicate, map<int, string> priceLabels, array<int> renderedPrices, bool globalShowPriceValues, string labelSizeActual, float atrThreshold, bool useATRFilter, bool ignoreATRFilter = false) =>
    if groupCondition and this.enabled and not na(this.price) and (ignoreATRFilter or isWithinATR(this.price, close, atrThreshold, useATRFilter)) and (not checkDuplicate or not array.includes(renderedPrices, this.priceTicks))
        string combinedLabel = map.contains(priceLabels, this.priceTicks) ? map.get(priceLabels, this.priceTicks) : this.name
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(this.price, format.mintick) + ")" : combinedLabel
        if na(this.lineRef)
            line tempLine = line.new(this.startBar, this.price, bar_index, this.price, color=this.levelColor, width=this.lineWidth, style=getLineStyle(this.lineStyle))
            label tempLabel = label.new(bar_index, this.price, labelText, color=labelBgColor(this.levelColor), textcolor=this.levelColor, style=label.style_label_left, size=labelSizeActual)
            this.lineRef := tempLine
            this.labelRef := tempLabel
            true
        else
            line.set_xy1(this.lineRef, this.startBar, this.price)
            line.set_xy2(this.lineRef, bar_index, this.price)
            label.set_xy(this.labelRef, bar_index, this.price)
            label.set_text(this.labelRef, labelText)
            true
        array.push(renderedPrices, this.priceTicks)
        true
    else if not na(this.lineRef)
        line.delete(this.lineRef)
        this.lineRef := na
        label.delete(this.labelRef)
        this.labelRef := na
        true
    else
        true

method update(LevelRenderer this, bool enabled, float price, int priceTicks, int startBar) =>
    this.enabled := enabled
    this.price := price
    this.priceTicks := priceTicks
    this.startBar := startBar
    true

deleteLabel(array<label> labelArray, int idx) =>
    label oldLabel = array.get(labelArray, idx)
    if not na(oldLabel)
        label.delete(oldLabel)



// Hue cycling interpolation between start and end colors through HSL color space
getVWAPColor(color startColor, color endColor, int positionInHistory, int maxPos) =>
    if positionInHistory == 0 or maxPos == 0
        startColor
    else
        // Interpolation factor (0.0 = start, 1.0 = end)
        float t = maxPos > 0 ? math.min(positionInHistory / float(maxPos), 1.0) : 0.0

        // Convert start color to HSL
        float r1 = color.r(startColor) / 255.0
        float g1 = color.g(startColor) / 255.0
        float b1 = color.b(startColor) / 255.0
        [h1, s1, l1] = rgbToHsl(r1 * 255.0, g1 * 255.0, b1 * 255.0)

        // Convert end color to HSL
        float r2 = color.r(endColor) / 255.0
        float g2 = color.g(endColor) / 255.0
        float b2 = color.b(endColor) / 255.0
        [h2, s2, l2] = rgbToHsl(r2 * 255.0, g2 * 255.0, b2 * 255.0)

        // Interpolate hue around color wheel (shortest path)
        float hDiff = h2 - h1
        if hDiff > 0.5
            hDiff := hDiff - 1.0
        else if hDiff < -0.5
            hDiff := hDiff + 1.0
        float h = h1 + hDiff * t
        h := h < 0.0 ? h + 1.0 : (h > 1.0 ? h - 1.0 : h)

        // Interpolate saturation and lightness
        float s = s1 + (s2 - s1) * t
        float l = l1 + (l2 - l1) * t

        // Convert back to RGB
        [newR, newG, newB] = hslToRgb(h, s, l)

        // Interpolate transparency
        float a1 = color.t(startColor)
        float a2 = color.t(endColor)
        int a = int(a1 + (a2 - a1) * t)

        color.rgb(newR, newG, newB, a)

// Session time definitions in session's local timezone
// LSE: 8:00 AM - 4:30 PM GMT
// NYSE/CME: 9:30 AM - 4:00 PM EST
// CME Globex: 6:00 PM - 5:00 PM ET (next day, spans 2 calendar days)
// ASX: 10:00 AM - 4:00 PM AEDT
// TSE: 9:00 AM - 3:00 PM JST

getSessionTimezone(string session) =>
    session == "London" ? "Europe/London" : session == "New York" ? "America/New_York" : session == "Globex" ? "America/New_York" : session == "Sydney" ? "Australia/Sydney" : "Asia/Tokyo"

getSessionStartHour(string session) =>
    session == "London" ? 8 : session == "New York" ? 9 : session == "Globex" ? 18 : session == "Sydney" ? 10 : 9

getSessionStartMinute(string session) =>
    session == "New York" ? 30 : 0

getSessionEndHour(string session) =>
    session == "London" ? 16 : session == "New York" ? 16 : session == "Globex" ? 17 : session == "Sydney" ? 16 : 15

getSessionEndMinute(string session) =>
    session == "London" ? 30 : 0

// Calculate session start timestamp for a specific date (calendar-based, pre-calculated)
getSessionStartForDate(string session, int y, int m, int d) =>
    string tz = getSessionTimezone(session)
    int sessionHour = getSessionStartHour(session)
    int sessionMinute = getSessionStartMinute(session)
    timestamp(tz, y, m, d, sessionHour, sessionMinute)

// Calculate session end timestamp for a specific date
// Note: For Globex, end is on NEXT calendar day (starts 6 PM, ends 5 PM next day)
getSessionEndForDate(string session, int y, int m, int d) =>
    string tz = getSessionTimezone(session)
    int sessionHour = getSessionEndHour(session)
    int sessionMinute = getSessionEndMinute(session)
    // Globex spans two days: starts evening, ends next afternoon
    if session == "Globex"
        // Add 24 hours in milliseconds to base timestamp instead of incrementing day
        int baseTimestamp = timestamp(tz, y, m, d, sessionHour, sessionMinute)
        baseTimestamp + MS_PER_DAY
    else
        timestamp(tz, y, m, d, sessionHour, sessionMinute)

// Common helper to collect session timestamps (start or end) for last N sessions
// CRITICAL: Collects trading days but avoids duplicate timestamps
// - Tracks each day's session timestamp
// - For Globex: Mon-Fri all map to same Sunday start, so we deduplicate
getSessionTimestampsArray(string session, int sessionsBack, bool isStart) =>
    var array<int> timestamps = array.new<int>()
    array.clear(timestamps)

    // Get session timezone to ensure date calculations are consistent
    string tz = getSessionTimezone(session)
    bool isStockType = syminfo.type == "stock"

    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    int currentD = dayofmonth(timenow, tz)
    int currentDayOfWeek = dayofweek(timenow, tz)

    // Adjust weekend to Friday; Globex trades Sunday so don't adjust Sunday for Globex
    if currentDayOfWeek == dayofweek.saturday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - MS_PER_DAY
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)
    else if currentDayOfWeek == dayofweek.sunday and session != "Globex"
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 172800000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)

    // For Globex on Mon-Fri, the session for "today" actually starts yesterday evening
    // So we need to check yesterday's session start time
    int todaySessionStart = na
    if session == "Globex" and currentDayOfWeek >= dayofweek.monday and currentDayOfWeek <= dayofweek.friday
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - MS_PER_DAY
        int prevY = year(yesterdayMidnight, tz)
        int prevM = month(yesterdayMidnight, tz)
        int prevD = dayofmonth(yesterdayMidnight, tz)
        todaySessionStart := getSessionStartForDate(session, prevY, prevM, prevD)
    else
        todaySessionStart := getSessionStartForDate(session, currentY, currentM, currentD)

    // Always start from today to include upcoming session (look-ahead)
    int mostRecentY = currentY
    int mostRecentM = currentM
    int mostRecentD = currentD

    int sessionsCollected = 0
    int daysBackOffset = 0
    int lastTimestamp = na

    while sessionsCollected < sessionsBack and daysBackOffset < 730
        int targetMidnight = timestamp(tz, mostRecentY, mostRecentM, mostRecentD, 0, 0) - (daysBackOffset * MS_PER_DAY)
        int y = year(targetMidnight, tz)
        int m = month(targetMidnight, tz)
        int d = dayofmonth(targetMidnight, tz)
        int dow = dayofweek(targetMidnight, tz)

        bool isValidTradingDay = isTradingDay(targetMidnight, tz, session, isStockType)

        if isValidTradingDay
            // For Globex: session active on day D starts evening of day D-1, EXCEPT Sunday
            int ts = na
            if session == "Globex"
                if dow == dayofweek.sunday
                    ts := isStart ? getSessionStartForDate(session, y, m, d) : getSessionEndForDate(session, y, m, d)
                else
                    int prevDayMidnight = timestamp(tz, y, m, d, 0, 0) - MS_PER_DAY
                    int prevY = year(prevDayMidnight, tz)
                    int prevM = month(prevDayMidnight, tz)
                    int prevD = dayofmonth(prevDayMidnight, tz)
                    ts := isStart ? getSessionStartForDate(session, prevY, prevM, prevD) : getSessionEndForDate(session, prevY, prevM, prevD)
            else
                ts := isStart ? getSessionStartForDate(session, y, m, d) : getSessionEndForDate(session, y, m, d)

            if na(lastTimestamp) or ts != lastTimestamp
                array.unshift(timestamps, ts)
                lastTimestamp := ts
                sessionsCollected := sessionsCollected + 1

        daysBackOffset := daysBackOffset + 1

    timestamps

getSessionStartsArray(string session, int sessionsBack) =>
    getSessionTimestampsArray(session, sessionsBack, true)

getSessionEndsArray(string session, int sessionsBack) =>
    getSessionTimestampsArray(session, sessionsBack, false)


// Find first valid trading day of a month (returns day 1-31, or na if none found in 14 days)
getFirstTradingDayOfMonth(string session, int targetYear, int targetMonth) =>
    string tz = getSessionTimezone(session)
    bool isStockType = syminfo.type == "stock"
    int foundDay = na
    for dayOffset = 0 to 13
        int testDay = dayOffset + 1
        if testDay > 31
            break
        int testTs = timestamp(tz, targetYear, targetMonth, testDay, 0, 0)
        int testYear = year(testTs, tz)
        int testMonth = month(testTs, tz)
        if testYear != targetYear or testMonth != targetMonth
            break
        bool isValidTradingDay = isTradingDay(testTs, tz, session, isStockType)
        if isValidTradingDay
            foundDay := testDay
            break
    foundDay

// Generic anchor start timestamps - handles weekly, monthly, yearly periods
getAnchorStarts(string period, string session, int count) =>
    var array<int> starts = array.new<int>()
    array.clear(starts)
    string tz = getSessionTimezone(session)
    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    int currentD = dayofmonth(timenow, tz)

    if period == "W"
        int currentDayOfWeek = dayofweek(timenow, tz)
        if currentDayOfWeek == dayofweek.saturday
            int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - MS_PER_DAY
            currentY := year(fridayMidnight, tz)
            currentM := month(fridayMidnight, tz)
            currentD := dayofmonth(fridayMidnight, tz)
        else if currentDayOfWeek == dayofweek.sunday and session != "Globex"
            int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 172800000
            currentY := year(fridayMidnight, tz)
            currentM := month(fridayMidnight, tz)
            currentD := dayofmonth(fridayMidnight, tz)
        int todaySessionStart = getSessionStartForDate(session, currentY, currentM, currentD)
        int mostRecentY = currentY
        int mostRecentM = currentM
        int mostRecentD = currentD
        if timenow < todaySessionStart
            int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - MS_PER_DAY
            mostRecentY := year(yesterdayMidnight, tz)
            mostRecentM := month(yesterdayMidnight, tz)
            mostRecentD := dayofmonth(yesterdayMidnight, tz)
        int targetDayOfWeek = session == "Globex" ? dayofweek.sunday : dayofweek.monday
        int collected = 0
        int daysBack = 0
        bool isStockType = syminfo.type == "stock"
        while collected < count and daysBack < 730
            int targetMidnight = timestamp(tz, mostRecentY, mostRecentM, mostRecentD, 0, 0) - (daysBack * 86400000)
            int y = year(targetMidnight, tz)
            int m = month(targetMidnight, tz)
            int d = dayofmonth(targetMidnight, tz)
            int dow = dayofweek(targetMidnight, tz)
            if dow == targetDayOfWeek and isTradingDay(targetMidnight, tz, session, isStockType)
                int anchorStart = getSessionStartForDate(session, y, m, d)
                array.unshift(starts, anchorStart)
                collected := collected + 1
            daysBack := daysBack + 1
    else if period == "M"
        if na(currentY) or na(currentM)
            for i = 0 to count - 1
                array.unshift(starts, na)
        else
            for i = 0 to count - 1
                int targetM = currentM - i
                int targetY = currentY
                while targetM < 1
                    targetM := targetM + 12
                    targetY := targetY - 1
                int firstDay = getFirstTradingDayOfMonth(session, targetY, targetM)
                if not na(firstDay)
                    int anchorStart = getSessionStartForDate(session, targetY, targetM, firstDay)
                    array.unshift(starts, anchorStart)
                else
                    array.unshift(starts, na)
    else if period == "Y"
        if na(currentY)
            for i = 0 to count - 1
                array.unshift(starts, na)
        else
            for i = 0 to count - 1
                int targetY = currentY - i
                int firstDay = getFirstTradingDayOfMonth(session, targetY, 1)
                if not na(firstDay)
                    int anchorStart = getSessionStartForDate(session, targetY, 1, firstDay)
                    array.unshift(starts, anchorStart)
                else
                    array.unshift(starts, na)
    starts

// Create anchor label helper
createAnchorLabel(array<label> labelArray, int idx, int anchorStart, string period, int positionInHistory, color anchorColor, color anchorColorEnd, int maxCount, string anchorTZ, string sessionName) =>
    if not na(anchorStart)
        label oldLabel = array.get(labelArray, idx)
        if not na(oldLabel)
            label.delete(oldLabel)
        color labelColor = getVWAPColor(anchorColor, anchorColorEnd, positionInHistory, maxCount - 1)
        string labelText = ""
        if period == "W"
            labelText := compactLabels ? "W" + str.tostring(positionInHistory + 1) : "Week " + str.tostring(weekofyear(anchorStart, anchorTZ)) + " (" + sessionName + ")"
        else if period == "M"
            labelText := compactLabels ? "M" + str.tostring(positionInHistory + 1) : str.format("{0,date,MMM yyyy}", anchorStart) + " (" + sessionName + ")"
        else if period == "Y"
            labelText := compactLabels ? "Y" + str.tostring(positionInHistory + 1) : str.tostring(year(anchorStart, anchorTZ)) + " (" + sessionName + ")"
        label newLabel = label.new(bar_index, high, labelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=labelColor, textcolor=color.white, size=getLabelSize(anchorLabelSize), style=label.style_label_down)
        array.set(labelArray, idx, newLabel)

// Convert period string to minutes
periodToMinutes(string period) =>
    period == "1m" ? 1 : period == "2m" ? 2 : period == "3m" ? 3 : period == "5m" ? 5 : period == "15m" ? 15 : period == "30m" ? 30 : period == "1h" ? 60 : period == "65m" ? 65 : period == "2h" ? 120 : period == "4h" ? 240 : period == "1D" ? 1440 : 99999

// Get timeframe in minutes for comparison
getTimeframeMinutes() =>
    int tfSeconds = timeframe.in_seconds()
    if tfSeconds >= 86400
        // Daily or larger timeframes return as days
        int days = tfSeconds / 86400
        days * 1440  // Convert days to minutes
    else
        tfSeconds / 60

// Add level to priceLabels map with duplicate detection
addToMap(map<int, string> priceMap, float price, string label) =>
    int key = priceToTicks(price)
    string existing = map.contains(priceMap, key) ? map.get(priceMap, key) : ""
    if existing != ""
        map.put(priceMap, key, existing + "/" + label)
    else
        map.put(priceMap, key, label)

// DISPLAY CONDITIONS & ATR FILTERING

float atrValue = request.security(syminfo.tickerid, "D", ta.atr(atrPeriod), lookahead=barmerge.lookahead_on)
float atrThreshold = atrValue * atrMultiplier

bool isFutures = syminfo.type == "futures"

// Check timeframe conditions
int currentTfMinutes = getTimeframeMinutes()
bool meetsMaxTimeframe = keyLevelsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(keyLevelsMaxTimeframe)

// Check if key levels should be shown (max timeframe filter only)
bool showKeyLevelsCondition = showKeyLevels and meetsMaxTimeframe

// Determine primary session name (used for long-term anchor and primary session logic)
string primarySessionName = longTermAnchorSession == "Auto" ? (syminfo.type == "stock" ? "New York" : "Globex") : longTermAnchorSession

// Check timeframe conditions for session features
bool meetsOtherSessionsTimeframe = otherSessionsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(otherSessionsMaxTimeframe)
bool meetsLongTermAnchorSessionTimeframe = longTermAnchorSessionMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(longTermAnchorSessionMaxTimeframe)
bool sessionBaseCondition = showSessionMarkers
bool showSessionMarkersCondition = sessionBaseCondition and meetsOtherSessionsTimeframe

// Individual session VWAP timeframe checks (long-term anchor session gets extended visibility, others are intraday-only)
bool meetsLondonVWAPTimeframe = primarySessionName == "London" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsNYVWAPTimeframe = primarySessionName == "New York" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsGlobexVWAPTimeframe = primarySessionName == "Globex" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsSydneyVWAPTimeframe = primarySessionName == "Sydney" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsTokyoVWAPTimeframe = primarySessionName == "Tokyo" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe

// Check timeframe conditions for session levels and pivot features
bool meetsSessionLevelsMaxTimeframe = sessionLevelsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(sessionLevelsMaxTimeframe)
bool meetsPivotMaxTimeframe = pivotMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(pivotMaxTimeframe)
bool showPivotsCondition = showPivots and meetsPivotMaxTimeframe

// NY session filter for stocks and equity indices (RTH = 9:30 AM - 4:00 PM ET, bars before 4:00 PM)
int nyHour = hour(time, "America/New_York")
int nyMinute = minute(time, "America/New_York")
int nyDayOfWeek = dayofweek(time, "America/New_York")
bool isWeekday = nyDayOfWeek >= dayofweek.monday and nyDayOfWeek <= dayofweek.friday
bool isNYSession = isWeekday and ((nyHour == 9 and nyMinute >= 30) or (nyHour > 9 and nyHour < 16))
bool isEquityIndex = syminfo.type == "futures" and (str.contains(syminfo.ticker, "ES") or str.contains(syminfo.ticker, "MES") or str.contains(syminfo.ticker, "NQ") or str.contains(syminfo.ticker, "MNQ") or str.contains(syminfo.ticker, "RTY") or str.contains(syminfo.ticker, "M2K") or str.contains(syminfo.ticker, "YM") or str.contains(syminfo.ticker, "MYM"))
bool shouldFilterRTH = (rthOnlyForStocks and syminfo.type == "stock") or (rthOnlyForIndices and isEquityIndex)
bool isRTHBar = not shouldFilterRTH or isNYSession

// Check timeframe condition for weekly anchors
bool meetsWeeklyAnchorMaxTimeframe = weeklyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(weeklyAnchorMaxTimeframe)
bool meetsMonthlyAnchorMinTimeframe = monthlyAnchorMinTimeframe == "None" or currentTfMinutes >= periodToMinutes(monthlyAnchorMinTimeframe)
bool meetsMonthlyAnchorMaxTimeframe = monthlyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(monthlyAnchorMaxTimeframe)
bool meetsMonthlyAnchorTimeframe = meetsMonthlyAnchorMinTimeframe and meetsMonthlyAnchorMaxTimeframe
bool meetsYearlyAnchorMinTimeframe = yearlyAnchorMinTimeframe == "None" or currentTfMinutes >= periodToMinutes(yearlyAnchorMinTimeframe)
bool meetsYearlyAnchorMaxTimeframe = yearlyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(yearlyAnchorMaxTimeframe)
bool meetsYearlyAnchorTimeframe = meetsYearlyAnchorMinTimeframe and meetsYearlyAnchorMaxTimeframe

// KEY LEVELS DATA - Conditional requests for performance
var float pdh = na, var float pdl = na
var float pwh = na, var float pwl = na
var float pmh = na, var float pml = na
var float pyh = na, var float pyl = na

// Current period levels (developing periods)
var float cdh = na, var float cdl = na
var float cwh = na, var float cwl = na
var float cmh = na, var float cml = na
var float cyh = na, var float cyl = na

// Fetch previous and current period levels in single calls
if barstate.isconfirmed and showKeyLevelsCondition and (showPDH or showPDL or showCDH or showCDL)
    [_pdh, _pdl, _cdh, _cdl] = request.security(syminfo.tickerid, "D", [high[1], low[1], high, low], lookahead=barmerge.lookahead_on)
    pdh := _pdh, pdl := _pdl, cdh := _cdh, cdl := _cdl
else if showKeyLevelsCondition and (showCDH or showCDL)
    [_cdh, _cdl] = request.security(syminfo.tickerid, "D", [high, low], lookahead=barmerge.lookahead_on)
    cdh := _cdh, cdl := _cdl

if barstate.isconfirmed and showKeyLevelsCondition and (showPWH or showPWL or showCWH or showCWL)
    [_pwh, _pwl, _cwh, _cwl] = request.security(syminfo.tickerid, "W", [high[1], low[1], high, low], lookahead=barmerge.lookahead_on)
    pwh := _pwh, pwl := _pwl, cwh := _cwh, cwl := _cwl
else if showKeyLevelsCondition and (showCWH or showCWL)
    [_cwh, _cwl] = request.security(syminfo.tickerid, "W", [high, low], lookahead=barmerge.lookahead_on)
    cwh := _cwh, cwl := _cwl

if barstate.isconfirmed and showKeyLevelsCondition and (showPMH or showPML or showCMH or showCML)
    [_pmh, _pml, _cmh, _cml] = request.security(syminfo.tickerid, "M", [high[1], low[1], high, low], lookahead=barmerge.lookahead_on)
    pmh := _pmh, pml := _pml, cmh := _cmh, cml := _cml
else if showKeyLevelsCondition and (showCMH or showCML)
    [_cmh, _cml] = request.security(syminfo.tickerid, "M", [high, low], lookahead=barmerge.lookahead_on)
    cmh := _cmh, cml := _cml

if barstate.isconfirmed and showKeyLevelsCondition and (showPYH or showPYL or showCYH or showCYL)
    [_pyh, _pyl, _cyh, _cyl] = request.security(syminfo.tickerid, "12M", [high[1], low[1], high, low], lookahead=barmerge.lookahead_on)
    pyh := _pyh, pyl := _pyl, cyh := _cyh, cyl := _cyl
else if showKeyLevelsCondition and (showCYH or showCYL)
    [_cyh, _cyl] = request.security(syminfo.tickerid, "12M", [high, low], lookahead=barmerge.lookahead_on)
    cyh := _cyh, cyl := _cyl

var float ath = na
if showKeyLevelsCondition and showATH
    ath := na(ath) ? high : math.max(ath, high)

// PIVOT POINTS (from previous day's HLC)
var float dailyHigh = na, var float dailyLow = na, var float dailyClose = na
if barstate.isconfirmed
    [_dailyHigh, _dailyLow, _dailyClose] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    dailyHigh := _dailyHigh
    dailyLow := _dailyLow
    dailyClose := _dailyClose

float dailyRange = dailyHigh - dailyLow
float pivotP = (dailyHigh + dailyLow + dailyClose) / 3
float pivotR1 = 2 * pivotP - dailyLow
float pivotS1 = 2 * pivotP - dailyHigh
float pivotR2 = pivotP + dailyRange
float pivotS2 = pivotP - dailyRange
float pivotR3 = dailyHigh + 2 * (pivotP - dailyLow)
float pivotS3 = dailyLow - 2 * (dailyHigh - pivotP)

var array<LevelRenderer> keyLevels = array.new<LevelRenderer>()
var array<LevelRenderer> pivotLevels = array.new<LevelRenderer>()
var array<LevelRenderer> sessionLevels = array.new<LevelRenderer>()

// MULTI-SESSION INFRASTRUCTURE

const int MAX_VWAP_HISTORY = 10
const int MAX_WEEKLY_HISTORY = 6
const int MAX_MONTHLY_HISTORY = 6
const int MAX_YEARLY_HISTORY = 2

type SessionManager
    string name
    bool enabled
    color col
    color colEnd
    int historyCount
    array<int> starts
    array<int> ends
    array<int> startBars
    array<float> sumSrc
    array<float> sumVol
    array<float> vwaps
    array<label> labels
    int prevMostRecentStart
    bool meetsTimeframe
    array<color> preCalcColors

// Shift session VWAP arrays left when new session detected
shiftSessionArrays(array<int> oldStarts, array<int> newStarts, array<int> startBars, array<float> sumSrc, array<float> sumVol, array<float> vwaps) =>
    array<int> tempStartBars = array.new<int>(MAX_VWAP_HISTORY, na)
    for oldIdx = 0 to MAX_VWAP_HISTORY - 1
        int oldSessionTime = array.get(oldStarts, oldIdx)
        int oldBarIdx = array.get(startBars, oldIdx)
        if not na(oldSessionTime) and not na(oldBarIdx)
            for newIdx = 0 to MAX_VWAP_HISTORY - 1
                int newSessionTime = array.get(newStarts, newIdx)
                if newSessionTime == oldSessionTime
                    array.set(tempStartBars, newIdx, oldBarIdx)
                    break
    for i = 0 to MAX_VWAP_HISTORY - 2
        int srcIdx = MAX_VWAP_HISTORY - 1 - i
        int dstIdx = srcIdx - 1
        array.set(sumSrc, dstIdx, array.get(sumSrc, srcIdx))
        array.set(sumVol, dstIdx, array.get(sumVol, srcIdx))
        array.set(vwaps, dstIdx, array.get(vwaps, srcIdx))
    array.set(sumSrc, MAX_VWAP_HISTORY - 1, 0.0)
    array.set(sumVol, MAX_VWAP_HISTORY - 1, 0.0)
    array.set(vwaps, MAX_VWAP_HISTORY - 1, na)
    for idx = 0 to MAX_VWAP_HISTORY - 1
        array.set(startBars, idx, array.get(tempStartBars, idx))

var array<SessionManager> sessionManagers = array.new<SessionManager>()

if barstate.isfirst
    array.push(sessionManagers, SessionManager.new("London", enableLondonActive, colorLondonActive, colorLondonActiveEnd, londonVWAPCountActive, getSessionStartsArray("London", MAX_VWAP_HISTORY), getSessionEndsArray("London", MAX_VWAP_HISTORY), array.new<int>(MAX_VWAP_HISTORY, na), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, na), array.new<label>(MAX_VWAP_HISTORY, na), na, meetsLondonVWAPTimeframe, array.new<color>(MAX_VWAP_HISTORY)))
    array.push(sessionManagers, SessionManager.new("New York", enableNewYorkActive, colorNewYorkActive, colorNewYorkActiveEnd, nyVWAPCountActive, getSessionStartsArray("New York", MAX_VWAP_HISTORY), getSessionEndsArray("New York", MAX_VWAP_HISTORY), array.new<int>(MAX_VWAP_HISTORY, na), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, na), array.new<label>(MAX_VWAP_HISTORY, na), na, meetsNYVWAPTimeframe, array.new<color>(MAX_VWAP_HISTORY)))
    array.push(sessionManagers, SessionManager.new("Globex", enableGlobexActive, colorGlobexActive, colorGlobexActiveEnd, globexVWAPCountActive, getSessionStartsArray("Globex", MAX_VWAP_HISTORY), getSessionEndsArray("Globex", MAX_VWAP_HISTORY), array.new<int>(MAX_VWAP_HISTORY, na), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, na), array.new<label>(MAX_VWAP_HISTORY, na), na, meetsGlobexVWAPTimeframe, array.new<color>(MAX_VWAP_HISTORY)))
    array.push(sessionManagers, SessionManager.new("Sydney", enableSydneyActive, colorSydneyActive, colorSydneyActiveEnd, sydneyVWAPCountActive, getSessionStartsArray("Sydney", MAX_VWAP_HISTORY), getSessionEndsArray("Sydney", MAX_VWAP_HISTORY), array.new<int>(MAX_VWAP_HISTORY, na), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, na), array.new<label>(MAX_VWAP_HISTORY, na), na, meetsSydneyVWAPTimeframe, array.new<color>(MAX_VWAP_HISTORY)))
    array.push(sessionManagers, SessionManager.new("Tokyo", enableTokyoActive, colorTokyoActive, colorTokyoActiveEnd, tokyoVWAPCountActive, getSessionStartsArray("Tokyo", MAX_VWAP_HISTORY), getSessionEndsArray("Tokyo", MAX_VWAP_HISTORY), array.new<int>(MAX_VWAP_HISTORY, na), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, 0.0), array.new<float>(MAX_VWAP_HISTORY, na), array.new<label>(MAX_VWAP_HISTORY, na), na, meetsTokyoVWAPTimeframe, array.new<color>(MAX_VWAP_HISTORY)))

    for i = 0 to 4
        SessionManager mgr = array.get(sessionManagers, i)
        mgr.prevMostRecentStart := array.get(mgr.starts, MAX_VWAP_HISTORY - 1)
        for pos = 0 to MAX_VWAP_HISTORY - 1
            color preCalc = getVWAPColor(mgr.col, mgr.colEnd, pos, mgr.historyCount - 1)
            array.set(mgr.preCalcColors, pos, preCalc)

var array<int> weeklyAnchorStartsArray = array.new<int>(MAX_WEEKLY_HISTORY, na)
var array<float> weeklyAnchorSumSrc = array.new<float>(MAX_WEEKLY_HISTORY, 0.0)
var array<float> weeklyAnchorSumVol = array.new<float>(MAX_WEEKLY_HISTORY, 0.0)
var array<float> weeklyAnchorVWAPs = array.new<float>(MAX_WEEKLY_HISTORY, na)
var array<label> weeklyAnchorLabels = array.new<label>(MAX_WEEKLY_HISTORY, na)
var bool currentSessionIsWeeklyAnchor = false
var array<color> weeklyColors = array.new<color>(MAX_WEEKLY_HISTORY)

var array<int> monthlyAnchorStartsArray = array.new<int>(MAX_MONTHLY_HISTORY, na)
var array<float> monthlyAnchorSumSrc = array.new<float>(MAX_MONTHLY_HISTORY, 0.0)
var array<float> monthlyAnchorSumVol = array.new<float>(MAX_MONTHLY_HISTORY, 0.0)
var array<float> monthlyAnchorVWAPs = array.new<float>(MAX_MONTHLY_HISTORY, na)
var array<label> monthlyAnchorLabels = array.new<label>(MAX_MONTHLY_HISTORY, na)
var bool currentSessionIsMonthlyAnchor = false
var array<color> monthlyColors = array.new<color>(MAX_MONTHLY_HISTORY)

var array<int> yearlyAnchorStartsArray = array.new<int>(MAX_YEARLY_HISTORY, na)
var array<float> yearlyAnchorSumSrc = array.new<float>(MAX_YEARLY_HISTORY, 0.0)
var array<float> yearlyAnchorSumVol = array.new<float>(MAX_YEARLY_HISTORY, 0.0)
var array<float> yearlyAnchorVWAPs = array.new<float>(MAX_YEARLY_HISTORY, na)
var array<label> yearlyAnchorLabels = array.new<label>(MAX_YEARLY_HISTORY, na)
var bool currentSessionIsYearlyAnchor = false
var array<color> yearlyColors = array.new<color>(MAX_YEARLY_HISTORY)

if barstate.isfirst
    weeklyAnchorStartsArray := getAnchorStarts("W", primarySessionName, MAX_WEEKLY_HISTORY)
    for pos = 0 to MAX_WEEKLY_HISTORY - 1
        array.set(weeklyColors, pos, getVWAPColor(colorWeeklyAnchor, colorWeeklyAnchorEnd, pos, weeklyAnchorCount - 1))
    if showMonthlyAnchorVWAP
        monthlyAnchorStartsArray := getAnchorStarts("M", primarySessionName, MAX_MONTHLY_HISTORY)
        for pos = 0 to MAX_MONTHLY_HISTORY - 1
            array.set(monthlyColors, pos, getVWAPColor(colorMonthlyAnchor, colorMonthlyAnchorEnd, pos, monthlyAnchorCount - 1))
    if showYearlyAnchorVWAP
        yearlyAnchorStartsArray := getAnchorStarts("Y", primarySessionName, MAX_YEARLY_HISTORY)
        for pos = 0 to MAX_YEARLY_HISTORY - 1
            array.set(yearlyColors, pos, getVWAPColor(colorYearlyAnchor, colorYearlyAnchorEnd, pos, yearlyAnchorCount - 1))

var int activeSessionIndex = na

var float sessionOpen = na
var float openRangeHigh = na
var float openRangeLow = na
var float initialBalanceHigh = na
var float initialBalanceLow = na
var int sessionStartBar = na
var int sessionStartTime = na
var int sessionEndTime = na

var int openPriceBar = na
var int orhBar = na
var int orlBar = na
var int ibhBar = na
var int iblBar = na

int openRangeMinutes = periodToMinutes(openRangeLength)
int ibMinutes = periodToMinutes(initialBalanceLength)

// UNIFIED SESSION DETECTION (Calendar-based)

for i = 0 to 4
    SessionManager mgr = array.get(sessionManagers, i)
    if mgr.enabled
        string sessionName = mgr.name
        array<int> sessionStartsArray = mgr.starts
        array<int> sessionEndsArray = mgr.ends

        // Find which session from this type is active at current time (for historical replay)
        for arrayIdx = MAX_VWAP_HISTORY - 1 to 0
            int sessionStart = array.get(sessionStartsArray, arrayIdx)
            int sessionEnd = array.get(sessionEndsArray, arrayIdx)

            if not na(sessionStart) and not na(sessionEnd)
                // Skip sessions that fall on holidays
                string sessionTZ = getSessionTimezone(sessionName)
                // For Globex, check the next day (active trading day), not the session start day
                int holidayCheckTimestamp = na
                if sessionName == "Globex"
                    holidayCheckTimestamp := timestamp(sessionTZ,
                                                       year(sessionStart, sessionTZ),
                                                       month(sessionStart, sessionTZ),
                                                       dayofmonth(sessionStart, sessionTZ) + 1,
                                                       0, 0)
                else
                    holidayCheckTimestamp := sessionStart
                bool sessionIsHoliday = isFullHoliday(holidayCheckTimestamp, sessionTZ, isStock)

                bool isInThisSession = time >= sessionStart and time < sessionEnd and not sessionIsHoliday
                bool sessionJustStarted = time >= sessionStart and time[1] < sessionStart and not sessionIsHoliday

                if sessionJustStarted
                    activeSessionIndex := i

                    sessionOpen := open
                    openRangeHigh := high
                    openRangeLow := low
                    initialBalanceHigh := high
                    initialBalanceLow := low
                    sessionStartBar := bar_index
                    sessionStartTime := sessionStart
                    sessionEndTime := sessionEnd
                    openPriceBar := bar_index
                    orhBar := bar_index
                    orlBar := bar_index
                    ibhBar := bar_index
                    iblBar := bar_index

                if isInThisSession
                    break

if not na(activeSessionIndex) and not na(sessionOpen) and not na(sessionStartTime)
    SessionManager activeMgr = array.get(sessionManagers, activeSessionIndex)
    array<int> activeSessionEnds = activeMgr.ends

    // Use stored session end time (set at session start) to handle edge case where
    // active session gets dropped from array after MAX_VWAP_HISTORY shifts
    bool stillInSession = not na(sessionEndTime) and time >= sessionStartTime and time < sessionEndTime

    if stillInSession
        int elapsedMinutes = math.round((time - sessionStartTime) / MS_PER_MINUTE)
        if elapsedMinutes <= openRangeMinutes
            if high > openRangeHigh
                openRangeHigh := high
                orhBar := bar_index
            if low < openRangeLow
                openRangeLow := low
                orlBar := bar_index

        if elapsedMinutes <= ibMinutes
            if high > initialBalanceHigh
                initialBalanceHigh := high
                ibhBar := bar_index
            if low < initialBalanceLow
                initialBalanceLow := low
                iblBar := bar_index

// MULTI-SESSION VWAP CALCULATIONS

for i = 0 to 4
    SessionManager mgr = array.get(sessionManagers, i)
    if mgr.enabled
        int historyCountUser = mgr.historyCount
        // Only calculate VWAPs that will be displayed (historyCount)
        // When user changes historyCount, entire script reloads from beginning
        // After array shift, the newest historyCount sessions continue calculating correctly
        int historyCountCalc = historyCountUser

        // Loop through all tracked sessions (MAX_VWAP_HISTORY)
        for arrayIdx = 0 to MAX_VWAP_HISTORY - 1
            int sessionStart = array.get(mgr.starts, arrayIdx)
            int nextSessionStart = arrayIdx < MAX_VWAP_HISTORY - 1 ? array.get(mgr.starts, arrayIdx + 1) : int(na)
            bool isSessionStart = not na(sessionStart) and time >= sessionStart and time[1] < sessionStart
            int sessionIndexInHistory = arrayIdx - (MAX_VWAP_HISTORY - historyCountCalc)
            bool isInConfiguredRange = sessionIndexInHistory >= 0
            bool sessionInFuture = not na(sessionStart) and sessionStart > time
            bool shouldCalculate = not na(sessionStart) and time >= sessionStart and isInConfiguredRange and not sessionInFuture

            if isSessionStart and isInConfiguredRange and not na(volume) and volume > 0
                array.set(mgr.sumSrc, arrayIdx, 0.0)
                array.set(mgr.sumVol, arrayIdx, 0.0)
                array.set(mgr.startBars, arrayIdx, bar_index)

            if shouldCalculate
                int sessionBarIdx = array.get(mgr.startBars, arrayIdx)

                if not na(sessionBarIdx)
                    float currentSumSrc = array.get(mgr.sumSrc, arrayIdx)
                    float currentSumVol = array.get(mgr.sumVol, arrayIdx)

                    bool isNYSessionVWAP = mgr.name == "New York"
                    bool shouldAccumulate = not isNYSessionVWAP or not shouldFilterRTH or isNYSession
                    if shouldAccumulate and not na(ohlc4) and not na(volume)
                        currentSumSrc += (ohlc4 * volume)
                        currentSumVol += volume
                        array.set(mgr.sumSrc, arrayIdx, currentSumSrc)
                        array.set(mgr.sumVol, arrayIdx, currentSumVol)

                    float vwap = currentSumVol > 0 ? currentSumSrc / currentSumVol : na
                    array.set(mgr.vwaps, arrayIdx, vwap)

                // Check if this anchor is on a holiday - if so, skip completely
                string sessionTZ = getSessionTimezone(mgr.name)
                int holidayCheckTS = mgr.name == "Globex" ? sessionStart + 86400000 : sessionStart
                bool anchorIsHoliday = isFullHoliday(holidayCheckTS, sessionTZ, isStock)

                // Count how many non-holiday sessions exist from most recent up to now
                int nonHolidayRank = 0
                if not anchorIsHoliday
                    for countIdx = MAX_VWAP_HISTORY - 1 to arrayIdx
                        int countStart = array.get(mgr.starts, countIdx)
                        if not na(countStart)
                            int countHolidayTS = mgr.name == "Globex" ? countStart + 86400000 : countStart
                            if not isFullHoliday(countHolidayTS, sessionTZ, isStock)
                                nonHolidayRank += 1

                // Only show if: not holiday AND within user's requested count
                bool shouldShow = not anchorIsHoliday and nonHolidayRank <= historyCountUser

                if isSessionStart and sessionBaseCondition and mgr.meetsTimeframe and showSessionLabels and showSessionVWAP and shouldShow
                    deleteLabel(mgr.labels, arrayIdx)
                    int positionInHistory = nonHolidayRank - 1
                    color labelColor = getVWAPColor(mgr.col, mgr.colEnd, positionInHistory, historyCountUser - 1)
                    bool isPrimarySession = mgr.name == primarySessionName
                    int labelTimestamp = na
                    if mgr.name == "Globex"
                        string labelTZ = getSessionTimezone(mgr.name)
                        labelTimestamp := timestamp(labelTZ,
                                                    year(sessionStart, labelTZ),
                                                    month(sessionStart, labelTZ),
                                                    dayofmonth(sessionStart, labelTZ) + 1,
                                                    0, 0)
                    else
                        labelTimestamp := sessionStart
                    string sessionLabelText = compactLabels ? (isPrimarySession ? "D" + str.tostring(positionInHistory + 1) : getSessionAbbr(mgr.name) + str.tostring(positionInHistory + 1)) : mgr.name + " " + str.format_time(labelTimestamp, "d MMM", getSessionTimezone(mgr.name))
                    label newLabel = label.new(bar_index, high, sessionLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=labelColor, textcolor=color.white, size=getLabelSize(anchorLabelSize), style=label.style_label_down)
                    array.set(mgr.labels, arrayIdx, newLabel)

            if not isInConfiguredRange
                deleteLabel(mgr.labels, arrayIdx)
                array.set(mgr.labels, arrayIdx, na)

// Detect array shifts and shift accumulators + recreate labels with updated position numbers
if barstate.isconfirmed and not barstate.isfirst
    for i = 0 to 4
        SessionManager mgr = array.get(sessionManagers, i)
        if mgr.enabled
            array<int> currentStarts = getSessionStartsArray(mgr.name, MAX_VWAP_HISTORY)
            array<int> currentEnds = getSessionEndsArray(mgr.name, MAX_VWAP_HISTORY)

            bool shifted = not na(mgr.prevMostRecentStart) and array.get(currentStarts, MAX_VWAP_HISTORY - 1) != mgr.prevMostRecentStart

            if shifted
                mgr.starts := currentStarts
                mgr.ends := currentEnds
                shiftSessionArrays(mgr.starts, currentStarts, mgr.startBars, mgr.sumSrc, mgr.sumVol, mgr.vwaps)

                // Recalculate colors after shift to keep alignment
                for pos = 0 to MAX_VWAP_HISTORY - 1
                    color preCalc = getVWAPColor(mgr.col, mgr.colEnd, pos, mgr.historyCount - 1)
                    array.set(mgr.preCalcColors, pos, preCalc)

                for arrayIdx = 0 to MAX_VWAP_HISTORY - 1
                    int sessionStart = array.get(mgr.starts, arrayIdx)
                    int mgrSessionStartBar = array.get(mgr.startBars, arrayIdx)

                    // Check if this anchor is on a holiday - if so, skip completely
                    string shiftSessionTZ = getSessionTimezone(mgr.name)
                    int shiftHolidayCheckTS = mgr.name == "Globex" ? sessionStart + 86400000 : sessionStart
                    bool shiftAnchorIsHoliday = isFullHoliday(shiftHolidayCheckTS, shiftSessionTZ, isStock)

                    // Count how many non-holiday sessions exist from most recent up to now
                    int shiftNonHolidayRank = 0
                    if not shiftAnchorIsHoliday
                        for countIdx = MAX_VWAP_HISTORY - 1 to arrayIdx
                            int countStart = array.get(mgr.starts, countIdx)
                            if not na(countStart)
                                int countHolidayTS = mgr.name == "Globex" ? countStart + 86400000 : countStart
                                if not isFullHoliday(countHolidayTS, shiftSessionTZ, isStock)
                                    shiftNonHolidayRank += 1

                    // Only show if: not holiday AND within user's requested count
                    bool shiftShouldShow = not shiftAnchorIsHoliday and shiftNonHolidayRank <= mgr.historyCount

                    bool withinLookback = not na(mgrSessionStartBar) and mgrSessionStartBar <= bar_index and (bar_index - mgrSessionStartBar) < 5000
                    bool sessionInFuture = sessionStart > time

                    if not na(sessionStart) and withinLookback and time >= sessionStart and not sessionInFuture and showSessionLabels and showSessionVWAP and sessionBaseCondition and mgr.meetsTimeframe and shiftShouldShow
                        deleteLabel(mgr.labels, arrayIdx)
                        int positionInHistory = shiftNonHolidayRank - 1
                        color labelColor = getVWAPColor(mgr.col, mgr.colEnd, positionInHistory, mgr.historyCount - 1)
                        bool isPrimarySession = mgr.name == primarySessionName
                        int labelTimestamp = mgr.name == "Globex" ? sessionStart + 86400000 : sessionStart
                        string sessionLabelText = compactLabels ? (isPrimarySession ? "D" + str.tostring(positionInHistory + 1) : getSessionAbbr(mgr.name) + str.tostring(positionInHistory + 1)) : mgr.name + " " + str.format_time(labelTimestamp, "d MMM", getSessionTimezone(mgr.name))
                        label newLabel = label.new(mgrSessionStartBar, high[bar_index - mgrSessionStartBar], sessionLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=labelColor, textcolor=color.white, size=getLabelSize(anchorLabelSize), style=label.style_label_down)
                        array.set(mgr.labels, arrayIdx, newLabel)

                mgr.prevMostRecentStart := array.get(currentStarts, MAX_VWAP_HISTORY - 1)

// Plot VWAPs - up to 5 historical sessions per type
SessionManager londonMgr = array.get(sessionManagers, 0)
SessionManager nyMgr = array.get(sessionManagers, 1)
SessionManager globexMgr = array.get(sessionManagers, 2)
SessionManager sydneyMgr = array.get(sessionManagers, 3)
SessionManager tokyoMgr = array.get(sessionManagers, 4)

bool skipLondonMostRecent = showWeeklyAnchorVWAP and primarySessionName == "London" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and londonMgr.meetsTimeframe and showSessionVWAP and londonMgr.enabled and londonMgr.historyCount >= 1 and not skipLondonMostRecent ? array.get(londonMgr.vwaps, MAX_VWAP_HISTORY - 1) : na, "London VWAP 1", color=array.get(londonMgr.preCalcColors, 0), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

bool skipNYMostRecent = showWeeklyAnchorVWAP and primarySessionName == "New York" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and nyMgr.meetsTimeframe and showSessionVWAP and nyMgr.enabled and nyMgr.historyCount >= 1 and not skipNYMostRecent ? array.get(nyMgr.vwaps, MAX_VWAP_HISTORY - 1) : na, "NY VWAP 1", color=array.get(nyMgr.preCalcColors, 0), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and nyMgr.meetsTimeframe and showSessionVWAP and nyMgr.enabled and nyMgr.historyCount >= 2 ? array.get(nyMgr.vwaps, MAX_VWAP_HISTORY - 2) : na, "NY VWAP 2", color=array.get(nyMgr.preCalcColors, 1), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and nyMgr.meetsTimeframe and showSessionVWAP and nyMgr.enabled and nyMgr.historyCount >= 3 ? array.get(nyMgr.vwaps, MAX_VWAP_HISTORY - 3) : na, "NY VWAP 3", color=array.get(nyMgr.preCalcColors, 2), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and nyMgr.meetsTimeframe and showSessionVWAP and nyMgr.enabled and nyMgr.historyCount >= 4 ? array.get(nyMgr.vwaps, MAX_VWAP_HISTORY - 4) : na, "NY VWAP 4", color=array.get(nyMgr.preCalcColors, 3), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and nyMgr.meetsTimeframe and showSessionVWAP and nyMgr.enabled and nyMgr.historyCount >= 5 ? array.get(nyMgr.vwaps, MAX_VWAP_HISTORY - 5) : na, "NY VWAP 5", color=array.get(nyMgr.preCalcColors, 4), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

bool skipGlobexMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Globex" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and globexMgr.meetsTimeframe and showSessionVWAP and globexMgr.enabled and globexMgr.historyCount >= 1 and not skipGlobexMostRecent ? array.get(globexMgr.vwaps, MAX_VWAP_HISTORY - 1) : na, "Globex VWAP 1", color=array.get(globexMgr.preCalcColors, 0), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and globexMgr.meetsTimeframe and showSessionVWAP and globexMgr.enabled and globexMgr.historyCount >= 2 ? array.get(globexMgr.vwaps, MAX_VWAP_HISTORY - 2) : na, "Globex VWAP 2", color=array.get(globexMgr.preCalcColors, 1), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and globexMgr.meetsTimeframe and showSessionVWAP and globexMgr.enabled and globexMgr.historyCount >= 3 ? array.get(globexMgr.vwaps, MAX_VWAP_HISTORY - 3) : na, "Globex VWAP 3", color=array.get(globexMgr.preCalcColors, 2), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and globexMgr.meetsTimeframe and showSessionVWAP and globexMgr.enabled and globexMgr.historyCount >= 4 ? array.get(globexMgr.vwaps, MAX_VWAP_HISTORY - 4) : na, "Globex VWAP 4", color=array.get(globexMgr.preCalcColors, 3), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and globexMgr.meetsTimeframe and showSessionVWAP and globexMgr.enabled and globexMgr.historyCount >= 5 ? array.get(globexMgr.vwaps, MAX_VWAP_HISTORY - 5) : na, "Globex VWAP 5", color=array.get(globexMgr.preCalcColors, 4), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

bool skipSydneyMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Sydney" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and sydneyMgr.meetsTimeframe and showSessionVWAP and sydneyMgr.enabled and sydneyMgr.historyCount >= 1 and not skipSydneyMostRecent ? array.get(sydneyMgr.vwaps, MAX_VWAP_HISTORY - 1) : na, "Sydney VWAP 1", color=array.get(sydneyMgr.preCalcColors, 0), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

bool skipTokyoMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Tokyo" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and tokyoMgr.meetsTimeframe and showSessionVWAP and tokyoMgr.enabled and tokyoMgr.historyCount >= 1 and not skipTokyoMostRecent ? array.get(tokyoMgr.vwaps, MAX_VWAP_HISTORY - 1) : na, "Tokyo VWAP 1", color=array.get(tokyoMgr.preCalcColors, 0), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEEKLY ANCHOR VWAP CALCULATION (Multi-week support)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Get the session arrays for the anchor session type (for skip logic)
SessionManager primaryMgr = switch primarySessionName
    "London" => londonMgr
    "New York" => nyMgr
    "Globex" => globexMgr
    "Sydney" => sydneyMgr
    => tokyoMgr

if showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe
    string anchorTZ = getSessionTimezone(primarySessionName)

    // Process each week in the array
    for weekIdx = 0 to MAX_WEEKLY_HISTORY - 1
        int weekStart = array.get(weeklyAnchorStartsArray, weekIdx)

        if not na(weekStart)
            // Detect when we cross into this week's start
            bool atWeekStart = time >= weekStart and time[1] < weekStart

            if atWeekStart
                // Reset accumulators for this week
                array.set(weeklyAnchorSumSrc, weekIdx, 0.0)
                array.set(weeklyAnchorSumVol, weekIdx, 0.0)

                // Check if this is the most recent week and matches the most recent daily session
                if weekIdx == MAX_WEEKLY_HISTORY - 1
                    currentSessionIsWeeklyAnchor := (weekStart == array.get(primaryMgr.starts, MAX_VWAP_HISTORY - 1))

                bool shouldShowLabel = weekIdx >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
                if showSessionLabels and shouldShowLabel
                    int positionInWeeklyHistory = (MAX_WEEKLY_HISTORY - 1) - weekIdx
                    createAnchorLabel(weeklyAnchorLabels, weekIdx, weekStart, "W", positionInWeeklyHistory, colorWeeklyAnchor, colorWeeklyAnchorEnd, weeklyAnchorCount - 1, anchorTZ, primarySessionName)

            // Accumulate if we're at or after this week's start (apply RTH filter for stocks/indices)
            bool shouldAccumulateWeekly = not shouldFilterRTH or isNYSession
            if time >= weekStart and shouldAccumulateWeekly
                float currentSumSrc = array.get(weeklyAnchorSumSrc, weekIdx)
                float currentSumVol = array.get(weeklyAnchorSumVol, weekIdx)
                array.set(weeklyAnchorSumSrc, weekIdx, currentSumSrc + (ohlc4 * volume))
                array.set(weeklyAnchorSumVol, weekIdx, currentSumVol + volume)

                float newSumSrc = array.get(weeklyAnchorSumSrc, weekIdx)
                float newSumVol = array.get(weeklyAnchorSumVol, weekIdx)
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(weeklyAnchorVWAPs, weekIdx, vwap)

bool wklyBase = showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe
plot(wklyBase and 0 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount) ? array.get(weeklyAnchorVWAPs, 0) : na, "Weekly Anchor 1", color=array.get(weeklyColors, 5), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(wklyBase and 1 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount) ? array.get(weeklyAnchorVWAPs, 1) : na, "Weekly Anchor 2", color=array.get(weeklyColors, 4), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(wklyBase and 2 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount) ? array.get(weeklyAnchorVWAPs, 2) : na, "Weekly Anchor 3", color=array.get(weeklyColors, 3), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(wklyBase and 3 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount) ? array.get(weeklyAnchorVWAPs, 3) : na, "Weekly Anchor 4", color=array.get(weeklyColors, 2), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(wklyBase and 4 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount) ? array.get(weeklyAnchorVWAPs, 4) : na, "Weekly Anchor 5", color=array.get(weeklyColors, 1), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(wklyBase and 5 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount) ? array.get(weeklyAnchorVWAPs, 5) : na, "Weekly Anchor 6", color=array.get(weeklyColors, 0), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MONTHLY ANCHOR VWAP CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if showMonthlyAnchorVWAP and showSessionMarkers and meetsMonthlyAnchorTimeframe
    string anchorTZ = getSessionTimezone(primarySessionName)
    for monthIdx = 0 to MAX_MONTHLY_HISTORY - 1
        int monthStart = array.get(monthlyAnchorStartsArray, monthIdx)
        if not na(monthStart)
            bool atMonthStart = time >= monthStart and time[1] < monthStart
            if atMonthStart
                array.set(monthlyAnchorSumSrc, monthIdx, 0.0)
                array.set(monthlyAnchorSumVol, monthIdx, 0.0)
                if monthIdx == MAX_MONTHLY_HISTORY - 1
                    currentSessionIsMonthlyAnchor := (monthStart == array.get(primaryMgr.starts, MAX_VWAP_HISTORY - 1))
                bool shouldShowLabel = monthIdx >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount)
                if showSessionLabels and shouldShowLabel
                    int positionInMonthlyHistory = (MAX_MONTHLY_HISTORY - 1) - monthIdx
                    createAnchorLabel(monthlyAnchorLabels, monthIdx, monthStart, "M", positionInMonthlyHistory, colorMonthlyAnchor, colorMonthlyAnchorEnd, monthlyAnchorCount - 1, anchorTZ, primarySessionName)
            if time >= monthStart
                bool shouldAccumulateMonthly = not shouldFilterRTH or isNYSession
                if shouldAccumulateMonthly
                    float currentSumSrc = array.get(monthlyAnchorSumSrc, monthIdx)
                    float currentSumVol = array.get(monthlyAnchorSumVol, monthIdx)
                    array.set(monthlyAnchorSumSrc, monthIdx, currentSumSrc + (ohlc4 * volume))
                    array.set(monthlyAnchorSumVol, monthIdx, currentSumVol + volume)
                float newSumSrc = array.get(monthlyAnchorSumSrc, monthIdx)
                float newSumVol = array.get(monthlyAnchorSumVol, monthIdx)
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(monthlyAnchorVWAPs, monthIdx, vwap)

bool mnthBase = showMonthlyAnchorVWAP and showSessionMarkers and meetsMonthlyAnchorTimeframe
plot(mnthBase and 0 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount) ? array.get(monthlyAnchorVWAPs, 0) : na, "Monthly Anchor 1", color=array.get(monthlyColors, 5), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(mnthBase and 1 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount) ? array.get(monthlyAnchorVWAPs, 1) : na, "Monthly Anchor 2", color=array.get(monthlyColors, 4), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(mnthBase and 2 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount) ? array.get(monthlyAnchorVWAPs, 2) : na, "Monthly Anchor 3", color=array.get(monthlyColors, 3), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(mnthBase and 3 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount) ? array.get(monthlyAnchorVWAPs, 3) : na, "Monthly Anchor 4", color=array.get(monthlyColors, 2), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(mnthBase and 4 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount) ? array.get(monthlyAnchorVWAPs, 4) : na, "Monthly Anchor 5", color=array.get(monthlyColors, 1), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(mnthBase and 5 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount) ? array.get(monthlyAnchorVWAPs, 5) : na, "Monthly Anchor 6", color=array.get(monthlyColors, 0), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// YEARLY ANCHOR VWAP CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if showYearlyAnchorVWAP and showSessionMarkers and meetsYearlyAnchorTimeframe
    string anchorTZ = getSessionTimezone(primarySessionName)
    for yearIdx = 0 to MAX_YEARLY_HISTORY - 1
        int yearStart = array.get(yearlyAnchorStartsArray, yearIdx)
        if not na(yearStart)
            bool atYearStart = time >= yearStart and time[1] < yearStart
            if atYearStart
                array.set(yearlyAnchorSumSrc, yearIdx, 0.0)
                array.set(yearlyAnchorSumVol, yearIdx, 0.0)
                if yearIdx == MAX_YEARLY_HISTORY - 1
                    currentSessionIsYearlyAnchor := (yearStart == array.get(primaryMgr.starts, MAX_VWAP_HISTORY - 1))
                bool shouldShowLabel = yearIdx >= (MAX_YEARLY_HISTORY - yearlyAnchorCount)
                if showSessionLabels and shouldShowLabel
                    int positionInYearlyHistory = (MAX_YEARLY_HISTORY - 1) - yearIdx
                    createAnchorLabel(yearlyAnchorLabels, yearIdx, yearStart, "Y", positionInYearlyHistory, colorYearlyAnchor, colorYearlyAnchorEnd, yearlyAnchorCount - 1, anchorTZ, primarySessionName)
            if time >= yearStart
                bool shouldAccumulateYearly = not shouldFilterRTH or isNYSession
                if shouldAccumulateYearly
                    float currentSumSrc = array.get(yearlyAnchorSumSrc, yearIdx)
                    float currentSumVol = array.get(yearlyAnchorSumVol, yearIdx)
                    array.set(yearlyAnchorSumSrc, yearIdx, currentSumSrc + (ohlc4 * volume))
                    array.set(yearlyAnchorSumVol, yearIdx, currentSumVol + volume)
                float newSumSrc = array.get(yearlyAnchorSumSrc, yearIdx)
                float newSumVol = array.get(yearlyAnchorSumVol, yearIdx)
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(yearlyAnchorVWAPs, yearIdx, vwap)

bool yrlyBase = showYearlyAnchorVWAP and showSessionMarkers and meetsYearlyAnchorTimeframe
plot(yrlyBase and 0 >= (MAX_YEARLY_HISTORY - yearlyAnchorCount) ? array.get(yearlyAnchorVWAPs, 0) : na, "Yearly Anchor 1", color=array.get(yearlyColors, 1), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)
plot(yrlyBase and 1 >= (MAX_YEARLY_HISTORY - yearlyAnchorCount) ? array.get(yearlyAnchorVWAPs, 1) : na, "Yearly Anchor 2", color=array.get(yearlyColors, 0), linewidth=sessionVWAPLineWidth, linestyle=sessionVWAPLineStyle)


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION LEVELS RENDERING (for active session only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box boxOpenRange = na
var box boxInitialBalanceUpper = na
var box boxInitialBalanceLower = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEY LEVELS RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Cache bar_index to prevent redundant updates on same bar (improves scrolling performance)
var int lastRenderBarIndex = na

if barstate.islast and (na(lastRenderBarIndex) or bar_index != lastRenderBarIndex)
    lastRenderBarIndex := bar_index

    // Calculate line start position with hard limit to prevent lines getting too long
    int startBar = math.max(0, bar_index - globalLineLengthBars)
    int maxLineDistance = 200  // Safe hard limit: must match max value of globalLineLengthBars input (prevents crashes on high-frequency charts)

    // Determine session line start based on user preference, but reset to configured length if beyond hard limit
    int sessionOpenBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
    int openPriceStartBar = sessionLineStartMode == "Level Established" and not na(openPriceBar) ? (bar_index - openPriceBar > maxLineDistance ? startBar : openPriceBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orhStartBar = sessionLineStartMode == "Level Established" and not na(orhBar) ? (bar_index - orhBar > maxLineDistance ? startBar : orhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orlStartBar = sessionLineStartMode == "Level Established" and not na(orlBar) ? (bar_index - orlBar > maxLineDistance ? startBar : orlBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int ibhStartBar = sessionLineStartMode == "Level Established" and not na(ibhBar) ? (bar_index - ibhBar > maxLineDistance ? startBar : ibhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int iblStartBar = sessionLineStartMode == "Level Established" and not na(iblBar) ? (bar_index - iblBar > maxLineDistance ? startBar : iblBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)

    string labelSizeActual = getLabelSize(globalLabelSize)

    // Convert prices to integer ticks for deduplication
    int athTicks = priceToTicks(ath)
    int pyhTicks = priceToTicks(pyh)
    int pylTicks = priceToTicks(pyl)
    int pmhTicks = priceToTicks(pmh)
    int pmlTicks = priceToTicks(pml)
    int pwhTicks = priceToTicks(pwh)
    int pwlTicks = priceToTicks(pwl)
    int pdhTicks = priceToTicks(pdh)
    int pdlTicks = priceToTicks(pdl)
    int cyhTicks = priceToTicks(cyh)
    int cylTicks = priceToTicks(cyl)
    int cmhTicks = priceToTicks(cmh)
    int cmlTicks = priceToTicks(cml)
    int cwhTicks = priceToTicks(cwh)
    int cwlTicks = priceToTicks(cwl)
    int cdhTicks = priceToTicks(cdh)
    int cdlTicks = priceToTicks(cdl)

    // Pivot points in ticks
    int pivotPTicks = priceToTicks(pivotP)
    int pivotR1Ticks = priceToTicks(pivotR1)
    int pivotR2Ticks = priceToTicks(pivotR2)
    int pivotR3Ticks = priceToTicks(pivotR3)
    int pivotS1Ticks = priceToTicks(pivotS1)
    int pivotS2Ticks = priceToTicks(pivotS2)
    int pivotS3Ticks = priceToTicks(pivotS3)

    // Session levels in ticks
    int ibhTicks = priceToTicks(initialBalanceHigh)
    int iblTicks = priceToTicks(initialBalanceLow)
    int orhTicks = priceToTicks(openRangeHigh)
    int orlTicks = priceToTicks(openRangeLow)
    int openTicks = priceToTicks(sessionOpen)

    // Build price->label map (merges duplicates with "/")
    // Priority: Session Levels > Pivot Points > Key Levels
    var map<int, string> priceLabels = map.new<int, string>()
    map.clear(priceLabels)

    // Session levels first (highest priority)
    bool shouldAddSessionToMap = showSessionMarkersCondition and not na(sessionOpen)
    if shouldAddSessionToMap
        if showOpenPrice
            addToMap(priceLabels, sessionOpen, "Open")
        if showOpenRange and not na(openRangeHigh)
            addToMap(priceLabels, openRangeHigh, "ORH")
        if showOpenRange and not na(openRangeLow)
            addToMap(priceLabels, openRangeLow, "ORL")
        if showInitialBalance and not na(initialBalanceHigh)
            addToMap(priceLabels, initialBalanceHigh, "IBH")
        if showInitialBalance and not na(initialBalanceLow)
            addToMap(priceLabels, initialBalanceLow, "IBL")

    // Pivot points second (after session, before key levels)
    if showPivotsCondition
        if showPivotP
            addToMap(priceLabels, pivotP, "P")
        if showPivotR1
            addToMap(priceLabels, pivotR1, "R1")
        if showPivotR2
            addToMap(priceLabels, pivotR2, "R2")
        if showPivotR3
            addToMap(priceLabels, pivotR3, "R3")
        if showPivotS1
            addToMap(priceLabels, pivotS1, "S1")
        if showPivotS2
            addToMap(priceLabels, pivotS2, "S2")
        if showPivotS3
            addToMap(priceLabels, pivotS3, "S3")

    // Key levels (lower priority)
    if showKeyLevelsCondition
        if showATH
            addToMap(priceLabels, ath, "ATH")
        if showPYH
            addToMap(priceLabels, pyh, "PYH")
        if showPYL
            addToMap(priceLabels, pyl, "PYL")
        if showPMH
            addToMap(priceLabels, pmh, "PMH")
        if showPML
            addToMap(priceLabels, pml, "PML")
        if showPWH
            addToMap(priceLabels, pwh, "PWH")
        if showPWL
            addToMap(priceLabels, pwl, "PWL")
        if showPDH
            addToMap(priceLabels, pdh, "PDH")
        if showPDL
            addToMap(priceLabels, pdl, "PDL")
        if showCYH
            addToMap(priceLabels, cyh, "CYH")
        if showCYL
            addToMap(priceLabels, cyl, "CYL")
        if showCMH
            addToMap(priceLabels, cmh, "CMH")
        if showCML
            addToMap(priceLabels, cml, "CML")
        if showCWH
            addToMap(priceLabels, cwh, "CWH")
        if showCWL
            addToMap(priceLabels, cwl, "CWL")
        if showCDH
            addToMap(priceLabels, cdh, "CDH")
        if showCDL
            addToMap(priceLabels, cdl, "CDL")

    var array<int> renderedPrices = array.new<int>()
    array.clear(renderedPrices)

    // Initialize level arrays on first render
    if array.size(sessionLevels) == 0
        addLevel(sessionLevels, "Open", showOpenPrice, sessionOpen, openTicks, openPriceStartBar, colorOpenPrice, sessionLevelsLineWidth, sessionLevelsLineStyle)
        addLevel(sessionLevels, "ORH", showOpenRange, openRangeHigh, orhTicks, orhStartBar, colorORH, sessionLevelsLineWidth, sessionLevelsLineStyle)
        addLevel(sessionLevels, "ORL", showOpenRange, openRangeLow, orlTicks, orlStartBar, colorORL, sessionLevelsLineWidth, sessionLevelsLineStyle)
        addLevel(sessionLevels, "IBH", showInitialBalance, initialBalanceHigh, ibhTicks, ibhStartBar, colorIBH, sessionLevelsLineWidth, sessionLevelsLineStyle)
        addLevel(sessionLevels, "IBL", showInitialBalance, initialBalanceLow, iblTicks, iblStartBar, colorIBL, sessionLevelsLineWidth, sessionLevelsLineStyle)

        addLevel(pivotLevels, "P", showPivotP, pivotP, pivotPTicks, startBar, pivotColorP, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "R1", showPivotR1, pivotR1, pivotR1Ticks, startBar, pivotColorR1, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "R2", showPivotR2, pivotR2, pivotR2Ticks, startBar, pivotColorR2, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "R3", showPivotR3, pivotR3, pivotR3Ticks, startBar, pivotColorR3, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "S1", showPivotS1, pivotS1, pivotS1Ticks, startBar, pivotColorS1, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "S2", showPivotS2, pivotS2, pivotS2Ticks, startBar, pivotColorS2, pivotLineWidth, pivotLineStyle)
        addLevel(pivotLevels, "S3", showPivotS3, pivotS3, pivotS3Ticks, startBar, pivotColorS3, pivotLineWidth, pivotLineStyle)

        addLevel(keyLevels, "ATH", showATH, ath, athTicks, startBar, colorATH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PYH", showPYH, pyh, pyhTicks, startBar, colorPYH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PYL", showPYL, pyl, pylTicks, startBar, colorPYL, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PMH", showPMH, pmh, pmhTicks, startBar, colorPMH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PML", showPML, pml, pmlTicks, startBar, colorPML, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PWH", showPWH, pwh, pwhTicks, startBar, colorPWH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PWL", showPWL, pwl, pwlTicks, startBar, colorPWL, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PDH", showPDH, pdh, pdhTicks, startBar, colorPDH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "PDL", showPDL, pdl, pdlTicks, startBar, colorPDL, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CYH", showCYH, cyh, cyhTicks, startBar, colorCYH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CYL", showCYL, cyl, cylTicks, startBar, colorCYL, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CMH", showCMH, cmh, cmhTicks, startBar, colorCMH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CML", showCML, cml, cmlTicks, startBar, colorCML, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CWH", showCWH, cwh, cwhTicks, startBar, colorCWH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CWL", showCWL, cwl, cwlTicks, startBar, colorCWL, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CDH", showCDH, cdh, cdhTicks, startBar, colorCDH, keyLevelsLineWidth, keyLevelsLineStyle)
        addLevel(keyLevels, "CDL", showCDL, cdl, cdlTicks, startBar, colorCDL, keyLevelsLineWidth, keyLevelsLineStyle)
    else
        // Update level data each bar
        array.get(sessionLevels, 0).update(showOpenPrice, sessionOpen, openTicks, openPriceStartBar)
        array.get(sessionLevels, 1).update(showOpenRange, openRangeHigh, orhTicks, orhStartBar)
        array.get(sessionLevels, 2).update(showOpenRange, openRangeLow, orlTicks, orlStartBar)
        array.get(sessionLevels, 3).update(showInitialBalance, initialBalanceHigh, ibhTicks, ibhStartBar)
        array.get(sessionLevels, 4).update(showInitialBalance, initialBalanceLow, iblTicks, iblStartBar)

        array.get(pivotLevels, 0).update(showPivotP, pivotP, pivotPTicks, startBar)
        array.get(pivotLevels, 1).update(showPivotR1, pivotR1, pivotR1Ticks, startBar)
        array.get(pivotLevels, 2).update(showPivotR2, pivotR2, pivotR2Ticks, startBar)
        array.get(pivotLevels, 3).update(showPivotR3, pivotR3, pivotR3Ticks, startBar)
        array.get(pivotLevels, 4).update(showPivotS1, pivotS1, pivotS1Ticks, startBar)
        array.get(pivotLevels, 5).update(showPivotS2, pivotS2, pivotS2Ticks, startBar)
        array.get(pivotLevels, 6).update(showPivotS3, pivotS3, pivotS3Ticks, startBar)

        array.get(keyLevels, 0).update(showATH, ath, athTicks, startBar)
        array.get(keyLevels, 1).update(showPYH, pyh, pyhTicks, startBar)
        array.get(keyLevels, 2).update(showPYL, pyl, pylTicks, startBar)
        array.get(keyLevels, 3).update(showPMH, pmh, pmhTicks, startBar)
        array.get(keyLevels, 4).update(showPML, pml, pmlTicks, startBar)
        array.get(keyLevels, 5).update(showPWH, pwh, pwhTicks, startBar)
        array.get(keyLevels, 6).update(showPWL, pwl, pwlTicks, startBar)
        array.get(keyLevels, 7).update(showPDH, pdh, pdhTicks, startBar)
        array.get(keyLevels, 8).update(showPDL, pdl, pdlTicks, startBar)
        array.get(keyLevels, 9).update(showCYH, cyh, cyhTicks, startBar)
        array.get(keyLevels, 10).update(showCYL, cyl, cylTicks, startBar)
        array.get(keyLevels, 11).update(showCMH, cmh, cmhTicks, startBar)
        array.get(keyLevels, 12).update(showCML, cml, cmlTicks, startBar)
        array.get(keyLevels, 13).update(showCWH, cwh, cwhTicks, startBar)
        array.get(keyLevels, 14).update(showCWL, cwl, cwlTicks, startBar)
        array.get(keyLevels, 15).update(showCDH, cdh, cdhTicks, startBar)
        array.get(keyLevels, 16).update(showCDL, cdl, cdlTicks, startBar)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION LEVELS RENDERING (FIRST - highest priority for line style)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    string sessionLineStyleActual = getLineStyle(sessionLevelsLineStyle)
    // Only show session levels if enabled and we meet the session levels timeframe filter
    bool showSessionLevels = showSessionLevelsInput == "Always" or (showSessionLevelsInput == "Futures Only" and syminfo.type == "futures")
    bool shouldShowSessionLevels = showSessionLevels and sessionBaseCondition and meetsSessionLevelsMaxTimeframe and not na(activeSessionIndex) and not na(sessionOpen)

    // Render session levels using array-based approach (always ignore ATR filter for session levels)
    for level in sessionLevels
        level.render(shouldShowSessionLevels, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter, true)

    // Open Range Background Shading
    if shouldShowSessionLevels and showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        int boxORStartBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
        boxOpenRange := updateBox(boxOpenRange, boxORStartBar, openRangeHigh, bar_index, openRangeLow, colorOpenRangeShade)
    else if not na(boxOpenRange)
        box.delete(boxOpenRange), boxOpenRange := na



    // Initial Balance Background Shading
    if shouldShowSessionLevels and showInitialBalance and shadeInitialBalance and not na(initialBalanceHigh) and not na(initialBalanceLow)
        int boxIBStartBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
        bool splitIBBox = showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        if splitIBBox
            if initialBalanceHigh > openRangeHigh
                boxInitialBalanceUpper := updateBox(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh, bar_index, openRangeHigh, colorInitialBalanceShade)
            else if not na(boxInitialBalanceUpper)
                box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
            if initialBalanceLow < openRangeLow
                boxInitialBalanceLower := updateBox(boxInitialBalanceLower, boxIBStartBar, openRangeLow, bar_index, initialBalanceLow, colorInitialBalanceShade)
            else if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
        else
            boxInitialBalanceUpper := updateBox(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh, bar_index, initialBalanceLow, colorInitialBalanceShade)
            if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
    else
        if not na(boxInitialBalanceUpper)
            box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
        if not na(boxInitialBalanceLower)
            box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PIVOT POINTS RENDERING (SECOND - after session levels, before key levels)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Render pivot levels using array-based approach
    for level in pivotLevels
        level.render(showPivotsCondition, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // KEY LEVELS RENDERING (THIRD - after session levels and pivots)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Render key levels using array-based approach
    for level in keyLevels
        level.render(showKeyLevelsCondition, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)
