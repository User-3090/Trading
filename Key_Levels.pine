// MIT License
//
// Copyright (c) 2025 User-3090
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//@version=6
indicator("Key Levels", overlay=true, max_lines_count=500, max_boxes_count=100)

//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS â€” PREMIUM PANEL (GROUPING/ORDER ONLY; RUNTIME LOGIC UNCHANGED)
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ·ï¸ Horizontal Levels
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
globalShowPriceValues = input.bool(false, "Show Prices in Level Labels", group="ðŸ·ï¸ Horizontal Levels", tooltip="Show price in labels: 'PDH (4523.50)' vs 'PDH'")

useATRFilter = input.bool(true, "Hide Distant Levels", group="ðŸ·ï¸ Horizontal Levels", tooltip="Only show horizontal levels within specified ATR distance from current price")
atrMultiplier = input.float(1.5, "Distance (ATR)", minval=1.0, maxval=10.0, step=0.5, group="ðŸ·ï¸ Horizontal Levels", tooltip="Hide levels beyond this many ATRs from current price")
atrPeriod = input.int(20, "ATR Period (Days)", minval=1, maxval=500, group="ðŸ·ï¸ Horizontal Levels", tooltip="ATR calculated from daily bars (last N days), regardless of chart timeframe")

globalLabelSize = input.string("Normal", "Level Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="ðŸ·ï¸ Horizontal Levels", tooltip="Label size for horizontal level lines (Session Levels, Pivot Points, Key Levels)")
globalLineLengthBars = input.int(50, "Line Length (Bars)", minval=10, maxval=200, group="ðŸ·ï¸ Horizontal Levels", tooltip="Bars to extend lines backward from current bar (used when Line Start = Fixed Bars Back). Hard limit for lines: 200")

showSessionMarkers = input.bool(true, "Enable Session Features", group="ðŸ•’ Sessions â€¢ General", tooltip="Master switch for session features (VWAP anchors, session levels, labels).")

showSessionLabels = input.bool(true, "Enable Anchor Labels", group="ðŸ•’ Sessions â€¢ General", tooltip="Master switch for session VWAP anchor labels.")
compactLabels = input.bool(true, "Compact Anchor Labels", group="ðŸ•’ Sessions â€¢ General", tooltip="Use abbreviated anchor labels (daily/weekly anchors).")
longTermAnchorSession = input.string("Auto", "Primary Anchor Session", options=["Auto", "Globex", "Sydney", "Tokyo", "London", "New York"], group="ðŸ•’ Sessions â€¢ General", tooltip="Primary session used to define weekly/monthly/yearly VWAP anchors. Auto selects New York for stocks, Globex for all other symbols.")
rthOnlyForStocks = input.bool(true, "RTH Only for NY Sessions (Stocks)", group="ðŸ•’ Sessions â€¢ General", tooltip="For stocks on ETH charts: provides correct RTH-based VWAPs by filtering NY session and NY-based anchors (Weekly/Monthly/Yearly) to Regular Trading Hours only (9:30 AM - 4:00 PM ET). Excludes pre-market and after-hours volume from calculations. Other sessions (London, Globex, etc.) use their full session data for reference.")
rthOnlyForIndices = input.bool(false, "RTH Only for NY Sessions (Indices)", group="ðŸ•’ Sessions â€¢ General", tooltip="For equity index futures on ETH charts: provides correct RTH-based VWAPs by filtering NY session and NY-based anchors to Regular Trading Hours only (9:30 AM - 4:00 PM ET). Other sessions use their full session data.")

showSessionVWAP = input.bool(true, "Enable Daily VWAP Anchors", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Show daily session VWAP anchors (each session start), including their labels.")

longTermAnchorSessionMaxTimeframe = input.string("30m", "Max Timeframe (Primary)", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Maximum chart timeframe where the Primary Anchor session remains visible.")
otherSessionsMaxTimeframe = input.string("5m", "Max Timeframe (Other)", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Maximum chart timeframe where non-primary sessions remain visible.")

sessionVWAPLineStyleInput = input.string("Dotted", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Line appearance for session VWAP anchors.")
sessionVWAPLineWidth = input.int(3, "Line Width", minval=1, maxval=5, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily", tooltip="Line thickness for session VWAP anchors.")
sessionVWAPLineStyle = sessionVWAPLineStyleInput == "Solid" ? plot.linestyle_solid : sessionVWAPLineStyleInput == "Dashed" ? plot.linestyle_dashed : plot.linestyle_dotted

// Stock-specific session settings
enableGlobexStock = input.bool(false, "Globex", inline="SS_GLX_STK", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorGlobexStock = input.color(#4CAF50, "", inline="SS_GLX_STK", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
globexVWAPCountStock = input.int(1, "History", inline="SS_GLX_STK", minval=1, maxval=5, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Number of daily Globex anchors to show for stocks.")

enableSydneyStock = input.bool(false, "Sydney", inline="SS_SYD_STK", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorSydneyStock = input.color(#800080, "", inline="SS_SYD_STK", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
sydneyVWAPCountStock = input.int(1, "History", inline="SS_SYD_STK", minval=1, maxval=1, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Number of daily Sydney anchors to show for stocks.")

enableTokyoStock = input.bool(false, "Tokyo", inline="SS_TKY_STK", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorTokyoStock = input.color(#FF0000, "", inline="SS_TKY_STK", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
tokyoVWAPCountStock = input.int(1, "History", inline="SS_TKY_STK", minval=1, maxval=1, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Number of daily Tokyo anchors to show for stocks.")

enableLondonStock = input.bool(false, "London", inline="SS_LON_STK", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorLondonStock = input.color(#FFA500, "", inline="SS_LON_STK", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
londonVWAPCountStock = input.int(1, "History", inline="SS_LON_STK", minval=1, maxval=1, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Number of daily London anchors to show for stocks.")

enableNewYorkStock = input.bool(true, "New York", inline="SS_NY_STK", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
colorNewYorkStock = input.color(#0000FF, "", inline="SS_NY_STK", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks")
nyVWAPCountStock = input.int(3, "History", inline="SS_NY_STK", minval=1, maxval=5, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Number of daily NY anchors to show for stocks.")

vwapColorDifferentiationStock = input.bool(true, "Fade Past Sessions", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Visually de-emphasize older daily VWAP anchors.")
vwapMaxTransparencyStock = input.int(0, "Oldest Transparency", minval=0, maxval=95, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Transparency applied to the oldest visible daily VWAP anchor (0=opaque).")
vwapDesaturationStock = input.int(0, "Desaturation", minval=0, maxval=100, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Reduce color vibrancy for older daily VWAP anchors (0=vibrant, 100=gray).")
vwapBrightnessStock = input.int(0, "Brightness", minval=-100, maxval=100, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Adjust brightness for older daily VWAP anchors (0=no change, -=darker, +=brighter).")
vwapHueShiftStock = input.int(-5, "Hue Shift", minval=-50, maxval=50, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Stocks", tooltip="Shift hue for older daily VWAP anchors (-=cooler, +=warmer).")

// Non-stock (futures, crypto, etc.) session settings
enableGlobex = input.bool(true, "Globex", inline="SS_GLX", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorGlobex = input.color(#4CAF50, "", inline="SS_GLX", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
globexVWAPCount = input.int(3, "History", inline="SS_GLX", minval=1, maxval=5, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Number of daily Globex anchors to show for non-stocks.")

enableSydney = input.bool(false, "Sydney", inline="SS_SYD", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorSydney = input.color(#800080, "", inline="SS_SYD", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
sydneyVWAPCount = input.int(1, "History", inline="SS_SYD", minval=1, maxval=1, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Number of daily Sydney anchors to show for non-stocks.")

enableTokyo = input.bool(false, "Tokyo", inline="SS_TKY", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorTokyo = input.color(#FF0000, "", inline="SS_TKY", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
tokyoVWAPCount = input.int(1, "History", inline="SS_TKY", minval=1, maxval=1, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Number of daily Tokyo anchors to show for non-stocks.")

enableLondon = input.bool(true, "London", inline="SS_LON", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorLondon = input.color(#FFA500, "", inline="SS_LON", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
londonVWAPCount = input.int(1, "History", inline="SS_LON", minval=1, maxval=1, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Number of daily London anchors to show for non-stocks.")

enableNewYork = input.bool(true, "New York", inline="SS_NY", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
colorNewYork = input.color(#0000FF, "", inline="SS_NY", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments")
nyVWAPCount = input.int(2, "History", inline="SS_NY", minval=1, maxval=5, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Number of daily NY anchors to show for non-stocks.")

vwapColorDifferentiation = input.bool(true, "Fade Past Sessions", group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Visually de-emphasize older daily VWAP anchors.")
vwapMaxTransparency = input.int(0, "Oldest Transparency", minval=0, maxval=95, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Transparency applied to the oldest visible daily VWAP anchor (0=opaque).")
vwapDesaturation = input.int(0, "Desaturation", minval=0, maxval=100, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Reduce color vibrancy for older daily VWAP anchors (0=vibrant, 100=gray).")
vwapBrightness = input.int(0, "Brightness", minval=-100, maxval=100, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Adjust brightness for older daily VWAP anchors (0=no change, -=darker, +=brighter).")
vwapHueShift = input.int(-5, "Hue Shift", minval=-50, maxval=50, group="ðŸ•’ Sessions â€¢ VWAP Anchors â€¢ Daily â€¢ Other Instruments", tooltip="Shift hue for older daily VWAP anchors (-=cooler, +=warmer).")

// Select which settings to use based on symbol type
bool isStock = syminfo.type == "stock"
bool enableGlobexActive = isStock ? enableGlobexStock : enableGlobex
color colorGlobexActive = isStock ? colorGlobexStock : colorGlobex
int globexVWAPCountActive = isStock ? globexVWAPCountStock : globexVWAPCount
bool enableSydneyActive = isStock ? enableSydneyStock : enableSydney
color colorSydneyActive = isStock ? colorSydneyStock : colorSydney
int sydneyVWAPCountActive = isStock ? sydneyVWAPCountStock : sydneyVWAPCount
bool enableTokyoActive = isStock ? enableTokyoStock : enableTokyo
color colorTokyoActive = isStock ? colorTokyoStock : colorTokyo
int tokyoVWAPCountActive = isStock ? tokyoVWAPCountStock : tokyoVWAPCount
bool enableLondonActive = isStock ? enableLondonStock : enableLondon
color colorLondonActive = isStock ? colorLondonStock : colorLondon
int londonVWAPCountActive = isStock ? londonVWAPCountStock : londonVWAPCount
bool enableNewYorkActive = isStock ? enableNewYorkStock : enableNewYork
color colorNewYorkActive = isStock ? colorNewYorkStock : colorNewYork
int nyVWAPCountActive = isStock ? nyVWAPCountStock : nyVWAPCount
bool vwapColorDifferentiationActive = isStock ? vwapColorDifferentiationStock : vwapColorDifferentiation
int vwapMaxTransparencyActive = isStock ? vwapMaxTransparencyStock : vwapMaxTransparency
int vwapDesaturationActive = isStock ? vwapDesaturationStock : vwapDesaturation
int vwapBrightnessActive = isStock ? vwapBrightnessStock : vwapBrightness
int vwapHueShiftActive = isStock ? vwapHueShiftStock : vwapHueShift

showWeeklyAnchorVWAP = input.bool(true, "Enable Weekly VWAP Anchor", group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Show weekly VWAP anchor (first Primary Anchor Session of the trading week).")
weeklyAnchorMaxTimeframe = input.string("2h", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D"], group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Maximum chart timeframe where weekly VWAP anchors remain visible.")
colorWeeklyAnchor = input.color(#B01200, "Color", group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly")
weeklyAnchorCount = input.int(6, "History", minval=1, maxval=6, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Number of weekly anchors to show (1=current only, 2=current+previous).")
longTermAnchorColorDifferentiation = input.bool(true, "Fade Past Sessions", group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Visually de-emphasize older weekly VWAP anchors.")
longTermAnchorMaxTransparency = input.int(0, "Oldest Transparency", minval=0, maxval=95, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Transparency applied to the oldest visible weekly VWAP anchor (0=opaque).")
longTermAnchorDesaturation = input.int(0, "Desaturation", minval=0, maxval=100, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Reduce color vibrancy for older weekly VWAP anchors (0=vibrant, 100=gray).")
longTermAnchorBrightness = input.int(0, "Brightness", minval=-100, maxval=100, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Adjust brightness for older weekly VWAP anchors (0=no change, -=darker, +=brighter).")
longTermAnchorHueShift = input.int(-12, "Hue Shift", minval=-50, maxval=50, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Weekly", tooltip="Shift hue for older weekly VWAP anchors (-=cooler, +=warmer).")

showMonthlyAnchorVWAP = input.bool(true, "Enable Monthly VWAP Anchor", group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly")
monthlyAnchorMinTimeframe = input.string("4h", "Min Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W"], group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Minimum chart timeframe where monthly VWAP anchors become visible.")
monthlyAnchorMaxTimeframe = input.string("1D", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W"], group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Maximum chart timeframe where monthly VWAP anchors remain visible.")
colorMonthlyAnchor = input.color(#3B5BFF, "Color", group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly")
monthlyAnchorCount = input.int(6, "History", minval=1, maxval=6, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Number of monthly anchors to show (1=current only, 2=current+previous).")
monthlyAnchorColorDifferentiation = input.bool(true, "Fade Past Sessions", group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Visually de-emphasize older monthly VWAP anchors.")
monthlyAnchorMaxTransparency = input.int(0, "Oldest Transparency", minval=0, maxval=95, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Transparency applied to the oldest visible monthly VWAP anchor (0=opaque).")
monthlyAnchorDesaturation = input.int(80, "Desaturation", minval=0, maxval=100, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Reduce color vibrancy for older monthly VWAP anchors (0=vibrant, 100=gray).")
monthlyAnchorBrightness = input.int(0, "Brightness", minval=-100, maxval=100, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Adjust brightness for older monthly VWAP anchors (0=no change, -=darker, +=brighter).")
monthlyAnchorHueShift = input.int(6, "Hue Shift", minval=-50, maxval=50, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Monthly", tooltip="Shift hue for older monthly VWAP anchors (-=cooler, +=warmer).")

showYearlyAnchorVWAP = input.bool(true, "Enable Yearly VWAP Anchor", group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly")
yearlyAnchorMinTimeframe = input.string("15m", "Min Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W", "1M"], group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Minimum chart timeframe where yearly VWAP anchors become visible.")
yearlyAnchorMaxTimeframe = input.string("1W", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h", "1D", "1W", "1M"], group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Maximum chart timeframe where yearly VWAP anchors remain visible.")
colorYearlyAnchor = input.color(#000000, "Color", group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly")
yearlyAnchorCount = input.int(2, "History", minval=1, maxval=2, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Number of yearly anchors to show (1=current only, 2=current+previous).")
yearlyAnchorColorDifferentiation = input.bool(true, "Fade Past Sessions", group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Visually de-emphasize older yearly VWAP anchors.")
yearlyAnchorMaxTransparency = input.int(0, "Oldest Transparency", minval=0, maxval=95, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Transparency applied to the oldest visible yearly VWAP anchor (0=opaque).")
yearlyAnchorDesaturation = input.int(0, "Desaturation", minval=0, maxval=100, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Reduce color vibrancy for older yearly VWAP anchors (0=vibrant, 100=gray).")
yearlyAnchorBrightness = input.int(50, "Brightness", minval=-100, maxval=100, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Adjust brightness for older yearly VWAP anchors (0=no change, -=darker, +=brighter).")
yearlyAnchorHueShift = input.int(-12, "Hue Shift", minval=-50, maxval=50, group="ðŸ—“ï¸ Sessions â€¢ VWAP Anchors â€¢ Yearly", tooltip="Shift hue for older yearly VWAP anchors (-=cooler, +=warmer).")


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ Sessions â€¢ Levels â€¢ Visibility
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showSessionLevelsInput = input.string("Futures Only", "Enable Session Levels", options=["Always", "Futures Only", "Off"], group="ðŸ“ Sessions â€¢ Levels â€¢ Visibility", tooltip="Master switch for session levels (Opening Price, ORB, IB). Futures Only: show only on futures symbols.")
sessionLevelsMaxTimeframe = input.string("5m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ“ Sessions â€¢ Levels â€¢ Visibility", tooltip="Hide session levels on timeframes above this")
sessionLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸ“ Sessions â€¢ Levels â€¢ Visibility")
sessionLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ðŸ“ Sessions â€¢ Levels â€¢ Visibility", tooltip="Width for Opening Price / ORB / IB lines")
sessionLineStartMode = input.string("Level Established", "Line Start", options=["Session Open", "Level Established", "Fixed Bars Back"], group="ðŸ“ Sessions â€¢ Levels â€¢ Visibility", tooltip="Session Open: from session start\nLevel Established: from where level was created\nFixed Bars Back: use ðŸ·ï¸ Horizontal Levels â†’ Line Length (Bars)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ Sessions â€¢ Levels â€¢ Opening Price
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showOpenPrice = input.bool(true, "Enable Opening Price", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Price")
colorOpenPrice = input.color(#fbbe30, "Color", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Price", tooltip="First traded price at session open")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ Sessions â€¢ Levels â€¢ Opening Range (ORB)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showOpenRange = input.bool(true, "Enable Opening Range (ORB)", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range (ORB)", tooltip="High/Low of the first 15â€“30 minutes after session open.")
openRangeLength = input.string("15m", "Length", options=["15m", "30m"], group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range (ORB)")
colorORH = input.color(#4682b4, "High", inline="SL_ORC", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range (ORB)")
colorORL = input.color(#cd5c5c, "Low", inline="SL_ORC", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range (ORB)")
shadeOpenRange = input.bool(true, "Shade", inline="SL_ORC", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range (ORB)")
colorOpenRangeShade = input.color(color.new(color.black, 98), "", inline="SL_ORC", group="ðŸ“ Sessions â€¢ Levels â€¢ Opening Range (ORB)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance (IB)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showInitialBalance = input.bool(false, "Enable Initial Balance (IB)", group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance (IB)", tooltip="High/Low of the first 30â€“60 minutes after session open.")
initialBalanceLength = input.string("1h", "Length", options=["30m", "1h"], group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance (IB)")
colorIBH = input.color(#81ce6f, "High", inline="SL_IBC", group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance (IB)")
colorIBL = input.color(#e43b38, "Low", inline="SL_IBC", group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance (IB)")
shadeInitialBalance = input.bool(true, "Shade", inline="SL_IBC", group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance (IB)")
colorInitialBalanceShade = input.color(color.new(color.green, 95), "", inline="SL_IBC", group="ðŸ“ Sessions â€¢ Levels â€¢ Initial Balance (IB)")



showPivots = input.bool(true, "Enable Pivot Points", group="ðŸ” Pivot Points", tooltip="Traditional pivots calculated from the previous day's High/Low/Close.")
pivotMaxTimeframe = input.string("4h", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ” Pivot Points", tooltip="Hide on timeframes above this")
pivotLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸ” Pivot Points")
pivotLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ðŸ” Pivot Points")

showPivotR3 = input.bool(true, "R3", inline="PV_R3", group="ðŸ” Pivot Points")
pivotColorR3 = input.color(#449955, "", inline="PV_R3", group="ðŸ” Pivot Points")
showPivotR2 = input.bool(true, "R2", inline="PV_R2", group="ðŸ” Pivot Points")
pivotColorR2 = input.color(#449955, "", inline="PV_R2", group="ðŸ” Pivot Points")
showPivotR1 = input.bool(false, "R1", inline="PV_R1", group="ðŸ” Pivot Points")
pivotColorR1 = input.color(#449955, "", inline="PV_R1", group="ðŸ” Pivot Points")

showPivotP = input.bool(false, "Pivot (P)", inline="PV_P", group="ðŸ” Pivot Points")
pivotColorP = input.color(#808080, "", inline="PV_P", group="ðŸ” Pivot Points")

showPivotS1 = input.bool(false, "S1", inline="PV_S1", group="ðŸ” Pivot Points")
pivotColorS1 = input.color(#b51b00, "", inline="PV_S1", group="ðŸ” Pivot Points")
showPivotS2 = input.bool(true, "S2", inline="PV_S2", group="ðŸ” Pivot Points")
pivotColorS2 = input.color(#b51b00, "", inline="PV_S2", group="ðŸ” Pivot Points")
showPivotS3 = input.bool(true, "S3", inline="PV_S3", group="ðŸ” Pivot Points")
pivotColorS3 = input.color(#b51b00, "", inline="PV_S3", group="ðŸ” Pivot Points")



showKeyLevels = input.bool(true, "Enable Key Levels", group="ðŸ“ˆ Key Levels", tooltip="Master toggle for key levels (ATH, Year/Month/Week/Day High/Low).")
keyLevelsMaxTimeframe = input.string("15m", "Max Timeframe", options=["None", "1m", "2m", "3m", "5m", "15m", "30m", "1h", "65m", "2h", "4h"], group="ðŸ“ˆ Key Levels", tooltip="Hide on timeframes above this")
keyLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="ðŸ“ˆ Key Levels")
keyLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="ðŸ“ˆ Key Levels")

showATH = input.bool(true, "All-Time High", inline="KL_ATH", group="ðŸ“ˆ Key Levels â€¢ All-Time High")
colorATH = input.color(#00fcff, "Color", inline="KL_ATH", group="ðŸ“ˆ Key Levels â€¢ All-Time High", tooltip="All-time high")

showCYH = input.bool(true, "Current", inline="KL_CY", group="ðŸ“ˆ Key Levels â€¢ Year")
colorCYH = input.color(#449955, "High", inline="KL_CY", group="ðŸ“ˆ Key Levels â€¢ Year")
showCYL = input.bool(true, "", inline="KL_CY", group="ðŸ“ˆ Key Levels â€¢ Year")
colorCYL = input.color(#b51b00, "Low", inline="KL_CY", group="ðŸ“ˆ Key Levels â€¢ Year")

showPYH = input.bool(true, "Previous", inline="KL_PY", group="ðŸ“ˆ Key Levels â€¢ Year")
colorPYH = input.color(#449955, "High", inline="KL_PY", group="ðŸ“ˆ Key Levels â€¢ Year")
showPYL = input.bool(true, "", inline="KL_PY", group="ðŸ“ˆ Key Levels â€¢ Year")
colorPYL = input.color(#b51b00, "Low", inline="KL_PY", group="ðŸ“ˆ Key Levels â€¢ Year")

showCMH = input.bool(true, "Current", inline="KL_CM", group="ðŸ“ˆ Key Levels â€¢ Month")
colorCMH = input.color(#449955, "High", inline="KL_CM", group="ðŸ“ˆ Key Levels â€¢ Month")
showCML = input.bool(true, "", inline="KL_CM", group="ðŸ“ˆ Key Levels â€¢ Month")
colorCML = input.color(#b51b00, "Low", inline="KL_CM", group="ðŸ“ˆ Key Levels â€¢ Month")

showPMH = input.bool(true, "Previous", inline="KL_PM", group="ðŸ“ˆ Key Levels â€¢ Month")
colorPMH = input.color(#449955, "High", inline="KL_PM", group="ðŸ“ˆ Key Levels â€¢ Month")
showPML = input.bool(true, "", inline="KL_PM", group="ðŸ“ˆ Key Levels â€¢ Month")
colorPML = input.color(#b51b00, "Low", inline="KL_PM", group="ðŸ“ˆ Key Levels â€¢ Month")

showCWH = input.bool(true, "Current", inline="KL_CW", group="ðŸ“ˆ Key Levels â€¢ Week")
colorCWH = input.color(#449955, "High", inline="KL_CW", group="ðŸ“ˆ Key Levels â€¢ Week")
showCWL = input.bool(true, "", inline="KL_CW", group="ðŸ“ˆ Key Levels â€¢ Week")
colorCWL = input.color(#b51b00, "Low", inline="KL_CW", group="ðŸ“ˆ Key Levels â€¢ Week")

showPWH = input.bool(true, "Previous", inline="KL_PW", group="ðŸ“ˆ Key Levels â€¢ Week")
colorPWH = input.color(#449955, "High", inline="KL_PW", group="ðŸ“ˆ Key Levels â€¢ Week")
showPWL = input.bool(true, "", inline="KL_PW", group="ðŸ“ˆ Key Levels â€¢ Week")
colorPWL = input.color(#b51b00, "Low", inline="KL_PW", group="ðŸ“ˆ Key Levels â€¢ Week")

showCDH = input.bool(true, "Current", inline="KL_CD", group="ðŸ“ˆ Key Levels â€¢ Day")
colorCDH = input.color(#449955, "High", inline="KL_CD", group="ðŸ“ˆ Key Levels â€¢ Day")
showCDL = input.bool(true, "", inline="KL_CD", group="ðŸ“ˆ Key Levels â€¢ Day")
colorCDL = input.color(#b51b00, "Low", inline="KL_CD", group="ðŸ“ˆ Key Levels â€¢ Day")

showPDH = input.bool(true, "Previous", inline="KL_PD", group="ðŸ“ˆ Key Levels â€¢ Day")
colorPDH = input.color(#449955, "High", inline="KL_PD", group="ðŸ“ˆ Key Levels â€¢ Day")
showPDL = input.bool(true, "", inline="KL_PD", group="ðŸ“ˆ Key Levels â€¢ Day")
colorPDL = input.color(#b51b00, "Low", inline="KL_PD", group="ðŸ“ˆ Key Levels â€¢ Day")



// HELPER FUNCTIONS


getLabelSize(string sizeStr) =>
    sizeStr == "Tiny" ? size.tiny : sizeStr == "Small" ? size.small : sizeStr == "Large" ? size.large : sizeStr == "Huge" ? size.huge : size.normal

getLineStyle(string styleStr) =>
    styleStr == "Solid" ? line.style_solid : styleStr == "Dashed" ? line.style_dashed : line.style_dotted

labelBgColor(color c) => color.new(c, 100)

roundToTick(float price) =>
    syminfo.mintick > 0 ? math.round(price / syminfo.mintick) * syminfo.mintick : price

updateBox(box boxRef, int x1, float y1, int x2, float y2, color bg) =>
    if na(boxRef)
        box.new(x1, y1, x2, y2, border_color=na, bgcolor=bg)
    else
        box.set_lefttop(boxRef, x1, y1)
        box.set_rightbottom(boxRef, x2, y2)
        boxRef

// RGB to HSL conversion
rgbToHsl(float r, float g, float b) =>
    float rNorm = r / 255.0
    float gNorm = g / 255.0
    float bNorm = b / 255.0

    float maxVal = math.max(rNorm, math.max(gNorm, bNorm))
    float minVal = math.min(rNorm, math.min(gNorm, bNorm))
    float delta = maxVal - minVal

    float h = 0.0
    float s = 0.0
    float l = (maxVal + minVal) / 2.0

    if delta != 0
        s := l > 0.5 ? delta / (2.0 - maxVal - minVal) : delta / (maxVal + minVal)

        if maxVal == rNorm
            h := ((gNorm - bNorm) / delta + (gNorm < bNorm ? 6.0 : 0.0)) / 6.0
        else if maxVal == gNorm
            h := ((bNorm - rNorm) / delta + 2.0) / 6.0
        else
            h := ((rNorm - gNorm) / delta + 4.0) / 6.0

    [h, s, l]

// HSL to RGB conversion helper
hueToRgb(float p, float q, float t) =>
    float tAdj = t < 0.0 ? t + 1.0 : (t > 1.0 ? t - 1.0 : t)
    float result = tAdj < 1.0/6.0 ? p + (q - p) * 6.0 * tAdj :
                  (tAdj < 1.0/2.0 ? q :
                  (tAdj < 2.0/3.0 ? p + (q - p) * (2.0/3.0 - tAdj) * 6.0 : p))
    result

// HSL to RGB conversion
hslToRgb(float h, float s, float l) =>
    if s == 0
        [int(l * 255.0), int(l * 255.0), int(l * 255.0)]
    else
        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s
        float p = 2.0 * l - q
        [int(hueToRgb(p, q, h + 1.0/3.0) * 255.0), int(hueToRgb(p, q, h) * 255.0), int(hueToRgb(p, q, h - 1.0/3.0) * 255.0)]

// Check if level price is within ATR distance from current price
isWithinATR(float levelPrice, float currentPrice, float threshold, bool filterEnabled) =>
    not filterEnabled or na(levelPrice) or math.abs(levelPrice - currentPrice) <= threshold

// Get compact session abbreviation for daily sessions
getSessionAbbr(string sessionName) =>
    sessionName == "London" ? "LN" : sessionName == "New York" ? "NY" : sessionName == "Globex" ? "GLX" : sessionName == "Sydney" ? "SYD" : "TKY"

// LEVEL RENDERER UDT


type LevelRenderer
    string name
    bool enabled
    float price
    float priceRounded
    int startBar
    color levelColor
    int lineWidth
    string lineStyle
    line lineRef
    label labelRef

// Render method for a single level with deduplication support
method render(LevelRenderer this, bool groupCondition, bool checkDuplicate, map<float, string> priceLabels, array<float> renderedPrices, bool globalShowPriceValues, string labelSizeActual, float atrThreshold, bool useATRFilter) =>
    if groupCondition and this.enabled and not na(this.price) and isWithinATR(this.price, close, atrThreshold, useATRFilter) and (not checkDuplicate or not array.includes(renderedPrices, this.priceRounded))
        string combinedLabel = map.contains(priceLabels, this.priceRounded) ? map.get(priceLabels, this.priceRounded) : this.name
        string labelText = globalShowPriceValues ? combinedLabel + " (" + str.tostring(this.price, format.mintick) + ")" : combinedLabel
        if na(this.lineRef)
            line tempLine = line.new(this.startBar, this.price, bar_index, this.price, color=this.levelColor, width=this.lineWidth, style=getLineStyle(this.lineStyle))
            label tempLabel = label.new(bar_index, this.price, labelText, color=labelBgColor(this.levelColor), textcolor=this.levelColor, style=label.style_label_left, size=labelSizeActual)
            this.lineRef := tempLine
            this.labelRef := tempLabel
            true
        else
            line.set_xy1(this.lineRef, this.startBar, this.price)
            line.set_xy2(this.lineRef, bar_index, this.price)
            label.set_xy(this.labelRef, bar_index, this.price)
            label.set_text(this.labelRef, labelText)
            true
        array.push(renderedPrices, this.priceRounded)
        true
    else if not na(this.lineRef)
        line.delete(this.lineRef)
        this.lineRef := na
        label.delete(this.labelRef)
        this.labelRef := na
        true
    else
        true

method update(LevelRenderer this, bool enabled, float price, float priceRounded, int startBar) =>
    this.enabled := enabled
    this.price := price
    this.priceRounded := priceRounded
    this.startBar := startBar
    true

deleteLabel(array<label> labelArray, int idx) =>
    label oldLabel = array.get(labelArray, idx)
    if not na(oldLabel)
        label.delete(oldLabel)



// Calculate color with transparency, hue shift, desaturation, and brightness based on VWAP position in history (0 = most recent)
getVWAPColor(color baseColor, int positionInHistory, bool useDifferentiation, int maxTransp, int hueShift, int desat, int brightness, int maxPos = 4) =>
    if not useDifferentiation or positionInHistory == 0
        baseColor
    else
        // Linear gradient for transparency
        float normalizedPos = maxPos > 0 ? positionInHistory / float(maxPos) : 0.0
        int transparency = int(normalizedPos * maxTransp)

        // Extract RGB components
        float origR = color.r(baseColor)
        float origG = color.g(baseColor)
        float origB = color.b(baseColor)

        // Convert to HSL for proper hue rotation
        [h, s, l] = rgbToHsl(origR, origG, origB)

        // Apply hue shift (rotate around color wheel)
        if hueShift != 0
            float hueShiftAmount = (normalizedPos * hueShift) / 50.0  // -1.0 to +1.0 range
            h := h + hueShiftAmount
            h := h < 0.0 ? h + 1.0 : (h > 1.0 ? h - 1.0 : h)  // Wrap around

        // Apply desaturation
        if desat > 0
            float desatFactor = (normalizedPos * desat) / 100.0
            s := s * (1.0 - desatFactor)

        // Apply brightness adjustment
        if brightness != 0
            float brightnessFactor = (normalizedPos * brightness) / 100.0
            l := math.max(0.0, math.min(1.0, l + brightnessFactor))

        // Convert back to RGB
        [newR, newG, newB] = hslToRgb(h, s, l)

        // Apply transparency
        color.rgb(newR, newG, newB, math.min(transparency, maxTransp))

// Session time definitions in session's local timezone
// LSE: 8:00 AM - 4:30 PM GMT
// NYSE/CME: 9:30 AM - 4:00 PM EST
// CME Globex: 6:00 PM - 5:00 PM ET (next day, spans 2 calendar days)
// ASX: 10:00 AM - 4:00 PM AEDT
// TSE: 9:00 AM - 3:00 PM JST

getSessionTimezone(string session) =>
    session == "London" ? "Europe/London" : session == "New York" ? "America/New_York" : session == "Globex" ? "America/New_York" : session == "Sydney" ? "Australia/Sydney" : "Asia/Tokyo"

getSessionStartHour(string session) =>
    session == "London" ? 8 : session == "New York" ? 9 : session == "Globex" ? 18 : session == "Sydney" ? 10 : 9

getSessionStartMinute(string session) =>
    session == "New York" ? 30 : 0

getSessionEndHour(string session) =>
    session == "London" ? 16 : session == "New York" ? 16 : session == "Globex" ? 17 : session == "Sydney" ? 16 : 15

getSessionEndMinute(string session) =>
    session == "London" ? 30 : 0

// Calculate session start timestamp for a specific date (calendar-based, pre-calculated)
getSessionStartForDate(string session, int y, int m, int d) =>
    string tz = getSessionTimezone(session)
    int sessionHour = getSessionStartHour(session)
    int sessionMinute = getSessionStartMinute(session)
    timestamp(tz, y, m, d, sessionHour, sessionMinute)

// Calculate session end timestamp for a specific date
// Note: For Globex, end is on NEXT calendar day (starts 6 PM, ends 5 PM next day)
getSessionEndForDate(string session, int y, int m, int d) =>
    string tz = getSessionTimezone(session)
    int sessionHour = getSessionEndHour(session)
    int sessionMinute = getSessionEndMinute(session)
    // Globex spans two days: starts evening, ends next afternoon
    if session == "Globex"
        // Add 24 hours in milliseconds to base timestamp instead of incrementing day
        int baseTimestamp = timestamp(tz, y, m, d, sessionHour, sessionMinute)
        baseTimestamp + 86400000  // Add 1 day in milliseconds
    else
        timestamp(tz, y, m, d, sessionHour, sessionMinute)

// Common helper to collect session timestamps (start or end) for last N sessions
// CRITICAL: Collects trading days but avoids duplicate timestamps
// - Tracks each day's session timestamp
// - For Globex: Mon-Fri all map to same Sunday start, so we deduplicate
getSessionTimestampsArray(string session, int sessionsBack, bool isStart) =>
    var array<int> timestamps = array.new<int>()
    array.clear(timestamps)

    // Get session timezone to ensure date calculations are consistent
    string tz = getSessionTimezone(session)

    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    int currentD = dayofmonth(timenow, tz)
    int currentDayOfWeek = dayofweek(timenow, tz)

    // Adjust weekend to Friday; Globex trades Sunday so don't adjust Sunday for Globex
    if currentDayOfWeek == dayofweek.saturday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)
    else if currentDayOfWeek == dayofweek.sunday and session != "Globex"
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 172800000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)

    // For Globex on Mon-Fri, the session for "today" actually starts yesterday evening
    // So we need to check yesterday's session start time
    int todaySessionStart = na
    if session == "Globex" and currentDayOfWeek >= dayofweek.monday and currentDayOfWeek <= dayofweek.friday
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        int prevY = year(yesterdayMidnight, tz)
        int prevM = month(yesterdayMidnight, tz)
        int prevD = dayofmonth(yesterdayMidnight, tz)
        todaySessionStart := getSessionStartForDate(session, prevY, prevM, prevD)
    else
        todaySessionStart := getSessionStartForDate(session, currentY, currentM, currentD)

    int mostRecentY = currentY
    int mostRecentM = currentM
    int mostRecentD = currentD

    if timenow < todaySessionStart
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        mostRecentY := year(yesterdayMidnight, tz)
        mostRecentM := month(yesterdayMidnight, tz)
        mostRecentD := dayofmonth(yesterdayMidnight, tz)

    int sessionsCollected = 0
    int daysBackOffset = 0
    int lastTimestamp = na

    while sessionsCollected < sessionsBack
        int targetMidnight = timestamp(tz, mostRecentY, mostRecentM, mostRecentD, 0, 0) - (daysBackOffset * 86400000)
        int y = year(targetMidnight, tz)
        int m = month(targetMidnight, tz)
        int d = dayofmonth(targetMidnight, tz)
        int dow = dayofweek(targetMidnight, tz)

        bool isTradingDay = false
        if session == "Globex"
            isTradingDay := dow == dayofweek.sunday or (dow >= dayofweek.monday and dow <= dayofweek.friday)
        else
            isTradingDay := dow >= dayofweek.monday and dow <= dayofweek.friday

        if isTradingDay
            // For Globex: session active on day D starts evening of day D-1, EXCEPT Sunday
            int ts = na
            if session == "Globex"
                if dow == dayofweek.sunday
                    ts := isStart ? getSessionStartForDate(session, y, m, d) : getSessionEndForDate(session, y, m, d)
                else
                    int prevDayMidnight = timestamp(tz, y, m, d, 0, 0) - 86400000
                    int prevY = year(prevDayMidnight, tz)
                    int prevM = month(prevDayMidnight, tz)
                    int prevD = dayofmonth(prevDayMidnight, tz)
                    ts := isStart ? getSessionStartForDate(session, prevY, prevM, prevD) : getSessionEndForDate(session, prevY, prevM, prevD)
            else
                ts := isStart ? getSessionStartForDate(session, y, m, d) : getSessionEndForDate(session, y, m, d)

            if na(lastTimestamp) or ts != lastTimestamp
                array.unshift(timestamps, ts)
                lastTimestamp := ts
                sessionsCollected := sessionsCollected + 1

        daysBackOffset := daysBackOffset + 1

    timestamps

getSessionStartsArray(string session, int sessionsBack) =>
    getSessionTimestampsArray(session, sessionsBack, true)

getSessionEndsArray(string session, int sessionsBack) =>
    getSessionTimestampsArray(session, sessionsBack, false)


// Weekly anchor start timestamps (Monday for most, Sunday for Globex)
getWeeklyAnchorStartsArray(string session, int weeksBack) =>
    var array<int> starts = array.new<int>()
    array.clear(starts)

    string tz = getSessionTimezone(session)

    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    int currentD = dayofmonth(timenow, tz)
    int currentDayOfWeek = dayofweek(timenow, tz)

    // Step 2: Adjust weekend to Friday (same as daily sessions)
    if currentDayOfWeek == dayofweek.saturday
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)
    else if currentDayOfWeek == dayofweek.sunday and session != "Globex"
        int fridayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 172800000
        currentY := year(fridayMidnight, tz)
        currentM := month(fridayMidnight, tz)
        currentD := dayofmonth(fridayMidnight, tz)

    // Step 3: Check if today's session has started
    int todaySessionStart = getSessionStartForDate(session, currentY, currentM, currentD)
    int mostRecentY = currentY
    int mostRecentM = currentM
    int mostRecentD = currentD

    if timenow < todaySessionStart
        int yesterdayMidnight = timestamp(tz, currentY, currentM, currentD, 0, 0) - 86400000
        mostRecentY := year(yesterdayMidnight, tz)
        mostRecentM := month(yesterdayMidnight, tz)
        mostRecentD := dayofmonth(yesterdayMidnight, tz)

    // Step 4: Walk backwards collecting only week-start days (Monday or Sunday)
    int targetDayOfWeek = session == "Globex" ? dayofweek.sunday : dayofweek.monday
    int weeksCollected = 0
    int daysBackOffset = 0

    while weeksCollected < weeksBack
        int targetMidnight = timestamp(tz, mostRecentY, mostRecentM, mostRecentD, 0, 0) - (daysBackOffset * 86400000)
        int y = year(targetMidnight, tz)
        int m = month(targetMidnight, tz)
        int d = dayofmonth(targetMidnight, tz)
        int dow = dayofweek(targetMidnight, tz)

        if dow == targetDayOfWeek
            // This is a week-start day - add the session start
            int weekStart = getSessionStartForDate(session, y, m, d)
            array.unshift(starts, weekStart)
            weeksCollected := weeksCollected + 1

        daysBackOffset := daysBackOffset + 1

    starts

// Find first valid trading day of a month (returns day 1-31, or na if none found in 14 days)
getFirstTradingDayOfMonth(string session, int targetYear, int targetMonth) =>
    string tz = getSessionTimezone(session)
    int foundDay = na
    for dayOffset = 0 to 13
        int testDay = dayOffset + 1
        if testDay > 31
            break
        int testTs = timestamp(tz, targetYear, targetMonth, testDay, 0, 0)
        int testYear = year(testTs, tz)
        int testMonth = month(testTs, tz)
        if testYear != targetYear or testMonth != targetMonth
            break
        int dow = dayofweek(testTs, tz)
        bool isValidTradingDay = session == "Globex" ? (dow == dayofweek.sunday or (dow >= dayofweek.monday and dow <= dayofweek.friday)) : (dow >= dayofweek.monday and dow <= dayofweek.friday)
        if isValidTradingDay
            foundDay := testDay
            break
    foundDay

// Monthly anchor start timestamps (first session of each month)
getMonthlyAnchorStartsArray(string session, int monthsBack) =>
    var array<int> starts = array.new<int>()
    array.clear(starts)
    string tz = getSessionTimezone(session)
    int currentY = year(timenow, tz)
    int currentM = month(timenow, tz)
    if na(currentY) or na(currentM)
        for i = 0 to monthsBack - 1
            array.unshift(starts, na)
    else
        for i = 0 to monthsBack - 1
            int targetM = currentM - i
            int targetY = currentY
            while targetM < 1
                targetM := targetM + 12
                targetY := targetY - 1
            int firstDay = getFirstTradingDayOfMonth(session, targetY, targetM)
            if not na(firstDay)
                int monthStart = getSessionStartForDate(session, targetY, targetM, firstDay)
                array.unshift(starts, monthStart)
            else
                array.unshift(starts, na)
    starts

// Yearly anchor start timestamps (first session of each year)
getYearlyAnchorStartsArray(string session, int yearsBack) =>
    var array<int> starts = array.new<int>()
    array.clear(starts)
    string tz = getSessionTimezone(session)
    int currentY = year(timenow, tz)
    if na(currentY)
        for i = 0 to yearsBack - 1
            array.unshift(starts, na)
    else
        for i = 0 to yearsBack - 1
            int targetY = currentY - i
            int firstDay = getFirstTradingDayOfMonth(session, targetY, 1)
            if not na(firstDay)
                int yearStart = getSessionStartForDate(session, targetY, 1, firstDay)
                array.unshift(starts, yearStart)
            else
                array.unshift(starts, na)
    starts

// Convert period string to minutes
periodToMinutes(string period) =>
    period == "1m" ? 1 : period == "2m" ? 2 : period == "3m" ? 3 : period == "5m" ? 5 : period == "15m" ? 15 : period == "30m" ? 30 : period == "1h" ? 60 : period == "65m" ? 65 : period == "2h" ? 120 : period == "4h" ? 240 : period == "1D" ? 1440 : 99999

// Get timeframe in minutes for comparison
getTimeframeMinutes() =>
    int tfSeconds = timeframe.in_seconds()
    if tfSeconds >= 86400
        // Daily or larger timeframes return as days
        int days = tfSeconds / 86400
        days * 1440  // Convert days to minutes
    else
        tfSeconds / 60

// Add level to priceLabels map with duplicate detection
addToMap(map<float, string> priceMap, float price, string label) =>
    float key = roundToTick(price)
    string existing = map.contains(priceMap, key) ? map.get(priceMap, key) : ""
    if existing != ""
        map.put(priceMap, key, existing + "/" + label)
    else
        map.put(priceMap, key, label)

// DISPLAY CONDITIONS & ATR FILTERING

float atrValue = request.security(syminfo.tickerid, "D", ta.atr(atrPeriod), lookahead=barmerge.lookahead_on)
float atrThreshold = atrValue * atrMultiplier

bool isFutures = syminfo.type == "futures"

// Check timeframe conditions
int currentTfMinutes = getTimeframeMinutes()
bool meetsMaxTimeframe = keyLevelsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(keyLevelsMaxTimeframe)

// Check if key levels should be shown (max timeframe filter only)
bool showKeyLevelsCondition = showKeyLevels and meetsMaxTimeframe

// Determine primary session name (used for long-term anchor and primary session logic)
string primarySessionName = longTermAnchorSession == "Auto" ? (syminfo.type == "stock" ? "New York" : "Globex") : longTermAnchorSession

// Check timeframe conditions for session features
bool meetsOtherSessionsTimeframe = otherSessionsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(otherSessionsMaxTimeframe)
bool meetsLongTermAnchorSessionTimeframe = longTermAnchorSessionMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(longTermAnchorSessionMaxTimeframe)
bool sessionBaseCondition = showSessionMarkers
bool showSessionMarkersCondition = sessionBaseCondition and meetsOtherSessionsTimeframe

// Individual session VWAP timeframe checks (long-term anchor session gets extended visibility, others are intraday-only)
bool meetsLondonVWAPTimeframe = primarySessionName == "London" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsNYVWAPTimeframe = primarySessionName == "New York" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsGlobexVWAPTimeframe = primarySessionName == "Globex" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsSydneyVWAPTimeframe = primarySessionName == "Sydney" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe
bool meetsTokyoVWAPTimeframe = primarySessionName == "Tokyo" ? meetsLongTermAnchorSessionTimeframe : meetsOtherSessionsTimeframe

// Check timeframe conditions for session levels and pivot features
bool meetsSessionLevelsMaxTimeframe = sessionLevelsMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(sessionLevelsMaxTimeframe)
bool meetsPivotMaxTimeframe = pivotMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(pivotMaxTimeframe)
bool showPivotsCondition = showPivots and meetsPivotMaxTimeframe

// NY session filter for stocks and equity indices (RTH = 9:30 AM - 4:00 PM ET, bars before 4:00 PM)
int nyHour = hour(time, "America/New_York")
int nyMinute = minute(time, "America/New_York")
bool isNYSession = (nyHour == 9 and nyMinute >= 30) or (nyHour > 9 and nyHour < 16)
bool isEquityIndex = syminfo.type == "futures" and (str.contains(syminfo.ticker, "ES") or str.contains(syminfo.ticker, "MES") or str.contains(syminfo.ticker, "NQ") or str.contains(syminfo.ticker, "MNQ") or str.contains(syminfo.ticker, "RTY") or str.contains(syminfo.ticker, "M2K") or str.contains(syminfo.ticker, "YM") or str.contains(syminfo.ticker, "MYM"))
bool shouldFilterRTH = (rthOnlyForStocks and syminfo.type == "stock") or (rthOnlyForIndices and isEquityIndex)
bool isRTHBar = not shouldFilterRTH or isNYSession

// Check timeframe condition for weekly anchors
bool meetsWeeklyAnchorMaxTimeframe = weeklyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(weeklyAnchorMaxTimeframe)
bool meetsMonthlyAnchorMinTimeframe = monthlyAnchorMinTimeframe == "None" or currentTfMinutes >= periodToMinutes(monthlyAnchorMinTimeframe)
bool meetsMonthlyAnchorMaxTimeframe = monthlyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(monthlyAnchorMaxTimeframe)
bool meetsMonthlyAnchorTimeframe = meetsMonthlyAnchorMinTimeframe and meetsMonthlyAnchorMaxTimeframe
bool meetsYearlyAnchorMinTimeframe = yearlyAnchorMinTimeframe == "None" or currentTfMinutes >= periodToMinutes(yearlyAnchorMinTimeframe)
bool meetsYearlyAnchorMaxTimeframe = yearlyAnchorMaxTimeframe == "None" or currentTfMinutes <= periodToMinutes(yearlyAnchorMaxTimeframe)
bool meetsYearlyAnchorTimeframe = meetsYearlyAnchorMinTimeframe and meetsYearlyAnchorMaxTimeframe

// KEY LEVELS DATA - Conditional requests for performance
var float pdh = na, var float pdl = na
var float pwh = na, var float pwl = na
var float pmh = na, var float pml = na
var float pyh = na, var float pyl = na

// Previous period levels - only update on confirmed bars (static values don't change intrabar)
if barstate.isconfirmed and showKeyLevelsCondition and (showPDH or showPDL or showCDH or showCDL)
    [_pdh, _pdl] = request.security(syminfo.tickerid, "D", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pdh := _pdh, pdl := _pdl
if barstate.isconfirmed and showKeyLevelsCondition and (showPWH or showPWL or showCWH or showCWL)
    [_pwh, _pwl] = request.security(syminfo.tickerid, "W", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pwh := _pwh, pwl := _pwl
if barstate.isconfirmed and showKeyLevelsCondition and (showPMH or showPML or showCMH or showCML)
    [_pmh, _pml] = request.security(syminfo.tickerid, "M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pmh := _pmh, pml := _pml
if barstate.isconfirmed and showKeyLevelsCondition and (showPYH or showPYL or showCYH or showCYL)
    [_pyh, _pyl] = request.security(syminfo.tickerid, "12M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
    pyh := _pyh, pyl := _pyl

// Current period levels (developing periods)
var float cdh = na, var float cdl = na
var float cwh = na, var float cwl = na
var float cmh = na, var float cml = na
var float cyh = na, var float cyl = na

if showKeyLevelsCondition and (showCDH or showCDL)
    [_cdh, _cdl] = request.security(syminfo.tickerid, "D", [high, low], lookahead=barmerge.lookahead_on)
    cdh := _cdh, cdl := _cdl
if showKeyLevelsCondition and (showCWH or showCWL)
    [_cwh, _cwl] = request.security(syminfo.tickerid, "W", [high, low], lookahead=barmerge.lookahead_on)
    cwh := _cwh, cwl := _cwl
if showKeyLevelsCondition and (showCMH or showCML)
    [_cmh, _cml] = request.security(syminfo.tickerid, "M", [high, low], lookahead=barmerge.lookahead_on)
    cmh := _cmh, cml := _cml
if showKeyLevelsCondition and (showCYH or showCYL)
    [_cyh, _cyl] = request.security(syminfo.tickerid, "12M", [high, low], lookahead=barmerge.lookahead_on)
    cyh := _cyh, cyl := _cyl

var float ath = na
float _ath = ta.highest(high, bar_index + 1)
if barstate.isconfirmed
    ath := showKeyLevelsCondition and showATH ? request.security(syminfo.tickerid, "M", _ath, lookahead=barmerge.lookahead_on) : na

// PIVOT POINTS (from previous day's HLC)
var float dailyHigh = na, var float dailyLow = na, var float dailyClose = na
if barstate.isconfirmed
    [_dailyHigh, _dailyLow, _dailyClose] = request.security(syminfo.tickerid, "D", [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    dailyHigh := _dailyHigh
    dailyLow := _dailyLow
    dailyClose := _dailyClose

float dailyRange = dailyHigh - dailyLow
float pivotP = (dailyHigh + dailyLow + dailyClose) / 3
float pivotR1 = 2 * pivotP - dailyLow
float pivotS1 = 2 * pivotP - dailyHigh
float pivotR2 = pivotP + dailyRange
float pivotS2 = pivotP - dailyRange
float pivotR3 = dailyHigh + 2 * (pivotP - dailyLow)
float pivotS3 = dailyLow - 2 * (dailyHigh - pivotP)

var array<LevelRenderer> keyLevels = array.new<LevelRenderer>()
var array<LevelRenderer> pivotLevels = array.new<LevelRenderer>()
var array<LevelRenderer> sessionLevels = array.new<LevelRenderer>()

// MULTI-SESSION INFRASTRUCTURE

const int MAX_VWAP_HISTORY = 10
const int MAX_WEEKLY_HISTORY = 6
const int MAX_MONTHLY_HISTORY = 6
const int MAX_YEARLY_HISTORY = 2

var array<bool> sessionEnabled = array.from(enableLondonActive, enableNewYorkActive, enableGlobexActive, enableSydneyActive, enableTokyoActive)
var array<string> sessionNames = array.from("London", "New York", "Globex", "Sydney", "Tokyo")
var array<color> sessionColors = array.from(colorLondonActive, colorNewYorkActive, colorGlobexActive, colorSydneyActive, colorTokyoActive)

var array<int> londonStarts = array.new<int>()
var array<int> nyStarts = array.new<int>()
var array<int> globexStarts = array.new<int>()
var array<int> sydneyStarts = array.new<int>()
var array<int> tokyoStarts = array.new<int>()

var array<int> londonEnds = array.new<int>()
var array<int> nyEnds = array.new<int>()
var array<int> globexEnds = array.new<int>()
var array<int> sydneyEnds = array.new<int>()
var array<int> tokyoEnds = array.new<int>()

if barstate.isfirst
    londonStarts := getSessionStartsArray("London", MAX_VWAP_HISTORY)
    nyStarts := getSessionStartsArray("New York", MAX_VWAP_HISTORY)
    globexStarts := getSessionStartsArray("Globex", MAX_VWAP_HISTORY)
    sydneyStarts := getSessionStartsArray("Sydney", MAX_VWAP_HISTORY)
    tokyoStarts := getSessionStartsArray("Tokyo", MAX_VWAP_HISTORY)

    londonEnds := getSessionEndsArray("London", MAX_VWAP_HISTORY)
    nyEnds := getSessionEndsArray("New York", MAX_VWAP_HISTORY)
    globexEnds := getSessionEndsArray("Globex", MAX_VWAP_HISTORY)
    sydneyEnds := getSessionEndsArray("Sydney", MAX_VWAP_HISTORY)
    tokyoEnds := getSessionEndsArray("Tokyo", MAX_VWAP_HISTORY)

var array<float> londonSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> londonSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> nySumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> nySumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> globexSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> globexSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> sydneySumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> sydneySumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> tokyoSumSrc = array.new<float>(MAX_VWAP_HISTORY, 0.0)
var array<float> tokyoSumVol = array.new<float>(MAX_VWAP_HISTORY, 0.0)

var array<int> sessionStartBars = array.new<int>(5, na)
var array<int> sessionStartTimes = array.new<int>(5, na)
var array<label> sessionLabels = array.new<label>(5, na)

var array<int> weeklyAnchorStartsArray = array.new<int>(MAX_WEEKLY_HISTORY, na)
var array<float> weeklyAnchorSumSrc = array.new<float>(MAX_WEEKLY_HISTORY, 0.0)
var array<float> weeklyAnchorSumVol = array.new<float>(MAX_WEEKLY_HISTORY, 0.0)
var array<float> weeklyAnchorVWAPs = array.new<float>(MAX_WEEKLY_HISTORY, na)
var array<label> weeklyAnchorLabels = array.new<label>(MAX_WEEKLY_HISTORY, na)
var bool currentSessionIsWeeklyAnchor = false

var array<int> monthlyAnchorStartsArray = array.new<int>(MAX_MONTHLY_HISTORY, na)
var array<float> monthlyAnchorSumSrc = array.new<float>(MAX_MONTHLY_HISTORY, 0.0)
var array<float> monthlyAnchorSumVol = array.new<float>(MAX_MONTHLY_HISTORY, 0.0)
var array<float> monthlyAnchorVWAPs = array.new<float>(MAX_MONTHLY_HISTORY, na)
var array<label> monthlyAnchorLabels = array.new<label>(MAX_MONTHLY_HISTORY, na)
var bool currentSessionIsMonthlyAnchor = false

var array<int> yearlyAnchorStartsArray = array.new<int>(MAX_YEARLY_HISTORY, na)
var array<float> yearlyAnchorSumSrc = array.new<float>(MAX_YEARLY_HISTORY, 0.0)
var array<float> yearlyAnchorSumVol = array.new<float>(MAX_YEARLY_HISTORY, 0.0)
var array<float> yearlyAnchorVWAPs = array.new<float>(MAX_YEARLY_HISTORY, na)
var array<label> yearlyAnchorLabels = array.new<label>(MAX_YEARLY_HISTORY, na)
var bool currentSessionIsYearlyAnchor = false

if barstate.isfirst
    weeklyAnchorStartsArray := getWeeklyAnchorStartsArray(primarySessionName, MAX_WEEKLY_HISTORY)
    if showMonthlyAnchorVWAP
        monthlyAnchorStartsArray := getMonthlyAnchorStartsArray(primarySessionName, MAX_MONTHLY_HISTORY)
    if showYearlyAnchorVWAP
        yearlyAnchorStartsArray := getYearlyAnchorStartsArray(primarySessionName, MAX_YEARLY_HISTORY)

var int activeSessionIndex = na
var string activeSessionName = na

var float sessionOpen = na
var float openRangeHigh = na
var float openRangeLow = na
var float initialBalanceHigh = na
var float initialBalanceLow = na
var int sessionStartBar = na
var int sessionStartTime = na

var int openPriceBar = na
var int orhBar = na
var int orlBar = na
var int ibhBar = na
var int iblBar = na

int openRangeMinutes = periodToMinutes(openRangeLength)
int ibMinutes = periodToMinutes(initialBalanceLength)

// UNIFIED SESSION DETECTION (Calendar-based)

for i = 0 to 4
    if array.get(sessionEnabled, i)
        string sessionName = array.get(sessionNames, i)

        array<int> sessionStartsArray = switch i
            0 => londonStarts
            1 => nyStarts
            2 => globexStarts
            3 => sydneyStarts
            => tokyoStarts
        int mostRecentSessionStart = array.get(sessionStartsArray, MAX_VWAP_HISTORY - 1)

        bool thisSessionChange = time >= mostRecentSessionStart and time[1] < mostRecentSessionStart

        if thisSessionChange
            array.set(sessionStartBars, i, bar_index)
            array.set(sessionStartTimes, i, mostRecentSessionStart)

            activeSessionIndex := i
            activeSessionName := sessionName

            sessionOpen := open
            openRangeHigh := high
            openRangeLow := low
            initialBalanceHigh := high
            initialBalanceLow := low
            sessionStartBar := bar_index
            sessionStartTime := mostRecentSessionStart
            openPriceBar := bar_index
            orhBar := bar_index
            orlBar := bar_index
            ibhBar := bar_index
            iblBar := bar_index

if not na(activeSessionIndex) and not na(sessionOpen) and not na(sessionStartTime)
    array<int> activeSessionEnds = switch activeSessionIndex
        0 => londonEnds
        1 => nyEnds
        2 => globexEnds
        3 => sydneyEnds
        => tokyoEnds
    int currentSessionEnd = array.get(activeSessionEnds, MAX_VWAP_HISTORY - 1)

    bool stillInSession = time >= sessionStartTime and time < currentSessionEnd

    if stillInSession
        int elapsedMinutes = math.round((time - sessionStartTime) / 60000)
        if elapsedMinutes <= openRangeMinutes
            if high > openRangeHigh
                openRangeHigh := high
                orhBar := bar_index
            if low < openRangeLow
                openRangeLow := low
                orlBar := bar_index

        if elapsedMinutes <= ibMinutes
            if high > initialBalanceHigh
                initialBalanceHigh := high
                ibhBar := bar_index
            if low < initialBalanceLow
                initialBalanceLow := low
                iblBar := bar_index

// MULTI-SESSION VWAP CALCULATIONS

var array<float> londonVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> nyVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> globexVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> sydneyVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)
var array<float> tokyoVWAPs = array.new<float>(MAX_VWAP_HISTORY, na)

var array<label> londonLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> nyLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> globexLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> sydneyLabels = array.new<label>(MAX_VWAP_HISTORY, na)
var array<label> tokyoLabels = array.new<label>(MAX_VWAP_HISTORY, na)

for i = 0 to 4
    if array.get(sessionEnabled, i)
        // Get configuration for this session type
        int historyCount = i == 0 ? londonVWAPCountActive : i == 1 ? nyVWAPCountActive : i == 2 ? globexVWAPCountActive : i == 3 ? sydneyVWAPCountActive : tokyoVWAPCountActive
        array<int> sessionStartsArray = i == 0 ? londonStarts : i == 1 ? nyStarts : i == 2 ? globexStarts : i == 3 ? sydneyStarts : tokyoStarts
        array<float> sumSrcArray = i == 0 ? londonSumSrc : i == 1 ? nySumSrc : i == 2 ? globexSumSrc : i == 3 ? sydneySumSrc : tokyoSumSrc
        array<float> sumVolArray = i == 0 ? londonSumVol : i == 1 ? nySumVol : i == 2 ? globexSumVol : i == 3 ? sydneySumVol : tokyoSumVol
        array<float> vwapArray = i == 0 ? londonVWAPs : i == 1 ? nyVWAPs : i == 2 ? globexVWAPs : i == 3 ? sydneyVWAPs : tokyoVWAPs
        array<label> labelArray = i == 0 ? londonLabels : i == 1 ? nyLabels : i == 2 ? globexLabels : i == 3 ? sydneyLabels : tokyoLabels
        color sessionColor = i == 0 ? colorLondon : i == 1 ? colorNewYork : i == 2 ? colorGlobex : i == 3 ? colorSydney : colorTokyo
        string sessionName = array.get(sessionNames, i)
        bool meetsThisSessionVWAPTimeframe = i == 0 ? meetsLondonVWAPTimeframe : i == 1 ? meetsNYVWAPTimeframe : i == 2 ? meetsGlobexVWAPTimeframe : i == 3 ? meetsSydneyVWAPTimeframe : meetsTokyoVWAPTimeframe

        // Loop through all tracked sessions (MAX_VWAP_HISTORY)
        for arrayIdx = 0 to MAX_VWAP_HISTORY - 1
            int sessionStart = array.get(sessionStartsArray, arrayIdx)

            // Get the next session start (to know when to stop calculating this VWAP)
            int nextSessionStart = arrayIdx < MAX_VWAP_HISTORY - 1 ? array.get(sessionStartsArray, arrayIdx + 1) : int(na)

            // Check if we're at the start of this session
            bool isSessionStart = time >= sessionStart and time[1] < sessionStart

            // Check if this VWAP is within the configured history count
            // Array layout: [0=oldest ... 9=newest] with MAX_VWAP_HISTORY=10
            // If historyCount=1: only arrayIdx=9 is visible (sessionIndexInHistory >= 0)
            // If historyCount=2: arrayIdx=8,9 are visible
            // If historyCount=5: arrayIdx=5,6,7,8,9 are visible
            int sessionIndexInHistory = arrayIdx - (MAX_VWAP_HISTORY - historyCount)
            bool isInConfiguredRange = sessionIndexInHistory >= 0

            // VWAPs should calculate as long as they're in the configured range AND after their session started
            // They continue calculating even after the next session starts (unlike the old logic)
            bool shouldCalculate = time >= sessionStart and isInConfiguredRange

            // Reset accumulators on session start (always, regardless of RTH)
            if isSessionStart and isInConfiguredRange
                array.set(sumSrcArray, arrayIdx, 0.0)
                array.set(sumVolArray, arrayIdx, 0.0)

            if shouldCalculate
                // Get current accumulators for this session
                float currentSumSrc = array.get(sumSrcArray, arrayIdx)
                float currentSumVol = array.get(sumVolArray, arrayIdx)

                // Accumulate: only filter NY session to RTH if enabled, all other sessions use full data
                bool isNYSessionVWAP = sessionName == "New York"
                bool shouldAccumulate = not isNYSessionVWAP or not shouldFilterRTH or isNYSession
                if shouldAccumulate
                    currentSumSrc += (ohlc4 * volume)
                    currentSumVol += volume
                    array.set(sumSrcArray, arrayIdx, currentSumSrc)
                    array.set(sumVolArray, arrayIdx, currentSumVol)

                // Calculate VWAP from current accumulators (after accumulation)
                float vwap = currentSumVol > 0 ? currentSumSrc / currentSumVol : na
                array.set(vwapArray, arrayIdx, vwap)

                // Create session label at session start ONLY if within configured history count and timeframe
                if isSessionStart and sessionBaseCondition and meetsThisSessionVWAPTimeframe and showSessionLabels and showSessionVWAP and isInConfiguredRange
                    deleteLabel(labelArray, arrayIdx)
                    int positionInHistory = (MAX_VWAP_HISTORY - 1) - arrayIdx
                    color labelColor = getVWAPColor(sessionColor, positionInHistory, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, historyCount - 1)
                    bool isPrimarySession = sessionName == primarySessionName
                    // For Globex, show the trading day (session end day) not the start day
                    int labelTimestamp = sessionName == "Globex" ? sessionStart + 86400000 : sessionStart
                    string sessionLabelText = compactLabels ? (isPrimarySession ? "D" + str.tostring(positionInHistory + 1) : getSessionAbbr(sessionName) + str.tostring(positionInHistory + 1)) : sessionName + " " + str.format_time(labelTimestamp, "d MMM", getSessionTimezone(sessionName))
                    label newLabel = label.new(bar_index, high, sessionLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=labelColor, textcolor=color.white, size=getLabelSize(globalLabelSize), style=label.style_label_down)
                    array.set(labelArray, arrayIdx, newLabel)
                    if arrayIdx == MAX_VWAP_HISTORY - 1
                        array.set(sessionLabels, i, newLabel)

            // Clean up labels that are outside the configured history count
            if not isInConfiguredRange
                deleteLabel(labelArray, arrayIdx)
                array.set(labelArray, arrayIdx, na)

// Plot VWAPs - up to 5 historical sessions per type
bool skipLondonMostRecent = showWeeklyAnchorVWAP and primarySessionName == "London" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsLondonVWAPTimeframe and showSessionVWAP and enableLondonActive and londonVWAPCountActive >= 1 and not skipLondonMostRecent ? array.get(londonVWAPs, MAX_VWAP_HISTORY - 1) : na, "London VWAP 1", color=getVWAPColor(colorLondonActive, 0, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, londonVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipNYMostRecent = showWeeklyAnchorVWAP and primarySessionName == "New York" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYorkActive and nyVWAPCountActive >= 1 and not skipNYMostRecent ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 1) : na, "NY VWAP 1", color=getVWAPColor(colorNewYorkActive, 0, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, nyVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYorkActive and nyVWAPCountActive >= 2 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 2) : na, "NY VWAP 2", color=getVWAPColor(colorNewYorkActive, 1, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, nyVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYorkActive and nyVWAPCountActive >= 3 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 3) : na, "NY VWAP 3", color=getVWAPColor(colorNewYorkActive, 2, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, nyVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYorkActive and nyVWAPCountActive >= 4 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 4) : na, "NY VWAP 4", color=getVWAPColor(colorNewYorkActive, 3, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, nyVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsNYVWAPTimeframe and showSessionVWAP and enableNewYorkActive and nyVWAPCountActive >= 5 ? array.get(nyVWAPs, MAX_VWAP_HISTORY - 5) : na, "NY VWAP 5", color=getVWAPColor(colorNewYorkActive, 4, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, nyVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipGlobexMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Globex" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobexActive and globexVWAPCountActive >= 1 and not skipGlobexMostRecent ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 1) : na, "Globex VWAP 1", color=getVWAPColor(colorGlobexActive, 0, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, globexVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobexActive and globexVWAPCountActive >= 2 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 2) : na, "Globex VWAP 2", color=getVWAPColor(colorGlobexActive, 1, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, globexVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobexActive and globexVWAPCountActive >= 3 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 3) : na, "Globex VWAP 3", color=getVWAPColor(colorGlobexActive, 2, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, globexVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobexActive and globexVWAPCountActive >= 4 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 4) : na, "Globex VWAP 4", color=getVWAPColor(colorGlobexActive, 3, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, globexVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(sessionBaseCondition and meetsGlobexVWAPTimeframe and showSessionVWAP and enableGlobexActive and globexVWAPCountActive >= 5 ? array.get(globexVWAPs, MAX_VWAP_HISTORY - 5) : na, "Globex VWAP 5", color=getVWAPColor(colorGlobexActive, 4, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, globexVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipSydneyMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Sydney" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsSydneyVWAPTimeframe and showSessionVWAP and enableSydneyActive and sydneyVWAPCountActive >= 1 and not skipSydneyMostRecent ? array.get(sydneyVWAPs, MAX_VWAP_HISTORY - 1) : na, "Sydney VWAP 1", color=getVWAPColor(colorSydneyActive, 0, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, sydneyVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

bool skipTokyoMostRecent = showWeeklyAnchorVWAP and primarySessionName == "Tokyo" and currentSessionIsWeeklyAnchor
plot(sessionBaseCondition and meetsTokyoVWAPTimeframe and showSessionVWAP and enableTokyoActive and tokyoVWAPCountActive >= 1 and not skipTokyoMostRecent ? array.get(tokyoVWAPs, MAX_VWAP_HISTORY - 1) : na, "Tokyo VWAP 1", color=getVWAPColor(colorTokyoActive, 0, vwapColorDifferentiationActive, vwapMaxTransparencyActive, vwapHueShiftActive, vwapDesaturationActive, vwapBrightnessActive, tokyoVWAPCountActive - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEEKLY ANCHOR VWAP CALCULATION (Multi-week support)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Get the session arrays for the anchor session type (for skip logic)
array<int> anchorSessionStarts = switch primarySessionName
    "London" => londonStarts
    "New York" => nyStarts
    "Globex" => globexStarts
    "Sydney" => sydneyStarts
    => tokyoStarts

if showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe
    string anchorTZ = getSessionTimezone(primarySessionName)

    // Process each week in the array
    for weekIdx = 0 to MAX_WEEKLY_HISTORY - 1
        int weekStart = array.get(weeklyAnchorStartsArray, weekIdx)

        if not na(weekStart)
            // Detect when we cross into this week's start
            bool atWeekStart = time >= weekStart and time[1] < weekStart

            if atWeekStart
                // Reset accumulators for this week
                array.set(weeklyAnchorSumSrc, weekIdx, 0.0)
                array.set(weeklyAnchorSumVol, weekIdx, 0.0)

                // Check if this is the most recent week and matches the most recent daily session
                if weekIdx == MAX_WEEKLY_HISTORY - 1
                    currentSessionIsWeeklyAnchor := (weekStart == array.get(anchorSessionStarts, MAX_VWAP_HISTORY - 1))

                // Create label at week start (only if within count)
                bool shouldShowLabel = weekIdx >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
                if showSessionLabels and shouldShowLabel
                    label oldLabel = array.get(weeklyAnchorLabels, weekIdx)
                    if not na(oldLabel)
                        label.delete(oldLabel)
                    int positionInWeeklyHistory = (MAX_WEEKLY_HISTORY - 1) - weekIdx
                    color weeklyLabelColor = getVWAPColor(colorWeeklyAnchor, positionInWeeklyHistory, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation, longTermAnchorBrightness, weeklyAnchorCount - 1)
                    string weeklyLabelText = compactLabels ? "W" + str.tostring(positionInWeeklyHistory + 1) : "Week " + str.tostring(weekofyear(weekStart, anchorTZ)) + " (" + primarySessionName + ")"
                    label newLabel = label.new(bar_index, high, weeklyLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=weeklyLabelColor, textcolor=color.white, size=getLabelSize(globalLabelSize), style=label.style_label_down)
                    array.set(weeklyAnchorLabels, weekIdx, newLabel)

            // Accumulate if we're at or after this week's start (apply RTH filter for stocks/indices)
            bool shouldAccumulateWeekly = not shouldFilterRTH or isNYSession
            if time >= weekStart and shouldAccumulateWeekly
                float currentSumSrc = array.get(weeklyAnchorSumSrc, weekIdx)
                float currentSumVol = array.get(weeklyAnchorSumVol, weekIdx)
                array.set(weeklyAnchorSumSrc, weekIdx, currentSumSrc + (ohlc4 * volume))
                array.set(weeklyAnchorSumVol, weekIdx, currentSumVol + volume)

                float newSumSrc = array.get(weeklyAnchorSumSrc, weekIdx)
                float newSumVol = array.get(weeklyAnchorSumVol, weekIdx)
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(weeklyAnchorVWAPs, weekIdx, vwap)

// Plot weekly anchor VWAPs (only plot the number specified by count)
// Index 5 = most recent (when MAX=6), Index 4 = 2nd most recent, etc.
bool shouldPlot0 = 0 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot1 = 1 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot2 = 2 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot3 = 3 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot4 = 4 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)
bool shouldPlot5 = 5 >= (MAX_WEEKLY_HISTORY - weeklyAnchorCount)

plot(shouldPlot0 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 0) : na, "Weekly Anchor 1", color=getVWAPColor(colorWeeklyAnchor, 5, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation, longTermAnchorBrightness, weeklyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot1 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 1) : na, "Weekly Anchor 2", color=getVWAPColor(colorWeeklyAnchor, 4, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation, longTermAnchorBrightness, weeklyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot2 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 2) : na, "Weekly Anchor 3", color=getVWAPColor(colorWeeklyAnchor, 3, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation, longTermAnchorBrightness, weeklyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot3 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 3) : na, "Weekly Anchor 4", color=getVWAPColor(colorWeeklyAnchor, 2, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation, longTermAnchorBrightness, weeklyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot4 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 4) : na, "Weekly Anchor 5", color=getVWAPColor(colorWeeklyAnchor, 1, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation, longTermAnchorBrightness, weeklyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlot5 and showWeeklyAnchorVWAP and showSessionMarkers and meetsWeeklyAnchorMaxTimeframe ? array.get(weeklyAnchorVWAPs, 5) : na, "Weekly Anchor 6", color=getVWAPColor(colorWeeklyAnchor, 0, longTermAnchorColorDifferentiation, longTermAnchorMaxTransparency, longTermAnchorHueShift, longTermAnchorDesaturation, longTermAnchorBrightness, weeklyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MONTHLY ANCHOR VWAP CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if showMonthlyAnchorVWAP and showSessionMarkers and meetsMonthlyAnchorTimeframe
    string anchorTZ = getSessionTimezone(primarySessionName)
    for monthIdx = 0 to MAX_MONTHLY_HISTORY - 1
        int monthStart = array.get(monthlyAnchorStartsArray, monthIdx)
        if not na(monthStart)
            bool atMonthStart = time >= monthStart and time[1] < monthStart
            if atMonthStart
                array.set(monthlyAnchorSumSrc, monthIdx, 0.0)
                array.set(monthlyAnchorSumVol, monthIdx, 0.0)
                if monthIdx == MAX_MONTHLY_HISTORY - 1
                    currentSessionIsMonthlyAnchor := (monthStart == array.get(anchorSessionStarts, MAX_VWAP_HISTORY - 1))
                bool shouldShowLabel = monthIdx >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount)
                if showSessionLabels and shouldShowLabel
                    label oldLabel = array.get(monthlyAnchorLabels, monthIdx)
                    if not na(oldLabel)
                        label.delete(oldLabel)
                    int positionInMonthlyHistory = (MAX_MONTHLY_HISTORY - 1) - monthIdx
                    color monthlyLabelColor = getVWAPColor(colorMonthlyAnchor, positionInMonthlyHistory, monthlyAnchorColorDifferentiation, monthlyAnchorMaxTransparency, monthlyAnchorHueShift, monthlyAnchorDesaturation, monthlyAnchorBrightness, monthlyAnchorCount - 1)
                    string monthlyLabelText = compactLabels ? "M" + str.tostring(positionInMonthlyHistory + 1) : str.format("{0,date,MMM yyyy}", monthStart) + " (" + primarySessionName + ")"
                    label newLabel = label.new(bar_index, high, monthlyLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=monthlyLabelColor, textcolor=color.white, size=getLabelSize(globalLabelSize), style=label.style_label_down)
                    array.set(monthlyAnchorLabels, monthIdx, newLabel)
            if time >= monthStart
                bool shouldAccumulateMonthly = not shouldFilterRTH or isNYSession
                if shouldAccumulateMonthly
                    float currentSumSrc = array.get(monthlyAnchorSumSrc, monthIdx)
                    float currentSumVol = array.get(monthlyAnchorSumVol, monthIdx)
                    array.set(monthlyAnchorSumSrc, monthIdx, currentSumSrc + (ohlc4 * volume))
                    array.set(monthlyAnchorSumVol, monthIdx, currentSumVol + volume)
                float newSumSrc = array.get(monthlyAnchorSumSrc, monthIdx)
                float newSumVol = array.get(monthlyAnchorSumVol, monthIdx)
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(monthlyAnchorVWAPs, monthIdx, vwap)

bool shouldPlotM0 = 0 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount)
bool shouldPlotM1 = 1 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount)
bool shouldPlotM2 = 2 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount)
bool shouldPlotM3 = 3 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount)
bool shouldPlotM4 = 4 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount)
bool shouldPlotM5 = 5 >= (MAX_MONTHLY_HISTORY - monthlyAnchorCount)

plot(shouldPlotM0 and showMonthlyAnchorVWAP and showSessionMarkers and meetsMonthlyAnchorTimeframe ? array.get(monthlyAnchorVWAPs, 0) : na, "Monthly Anchor 1", color=getVWAPColor(colorMonthlyAnchor, 5, monthlyAnchorColorDifferentiation, monthlyAnchorMaxTransparency, monthlyAnchorHueShift, monthlyAnchorDesaturation, monthlyAnchorBrightness, monthlyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlotM1 and showMonthlyAnchorVWAP and showSessionMarkers and meetsMonthlyAnchorTimeframe ? array.get(monthlyAnchorVWAPs, 1) : na, "Monthly Anchor 2", color=getVWAPColor(colorMonthlyAnchor, 4, monthlyAnchorColorDifferentiation, monthlyAnchorMaxTransparency, monthlyAnchorHueShift, monthlyAnchorDesaturation, monthlyAnchorBrightness, monthlyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlotM2 and showMonthlyAnchorVWAP and showSessionMarkers and meetsMonthlyAnchorTimeframe ? array.get(monthlyAnchorVWAPs, 2) : na, "Monthly Anchor 3", color=getVWAPColor(colorMonthlyAnchor, 3, monthlyAnchorColorDifferentiation, monthlyAnchorMaxTransparency, monthlyAnchorHueShift, monthlyAnchorDesaturation, monthlyAnchorBrightness, monthlyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlotM3 and showMonthlyAnchorVWAP and showSessionMarkers and meetsMonthlyAnchorTimeframe ? array.get(monthlyAnchorVWAPs, 3) : na, "Monthly Anchor 4", color=getVWAPColor(colorMonthlyAnchor, 2, monthlyAnchorColorDifferentiation, monthlyAnchorMaxTransparency, monthlyAnchorHueShift, monthlyAnchorDesaturation, monthlyAnchorBrightness, monthlyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlotM4 and showMonthlyAnchorVWAP and showSessionMarkers and meetsMonthlyAnchorTimeframe ? array.get(monthlyAnchorVWAPs, 4) : na, "Monthly Anchor 5", color=getVWAPColor(colorMonthlyAnchor, 1, monthlyAnchorColorDifferentiation, monthlyAnchorMaxTransparency, monthlyAnchorHueShift, monthlyAnchorDesaturation, monthlyAnchorBrightness, monthlyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlotM5 and showMonthlyAnchorVWAP and showSessionMarkers and meetsMonthlyAnchorTimeframe ? array.get(monthlyAnchorVWAPs, 5) : na, "Monthly Anchor 6", color=getVWAPColor(colorMonthlyAnchor, 0, monthlyAnchorColorDifferentiation, monthlyAnchorMaxTransparency, monthlyAnchorHueShift, monthlyAnchorDesaturation, monthlyAnchorBrightness, monthlyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// YEARLY ANCHOR VWAP CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if showYearlyAnchorVWAP and showSessionMarkers and meetsYearlyAnchorTimeframe
    string anchorTZ = getSessionTimezone(primarySessionName)
    for yearIdx = 0 to MAX_YEARLY_HISTORY - 1
        int yearStart = array.get(yearlyAnchorStartsArray, yearIdx)
        if not na(yearStart)
            bool atYearStart = time >= yearStart and time[1] < yearStart
            if atYearStart
                array.set(yearlyAnchorSumSrc, yearIdx, 0.0)
                array.set(yearlyAnchorSumVol, yearIdx, 0.0)
                if yearIdx == MAX_YEARLY_HISTORY - 1
                    currentSessionIsYearlyAnchor := (yearStart == array.get(anchorSessionStarts, MAX_VWAP_HISTORY - 1))
                bool shouldShowLabel = yearIdx >= (MAX_YEARLY_HISTORY - yearlyAnchorCount)
                if showSessionLabels and shouldShowLabel
                    label oldLabel = array.get(yearlyAnchorLabels, yearIdx)
                    if not na(oldLabel)
                        label.delete(oldLabel)
                    int positionInYearlyHistory = (MAX_YEARLY_HISTORY - 1) - yearIdx
                    color yearlyLabelColor = getVWAPColor(colorYearlyAnchor, positionInYearlyHistory, yearlyAnchorColorDifferentiation, yearlyAnchorMaxTransparency, yearlyAnchorHueShift, yearlyAnchorDesaturation, yearlyAnchorBrightness, yearlyAnchorCount - 1)
                    string yearlyLabelText = compactLabels ? "Y" + str.tostring(positionInYearlyHistory + 1) : str.format("{0,date,yyyy}", yearStart) + " (" + primarySessionName + ")"
                    label newLabel = label.new(bar_index, high, yearlyLabelText, xloc=xloc.bar_index, yloc=yloc.abovebar, color=yearlyLabelColor, textcolor=color.white, size=getLabelSize(globalLabelSize), style=label.style_label_down)
                    array.set(yearlyAnchorLabels, yearIdx, newLabel)
            if time >= yearStart
                bool shouldAccumulateYearly = not shouldFilterRTH or isNYSession
                if shouldAccumulateYearly
                    float currentSumSrc = array.get(yearlyAnchorSumSrc, yearIdx)
                    float currentSumVol = array.get(yearlyAnchorSumVol, yearIdx)
                    array.set(yearlyAnchorSumSrc, yearIdx, currentSumSrc + (ohlc4 * volume))
                    array.set(yearlyAnchorSumVol, yearIdx, currentSumVol + volume)
                float newSumSrc = array.get(yearlyAnchorSumSrc, yearIdx)
                float newSumVol = array.get(yearlyAnchorSumVol, yearIdx)
                float vwap = newSumVol > 0 ? newSumSrc / newSumVol : na
                array.set(yearlyAnchorVWAPs, yearIdx, vwap)

bool shouldPlotY0 = 0 >= (MAX_YEARLY_HISTORY - yearlyAnchorCount)
bool shouldPlotY1 = 1 >= (MAX_YEARLY_HISTORY - yearlyAnchorCount)

plot(shouldPlotY0 and showYearlyAnchorVWAP and showSessionMarkers and meetsYearlyAnchorTimeframe ? array.get(yearlyAnchorVWAPs, 0) : na, "Yearly Anchor 1", color=getVWAPColor(colorYearlyAnchor, 1, yearlyAnchorColorDifferentiation, yearlyAnchorMaxTransparency, yearlyAnchorHueShift, yearlyAnchorDesaturation, yearlyAnchorBrightness, yearlyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)
plot(shouldPlotY1 and showYearlyAnchorVWAP and showSessionMarkers and meetsYearlyAnchorTimeframe ? array.get(yearlyAnchorVWAPs, 1) : na, "Yearly Anchor 2", color=getVWAPColor(colorYearlyAnchor, 0, yearlyAnchorColorDifferentiation, yearlyAnchorMaxTransparency, yearlyAnchorHueShift, yearlyAnchorDesaturation, yearlyAnchorBrightness, yearlyAnchorCount - 1), linewidth=sessionVWAPLineWidth, style=plot.style_line, linestyle=sessionVWAPLineStyle)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION LEVELS RENDERING (for active session only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box boxOpenRange = na
var box boxInitialBalanceUpper = na
var box boxInitialBalanceLower = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEY LEVELS RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Cache bar_index to prevent redundant updates on same bar (improves scrolling performance)
var int lastRenderBarIndex = na

if barstate.islast and (na(lastRenderBarIndex) or bar_index != lastRenderBarIndex)
    lastRenderBarIndex := bar_index

    // Calculate line start position with hard limit to prevent lines getting too long
    int startBar = math.max(0, bar_index - globalLineLengthBars)
    int maxLineDistance = 200  // Safe hard limit: must match max value of globalLineLengthBars input (prevents crashes on high-frequency charts)

    // Determine session line start based on user preference, but reset to configured length if beyond hard limit
    int sessionOpenBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
    int openPriceStartBar = sessionLineStartMode == "Level Established" and not na(openPriceBar) ? (bar_index - openPriceBar > maxLineDistance ? startBar : openPriceBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orhStartBar = sessionLineStartMode == "Level Established" and not na(orhBar) ? (bar_index - orhBar > maxLineDistance ? startBar : orhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int orlStartBar = sessionLineStartMode == "Level Established" and not na(orlBar) ? (bar_index - orlBar > maxLineDistance ? startBar : orlBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int ibhStartBar = sessionLineStartMode == "Level Established" and not na(ibhBar) ? (bar_index - ibhBar > maxLineDistance ? startBar : ibhBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)
    int iblStartBar = sessionLineStartMode == "Level Established" and not na(iblBar) ? (bar_index - iblBar > maxLineDistance ? startBar : iblBar) : (sessionLineStartMode == "Session Open" ? sessionOpenBar : startBar)

    string labelSizeActual = getLabelSize(globalLabelSize)

    // Round prices for map key consistency
    float athRounded = roundToTick(ath)
    float pyhRounded = roundToTick(pyh)
    float pylRounded = roundToTick(pyl)
    float pmhRounded = roundToTick(pmh)
    float pmlRounded = roundToTick(pml)
    float pwhRounded = roundToTick(pwh)
    float pwlRounded = roundToTick(pwl)
    float pdhRounded = roundToTick(pdh)
    float pdlRounded = roundToTick(pdl)
    float cyhRounded = roundToTick(cyh)
    float cylRounded = roundToTick(cyl)
    float cmhRounded = roundToTick(cmh)
    float cmlRounded = roundToTick(cml)
    float cwhRounded = roundToTick(cwh)
    float cwlRounded = roundToTick(cwl)
    float cdhRounded = roundToTick(cdh)
    float cdlRounded = roundToTick(cdl)

    // Pivot points rounded
    float pivotPRounded = roundToTick(pivotP)
    float pivotR1Rounded = roundToTick(pivotR1)
    float pivotR2Rounded = roundToTick(pivotR2)
    float pivotR3Rounded = roundToTick(pivotR3)
    float pivotS1Rounded = roundToTick(pivotS1)
    float pivotS2Rounded = roundToTick(pivotS2)
    float pivotS3Rounded = roundToTick(pivotS3)

    // Session levels rounded
    float ibhRounded = roundToTick(initialBalanceHigh)
    float iblRounded = roundToTick(initialBalanceLow)
    float orhRounded = roundToTick(openRangeHigh)
    float orlRounded = roundToTick(openRangeLow)
    float openRounded = roundToTick(sessionOpen)

    // Build price->label map (merges duplicates with "/")
    // Priority: Session Levels > Pivot Points > Key Levels
    var map<float, string> priceLabels = map.new<float, string>()
    map.clear(priceLabels)

    // Session levels first (highest priority)
    bool shouldAddSessionToMap = showSessionMarkersCondition and not na(sessionOpen)
    if shouldAddSessionToMap
        if showOpenPrice
            addToMap(priceLabels, sessionOpen, "Open")
        if showOpenRange and not na(openRangeHigh)
            addToMap(priceLabels, openRangeHigh, "ORH")
        if showOpenRange and not na(openRangeLow)
            addToMap(priceLabels, openRangeLow, "ORL")
        if showInitialBalance and not na(initialBalanceHigh)
            addToMap(priceLabels, initialBalanceHigh, "IBH")
        if showInitialBalance and not na(initialBalanceLow)
            addToMap(priceLabels, initialBalanceLow, "IBL")

    // Pivot points second (after session, before key levels)
    if showPivotsCondition
        if showPivotP
            addToMap(priceLabels, pivotP, "P")
        if showPivotR1
            addToMap(priceLabels, pivotR1, "R1")
        if showPivotR2
            addToMap(priceLabels, pivotR2, "R2")
        if showPivotR3
            addToMap(priceLabels, pivotR3, "R3")
        if showPivotS1
            addToMap(priceLabels, pivotS1, "S1")
        if showPivotS2
            addToMap(priceLabels, pivotS2, "S2")
        if showPivotS3
            addToMap(priceLabels, pivotS3, "S3")

    // Key levels (lower priority)
    if showKeyLevelsCondition
        if showATH
            addToMap(priceLabels, ath, "ATH")
        if showPYH
            addToMap(priceLabels, pyh, "PYH")
        if showPYL
            addToMap(priceLabels, pyl, "PYL")
        if showPMH
            addToMap(priceLabels, pmh, "PMH")
        if showPML
            addToMap(priceLabels, pml, "PML")
        if showPWH
            addToMap(priceLabels, pwh, "PWH")
        if showPWL
            addToMap(priceLabels, pwl, "PWL")
        if showPDH
            addToMap(priceLabels, pdh, "PDH")
        if showPDL
            addToMap(priceLabels, pdl, "PDL")
        if showCYH
            addToMap(priceLabels, cyh, "CYH")
        if showCYL
            addToMap(priceLabels, cyl, "CYL")
        if showCMH
            addToMap(priceLabels, cmh, "CMH")
        if showCML
            addToMap(priceLabels, cml, "CML")
        if showCWH
            addToMap(priceLabels, cwh, "CWH")
        if showCWL
            addToMap(priceLabels, cwl, "CWL")
        if showCDH
            addToMap(priceLabels, cdh, "CDH")
        if showCDL
            addToMap(priceLabels, cdl, "CDL")

    var array<float> renderedPrices = array.new<float>()
    array.clear(renderedPrices)

    // Initialize level arrays on first render
    if array.size(sessionLevels) == 0
        array.push(sessionLevels, LevelRenderer.new("Open", showOpenPrice, sessionOpen, openRounded, openPriceStartBar, colorOpenPrice, sessionLevelsLineWidth, sessionLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("ORH", showOpenRange, openRangeHigh, orhRounded, orhStartBar, colorORH, sessionLevelsLineWidth, sessionLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("ORL", showOpenRange, openRangeLow, orlRounded, orlStartBar, colorORL, sessionLevelsLineWidth, sessionLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("IBH", showInitialBalance, initialBalanceHigh, ibhRounded, ibhStartBar, colorIBH, sessionLevelsLineWidth, sessionLevelsLineStyle, na, na))
        array.push(sessionLevels, LevelRenderer.new("IBL", showInitialBalance, initialBalanceLow, iblRounded, iblStartBar, colorIBL, sessionLevelsLineWidth, sessionLevelsLineStyle, na, na))

        array.push(pivotLevels, LevelRenderer.new("P", showPivotP, pivotP, pivotPRounded, startBar, pivotColorP, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("R1", showPivotR1, pivotR1, pivotR1Rounded, startBar, pivotColorR1, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("R2", showPivotR2, pivotR2, pivotR2Rounded, startBar, pivotColorR2, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("R3", showPivotR3, pivotR3, pivotR3Rounded, startBar, pivotColorR3, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("S1", showPivotS1, pivotS1, pivotS1Rounded, startBar, pivotColorS1, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("S2", showPivotS2, pivotS2, pivotS2Rounded, startBar, pivotColorS2, pivotLineWidth, pivotLineStyle, na, na))
        array.push(pivotLevels, LevelRenderer.new("S3", showPivotS3, pivotS3, pivotS3Rounded, startBar, pivotColorS3, pivotLineWidth, pivotLineStyle, na, na))

        array.push(keyLevels, LevelRenderer.new("ATH", showATH, ath, athRounded, startBar, colorATH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PYH", showPYH, pyh, pyhRounded, startBar, colorPYH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PYL", showPYL, pyl, pylRounded, startBar, colorPYL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PMH", showPMH, pmh, pmhRounded, startBar, colorPMH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PML", showPML, pml, pmlRounded, startBar, colorPML, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PWH", showPWH, pwh, pwhRounded, startBar, colorPWH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PWL", showPWL, pwl, pwlRounded, startBar, colorPWL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PDH", showPDH, pdh, pdhRounded, startBar, colorPDH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("PDL", showPDL, pdl, pdlRounded, startBar, colorPDL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CYH", showCYH, cyh, cyhRounded, startBar, colorCYH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CYL", showCYL, cyl, cylRounded, startBar, colorCYL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CMH", showCMH, cmh, cmhRounded, startBar, colorCMH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CML", showCML, cml, cmlRounded, startBar, colorCML, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CWH", showCWH, cwh, cwhRounded, startBar, colorCWH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CWL", showCWL, cwl, cwlRounded, startBar, colorCWL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CDH", showCDH, cdh, cdhRounded, startBar, colorCDH, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
        array.push(keyLevels, LevelRenderer.new("CDL", showCDL, cdl, cdlRounded, startBar, colorCDL, keyLevelsLineWidth, keyLevelsLineStyle, na, na))
    else
        // Update level data each bar
        array.get(sessionLevels, 0).update(showOpenPrice, sessionOpen, openRounded, openPriceStartBar)
        array.get(sessionLevels, 1).update(showOpenRange, openRangeHigh, orhRounded, orhStartBar)
        array.get(sessionLevels, 2).update(showOpenRange, openRangeLow, orlRounded, orlStartBar)
        array.get(sessionLevels, 3).update(showInitialBalance, initialBalanceHigh, ibhRounded, ibhStartBar)
        array.get(sessionLevels, 4).update(showInitialBalance, initialBalanceLow, iblRounded, iblStartBar)

        array.get(pivotLevels, 0).update(showPivotP, pivotP, pivotPRounded, startBar)
        array.get(pivotLevels, 1).update(showPivotR1, pivotR1, pivotR1Rounded, startBar)
        array.get(pivotLevels, 2).update(showPivotR2, pivotR2, pivotR2Rounded, startBar)
        array.get(pivotLevels, 3).update(showPivotR3, pivotR3, pivotR3Rounded, startBar)
        array.get(pivotLevels, 4).update(showPivotS1, pivotS1, pivotS1Rounded, startBar)
        array.get(pivotLevels, 5).update(showPivotS2, pivotS2, pivotS2Rounded, startBar)
        array.get(pivotLevels, 6).update(showPivotS3, pivotS3, pivotS3Rounded, startBar)

        array.get(keyLevels, 0).update(showATH, ath, athRounded, startBar)
        array.get(keyLevels, 1).update(showPYH, pyh, pyhRounded, startBar)
        array.get(keyLevels, 2).update(showPYL, pyl, pylRounded, startBar)
        array.get(keyLevels, 3).update(showPMH, pmh, pmhRounded, startBar)
        array.get(keyLevels, 4).update(showPML, pml, pmlRounded, startBar)
        array.get(keyLevels, 5).update(showPWH, pwh, pwhRounded, startBar)
        array.get(keyLevels, 6).update(showPWL, pwl, pwlRounded, startBar)
        array.get(keyLevels, 7).update(showPDH, pdh, pdhRounded, startBar)
        array.get(keyLevels, 8).update(showPDL, pdl, pdlRounded, startBar)
        array.get(keyLevels, 9).update(showCYH, cyh, cyhRounded, startBar)
        array.get(keyLevels, 10).update(showCYL, cyl, cylRounded, startBar)
        array.get(keyLevels, 11).update(showCMH, cmh, cmhRounded, startBar)
        array.get(keyLevels, 12).update(showCML, cml, cmlRounded, startBar)
        array.get(keyLevels, 13).update(showCWH, cwh, cwhRounded, startBar)
        array.get(keyLevels, 14).update(showCWL, cwl, cwlRounded, startBar)
        array.get(keyLevels, 15).update(showCDH, cdh, cdhRounded, startBar)
        array.get(keyLevels, 16).update(showCDL, cdl, cdlRounded, startBar)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION LEVELS RENDERING (FIRST - highest priority for line style)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    string sessionLineStyleActual = getLineStyle(sessionLevelsLineStyle)
    // Only show session levels if enabled and we meet the session levels timeframe filter
    bool showSessionLevels = showSessionLevelsInput == "Always" or (showSessionLevelsInput == "Futures Only" and syminfo.type == "futures")
    bool shouldShowSessionLevels = showSessionLevels and sessionBaseCondition and meetsSessionLevelsMaxTimeframe and not na(activeSessionIndex) and not na(sessionOpen)

    // Render session levels using array-based approach
    for level in sessionLevels
        level.render(shouldShowSessionLevels, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)

    // Open Range Background Shading
    if shouldShowSessionLevels and showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        int boxORStartBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
        boxOpenRange := updateBox(boxOpenRange, boxORStartBar, openRangeHigh, bar_index, openRangeLow, colorOpenRangeShade)
    else if not na(boxOpenRange)
        box.delete(boxOpenRange), boxOpenRange := na



    // Initial Balance Background Shading
    if shouldShowSessionLevels and showInitialBalance and shadeInitialBalance and not na(initialBalanceHigh) and not na(initialBalanceLow)
        int boxIBStartBar = not na(sessionStartBar) ? (bar_index - sessionStartBar > maxLineDistance ? startBar : sessionStartBar) : startBar
        bool splitIBBox = showOpenRange and shadeOpenRange and not na(openRangeHigh) and not na(openRangeLow)
        if splitIBBox
            if initialBalanceHigh > openRangeHigh
                boxInitialBalanceUpper := updateBox(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh, bar_index, openRangeHigh, colorInitialBalanceShade)
            else if not na(boxInitialBalanceUpper)
                box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
            if initialBalanceLow < openRangeLow
                boxInitialBalanceLower := updateBox(boxInitialBalanceLower, boxIBStartBar, openRangeLow, bar_index, initialBalanceLow, colorInitialBalanceShade)
            else if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
        else
            boxInitialBalanceUpper := updateBox(boxInitialBalanceUpper, boxIBStartBar, initialBalanceHigh, bar_index, initialBalanceLow, colorInitialBalanceShade)
            if not na(boxInitialBalanceLower)
                box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na
    else
        if not na(boxInitialBalanceUpper)
            box.delete(boxInitialBalanceUpper), boxInitialBalanceUpper := na
        if not na(boxInitialBalanceLower)
            box.delete(boxInitialBalanceLower), boxInitialBalanceLower := na

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PIVOT POINTS RENDERING (SECOND - after session levels, before key levels)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Render pivot levels using array-based approach
    for level in pivotLevels
        level.render(showPivotsCondition, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // KEY LEVELS RENDERING (THIRD - after session levels and pivots)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Render key levels using array-based approach
    for level in keyLevels
        level.render(showKeyLevelsCondition, true, priceLabels, renderedPrices, globalShowPriceValues, labelSizeActual, atrThreshold, useATRFilter)
