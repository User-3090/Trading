// MIT License
//
// Copyright (c) 2025 User-3090
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//@version=6
indicator("VWAP Trader AIO", overlay=true, max_lines_count=500)

// ═══════════════════════════════════════════════════════════════════════════════
// CONSTANTS & CONFIGURATION
// ═══════════════════════════════════════════════════════════════════════════════

const int MAX_BARS            = 5000
const int SCAN_WINDOW         = 10    // Rolling window: keep last N days
const int MIN_DAYS_FOR_SCAN   = 2     // Minimum days needed before using scanned data
const int MIN_BARS_TOTAL      = 6     // Minimum bars to start scanning (works on 4-hour+ timeframes)
const int MIN_BARS_PER_DAY    = 1     // Minimum bars per day (filters holidays, allows multi-hour timeframes)
const int MAX_BARS_PER_DAY    = 3000  // Maximum bars per day (supports 30-second charts on 24h markets)
const int SECONDS_STOCK_DAY   = 23400 // 6.5 hours (stock market RTH)
const int SECONDS_FOREX_DAY   = 86400 // 24 hours (forex trading, 5 days/week)
const int SECONDS_FUTURES_DAY = 82800 // 23 hours (typical futures trading)
const int SECONDS_CRYPTO_DAY  = 86400 // 24 hours (crypto trading)

// RTH Time Constants (Eastern Time)
const int RTH_START_MINUTES   = 570   // 9:30 AM
const int RTH_END_MINUTES     = 960   // 4:00 PM
const int MS_PER_DAY          = 86400000

// Session Array Management (optimized from 1000)
const int MAX_SESSION_BUFFER  = 200

max_bars_back(close, MAX_BARS)
max_bars_back(time, 5000)
max_bars_back(high, 5000)
max_bars_back(low, 5000)

// SMA Colors - Daily
const color COL_SMA5   = #fbbe30  // Yellow - 5-day
const color COL_SMA20  = #f47b00  // Orange - 20-day
const color COL_SMA50  = #d62060  // Pink - 50-day
const color COL_SMA200 = #e43b38  // Red - 200-day

// SMA Colors - Weekly (default to match 20-day, 50-day, 200-day)
const color COL_SMA20W = #f47b00  // Orange - 20-week
const color COL_SMA31W = #d62060  // Pink - 31-week
const color COL_SMA42W = #e43b38  // Red - 42-week



// ═══════════════════════════════════════════════════════════════════════════════
// INPUTS - ORGANIZED BY FEATURE
// ═══════════════════════════════════════════════════════════════════════════════

// 5-Day SMA Shading
shadingMode = input.string("Flat", "Shading Mode", options=["None", "Flat", "Gradient"], group="5-Day SMA Shading", tooltip="None = disabled, Flat = uniform color, Gradient = fades from bar")
shadeBullishColor = input.color(color.new(#81ce6f, 90), "Bullish Color", group="5-Day SMA Shading", tooltip="Shading when price above rising 5-Day SMA")
shadeBearishColor = input.color(color.new(#e43b38, 90), "Bearish Color", group="5-Day SMA Shading", tooltip="Shading when price below falling 5-Day SMA")
shadeTransitionColor = input.color(color.new(#fbbe30, 90), "Transition Color", group="5-Day SMA Shading", tooltip="Shading during mixed conditions")
shadowLengthPercent = input.float(0.2, "Shadow Length (%)", minval=0.01, step=0.01, group="5-Day SMA Shading", tooltip="Shadow distance from bar (gradient mode only)")
gradientMaxAlpha = input.int(100, "Fade To Alpha", group="5-Day SMA Shading", tooltip="Transparency at shadow end (gradient mode only)")

// Global Line Label Configuration (applies to Pivots, Settlements, Key Levels)
globalLabelSize = input.string("Normal", "Line Label Size", options=["Tiny", "Small", "Normal", "Large", "Huge"], group="Global Line Label Settings", tooltip="Label size for all horizontal level lines (Pivots, Settlements, Key Levels)")
globalShowPriceValues = input.bool(true, "Show Price in Labels", group="Global Line Label Settings", tooltip="Display price values in line labels (e.g., 'PDH (4523.50)' vs 'PDH')")
globalLineLengthBars = input.int(100, "Level Line Length (Bars)", minval=10, maxval=500, group="Global Line Label Settings", tooltip="How many bars back level lines extend (Settlements, Key Levels). Pivots always span current day only.")

// SMA Start Lines
show5StartLineInput = input.bool(true, "Show 5-Day", inline="5", group="SMA Start Lines")
startLineStyle5Input = input.string("Dashed", "Style", options=["Solid", "Dashed", "Dotted"], inline="5", group="SMA Start Lines")
show50StartLineInput = input.bool(false, "Show 50-Day", inline="50", group="SMA Start Lines")
startLineStyle50Input = input.string("Dashed", "Style", options=["Solid", "Dashed", "Dotted"], inline="50", group="SMA Start Lines")
show200StartLineInput = input.bool(false, "Show 200-Day", inline="200", group="SMA Start Lines")
startLineStyle200Input = input.string("Dashed", "Style", options=["Solid", "Dashed", "Dotted"], inline="200", group="SMA Start Lines")

// Pivot Points (Traditional Daily Levels)
showPivots = input.bool(true, "Show Pivot Points", group="Pivot Points", tooltip="Display traditional pivot points: P, R1-R3, S1-S3")
pivotIntradayOnly = input.bool(true, "Intraday Only", group="Pivot Points", tooltip="Only display on intraday timeframes, hide on daily/weekly charts")
showPivotP = input.bool(false, "P", inline="P", group="Pivot Points")
pivotColorP = input.color(#000000, "", inline="P", group="Pivot Points")
showPivotR1 = input.bool(false, "R1", inline="R", group="Pivot Points")
pivotColorR1 = input.color(#449955, "", inline="R", group="Pivot Points")
showPivotR2 = input.bool(true, "R2", inline="R", group="Pivot Points")
pivotColorR2 = input.color(#449955, "", inline="R", group="Pivot Points")
showPivotR3 = input.bool(true, "R3", inline="R", group="Pivot Points")
pivotColorR3 = input.color(#81ce6f, "", inline="R", group="Pivot Points")
showPivotS1 = input.bool(false, "S1", inline="S", group="Pivot Points")
pivotColorS1 = input.color(#b51b00, "", inline="S", group="Pivot Points")
showPivotS2 = input.bool(true, "S2", inline="S", group="Pivot Points")
pivotColorS2 = input.color(#b51b00, "", inline="S", group="Pivot Points")
showPivotS3 = input.bool(true, "S3", inline="S", group="Pivot Points")
pivotColorS3 = input.color(#d37666, "", inline="S", group="Pivot Points")
pivotLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="Pivot Points")
pivotLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="Pivot Points")

// Settlement Prices (Futures Only)
showSettlements = input.bool(false, "Show Settlement Prices", group="Settlement Prices", tooltip="Display last X settlement prices - FUTURES ONLY")
settlementIntradayOnly = input.bool(true, "Intraday Only", group="Settlement Prices", tooltip="Only display on intraday timeframes, hide on daily/weekly charts")
settlementCount = input.int(10, "Number of Settlements", minval=1, maxval=50, group="Settlement Prices", tooltip="Display the LAST X most recent settlement prices (rolling window)")
settlementDistanceFilter = input.bool(false, "Filter by Distance (Display Only)", group="Settlement Prices", tooltip="Only DISPLAY settlements within X ticks of current price - does not affect crossing detection")
settlementMaxDistance = input.int(1000, "Max Distance (Ticks)", minval=1, group="Settlement Prices", tooltip="Maximum distance from current price to display settlement line")
settlementHideCrossed = input.bool(true, "Hide Crossed Settlements", group="Settlement Prices", tooltip="Hide settlements that price has touched/crossed (like naked POC)")
settlementRthOnly = input.bool(true, "RTH Crossing Only", group="Settlement Prices", tooltip="Only mark as crossed if touched during Regular Trading Hours (9:30 AM - 4:00 PM ET). Ignores overnight/extended hours crosses.")
settlementShowAsGapTarget = input.bool(true, "Show as Gap Close Target", group="Settlement Prices", tooltip="Display settlement labels as 'Gap Close' instead of dates. Only active when both Hide Crossed and RTH Crossing are enabled.")
settlementColor = input.color(#000000, "Weekday Color", group="Settlement Prices")
settlementFridayColor = input.color(#ff0014, "Friday/Weekend Color", group="Settlement Prices", tooltip="Separate color for Friday and weekend settlements")
settlementGapColor = input.color(#00ff00, "Gap Close / Most Recent Color", group="Settlement Prices", tooltip="Color for gap close target and most recent settlement price")
settlementLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="Settlement Prices")
settlementLineStyle = input.string("Dotted", "Line Style", options=["Solid", "Dashed", "Dotted"], group="Settlement Prices")
settlementGapLineWidth = input.int(4, "Gap Close Line Width", minval=1, maxval=5, group="Settlement Prices", tooltip="Line width for gap close target")
settlementGapLineStyle = input.string("Solid", "Gap Close Line Style", options=["Solid", "Dashed", "Dotted"], group="Settlement Prices", tooltip="Line style for gap close target")

// Key Levels (PDH/PDL, PWH/PWL, PMH/PML, PYH/PYL, ATH)
showKeyLevels = input.bool(false, "Show Key Levels", group="Key Levels", tooltip="Display Previous Day/Week/Month/Year High/Low levels and All-Time High")
showPDH = input.bool(true, "PDH", inline="PD", group="Key Levels")
showPDL = input.bool(true, "PDL", inline="PD", group="Key Levels")
colorPDH = input.color(#ffa500, "PDH", inline="PD", group="Key Levels")
colorPDL = input.color(#4169e1, "PDL", inline="PD", group="Key Levels")
showPWH = input.bool(true, "PWH", inline="PW", group="Key Levels")
showPWL = input.bool(true, "PWL", inline="PW", group="Key Levels")
colorPWH = input.color(#ff69b4, "PWH", inline="PW", group="Key Levels")
colorPWL = input.color(#9370db, "PWL", inline="PW", group="Key Levels")
showPMH = input.bool(true, "PMH", inline="PM", group="Key Levels")
showPML = input.bool(true, "PML", inline="PM", group="Key Levels")
colorPMH = input.color(#32cd32, "PMH", inline="PM", group="Key Levels")
colorPML = input.color(#dc143c, "PML", inline="PM", group="Key Levels")
showPYH = input.bool(true, "PYH", inline="PY", group="Key Levels")
showPYL = input.bool(true, "PYL", inline="PY", group="Key Levels")
colorPYH = input.color(#ffd700, "PYH", inline="PY", group="Key Levels")
colorPYL = input.color(#8b4513, "PYL", inline="PY", group="Key Levels")
showATH = input.bool(true, "ATH", inline="ATH", group="Key Levels")
colorATH = input.color(#00ff00, "ATH", inline="ATH", group="Key Levels", tooltip="All-Time High")
keyLevelsLineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="Key Levels")
keyLevelsLineStyle = input.string("Solid", "Line Style", options=["Solid", "Dashed", "Dotted"], group="Key Levels")

// Session Detection
showSessionsMode = input.string("Only Futures", "Show Session Labels", options=["Always", "Only Futures", "Off"], group="Session Detection", tooltip="Display D/W/M/Y session markers on chart")
numDailySessions = input.int(5, "Daily Sessions", minval=0, maxval=31, group="Session Detection", tooltip="Number of daily sessions to show (0 to disable)")
numWeeklySessions = input.int(2, "Weekly Sessions", minval=0, maxval=53, group="Session Detection", tooltip="Number of weekly sessions to show (0 to disable)")
numMonthlySessions = input.int(2, "Monthly Sessions", minval=0, maxval=12, group="Session Detection", tooltip="Number of monthly sessions to show (0 to disable)")
numYearlySessions = input.int(2, "Yearly Sessions", minval=0, maxval=5, group="Session Detection", tooltip="Number of yearly sessions to show (0 to disable)")
colorSessionDaily = input.color(color.new(#00b8bd, 0), "Daily Color", group="Session Detection")
colorSessionWeekly = input.color(color.new(#b51b00, 0), "Weekly Color", group="Session Detection")
colorSessionMonthly = input.color(color.new(#00fcff, 0), "Monthly Color", group="Session Detection")
colorSessionYearly = input.color(color.new(color.black, 0), "Yearly Color", group="Session Detection")

// Period Separators
showPeriodSeparators = input.bool(true, "Show Period Separators", group="Period Separators", tooltip="Automatically draw period boundary lines based on chart timeframe")
minBarsPerSegment = input.int(6, "Min Bars Per Segment", minval=1, maxval=50, group="Period Separators", tooltip="Minimum number of bars between separators - automatically selects appropriate timeframe")
separatorColor = input.color(color.gray, "Separator Color", group="Period Separators")
separatorStyle = input.string("Dotted", "Separator Style", options=["Solid", "Dashed", "Dotted"], group="Period Separators")
separatorWidth = input.int(1, "Separator Width", minval=1, maxval=5, group="Period Separators")

// Thick Bars (Hi-DPI Enhancement)
showThickBars = input.bool(true, "Show Thick Bars", group="Thick Bars", tooltip="Draw thick bars for better visibility on hi-DPI displays")
thickBarsBaseOnPrevClose = input.bool(false, "Base Color on Previous Close", group="Thick Bars", tooltip="When disabled, color is based on Open vs Close. When enabled, based on Previous Close vs Close")
thickBarsColorUp = input.color(color.black, "Up Color", group="Thick Bars")
thickBarsColorDown = input.color(color.black, "Down Color", group="Thick Bars")
thickBarsWidth = input.int(2, "Bar Width", minval=1, maxval=10, group="Thick Bars")

// Info Bar (Compact Display)
showInfoBar = input.bool(false, "Show Info Bar", group="Info Bar", tooltip="Display compact info panel with ATR and volume data")
infoBarPosition = input.string("Top Center", "Position", options=["Top Left", "Top Center", "Top Right", "Bottom Left", "Bottom Center", "Bottom Right"], group="Info Bar")
showTicker = input.bool(true, "Show Ticker", group="Info Bar", tooltip="Display ticker symbol at start of info bar")
showATR = input.bool(true, "Show ATR", group="Info Bar")
atrPeriod = input.int(20, "ATR Period (Days)", minval=1, maxval=500, group="Info Bar", tooltip="Number of days for Average True Range calculation")
riskAmount = input.float(2000, "ATR Position Size", minval=0, step=100, group="Info Bar", tooltip="Dollar risk per 1 ATR move - calculates shares/lots based on volatility")
showVolume = input.bool(true, "Show Volume", group="Info Bar")
volumePeriod = input.int(20, "Volume Period (Days)", minval=1, maxval=500, group="Info Bar", tooltip="Number of days for average volume calculation")
infoBarTextSize = input.string("Normal", "Text Size", options=["Auto", "Tiny", "Small", "Normal", "Large", "Huge"], group="Info Bar")
infoBarBgColor = input.color(color.gray, "Background Color", group="Info Bar")
infoBarTextColor = input.color(color.white, "Text Color", group="Info Bar")

// ═══════════════════════════════════════════════════════════════════════════════
// ADAPTIVE BARS PER DAY CALCULATION
// ═══════════════════════════════════════════════════════════════════════════════

// Cache timeframe checks and instrument type for performance (calculated once per bar)
int tfSeconds = timeframe.in_seconds()
bool isIntraday = timeframe.isintraday
bool isWeekly = timeframe.isweekly
bool isDaily = timeframe.isdaily
bool isMonthly = timeframe.ismonthly
bool isFutures = syminfo.type == "futures"

// Initial fallback: detect instrument type and use appropriate hours
int theoreticalSeconds = syminfo.type == "futures" ? SECONDS_FUTURES_DAY :
     syminfo.type == "crypto" ? SECONDS_CRYPTO_DAY :
     syminfo.type == "forex" ? SECONDS_FOREX_DAY :
     SECONDS_STOCK_DAY
float theoreticalBarsPerDay = isIntraday ? math.round(theoreticalSeconds / tfSeconds) : 1.0
var float barsPerDay = theoreticalBarsPerDay
var array<int> barCountsPerDay = array.new<int>()
var int dayStartBar = na
bool hasEnoughData = bar_index >= MIN_BARS_TOTAL

// ═══════════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

// Convert label size string to Pine Script size constant
getLabelSize(string sizeStr) =>
    sizeStr == "Tiny" ? size.tiny : sizeStr == "Small" ? size.small : sizeStr == "Large" ? size.large : sizeStr == "Huge" ? size.huge : size.normal

// Convert line style string to Pine Script line style constant
getLineStyle(string styleStr) =>
    styleStr == "Solid" ? line.style_solid : styleStr == "Dashed" ? line.style_dashed : line.style_dotted

// Create transparent label background color (100% transparency)
labelBgColor(color c) => color.new(c, 100)

// Currency symbol formatter
getCurrencySymbol(string curr) =>
    string _result = curr == "USD" ? "$" :
         curr == "EUR" ? "€" :
         curr == "GBP" ? "£" :
         curr == "JPY" ? "¥" :
         curr == "CNY" ? "¥" :
         curr == "CHF" ? "CHF " :
         curr == "AUD" ? "A$" :
         curr == "CAD" ? "C$" :
         curr == "NZD" ? "NZ$" :
         curr == "HKD" ? "HK$" :
         curr == "SGD" ? "S$" :
         curr == "KRW" ? "₩" :
         curr == "INR" ? "₹" :
         curr == "RUB" ? "₽" :
         curr == "BRL" ? "R$" :
         curr == "ZAR" ? "R" :
         curr == "TRY" ? "₺" :
         curr + " "
    _result

// ═══════════════════════════════════════════════════════════════════════════════
// SESSION DETECTION
// ═══════════════════════════════════════════════════════════════════════════════

// Session detection arrays
var array<int> sessionBars = array.new<int>()
var array<float> sessionHighs = array.new<float>()
var array<string> sessionTypes = array.new<string>()

// Year detection using explicit tracking (more reliable across all timeframes)
var int lastYear = na
int currentYear = year(time)
bool newYear = not na(lastYear) and currentYear != lastYear
if barstate.isconfirmed and not na(currentYear)
    lastYear := currentYear

// Detect session changes
bool newDay = timeframe.change("D") and barstate.isconfirmed
bool newWeek = timeframe.change("W") and barstate.isconfirmed
bool newMonth = timeframe.change("M") and barstate.isconfirmed

// Store sessions with highest priority: Y > M > W > D
string sessionType = newYear ? "Y" : newMonth ? "M" : newWeek ? "W" : newDay ? "D" : ""
if sessionType != ""
    array.unshift(sessionBars, bar_index)
    array.unshift(sessionHighs, high)
    array.unshift(sessionTypes, sessionType)
    // Maintain optimized buffer (reduced from 1000 for better performance)
    if array.size(sessionBars) > MAX_SESSION_BUFFER
        array.pop(sessionBars)
        array.pop(sessionHighs)
        array.pop(sessionTypes)

// Scan trading days and adapt to session changes
if newDay and not isWeekly and hasEnoughData
    if not na(dayStartBar)
        int barsInDay = bar_index - dayStartBar

        // Filter holidays, data gaps, corrupt data
        if barsInDay >= MIN_BARS_PER_DAY and barsInDay <= MAX_BARS_PER_DAY
            array.push(barCountsPerDay, barsInDay)

            // Maintain rolling window
            if array.size(barCountsPerDay) > SCAN_WINDOW
                array.shift(barCountsPerDay)

    dayStartBar := bar_index

    // Use mode of last N days
    if array.size(barCountsPerDay) >= MIN_DAYS_FOR_SCAN
        barsPerDay := array.mode(barCountsPerDay)

// ═══════════════════════════════════════════════════════════════════════════════
// SMA CALCULATIONS
// ═══════════════════════════════════════════════════════════════════════════════

// Calculate SMA periods based on actual bars per day
len5   = int(5 * barsPerDay)
len20  = int(20 * barsPerDay)
len50  = int(50 * barsPerDay)
len200 = int(200 * barsPerDay)

canShow5   = len5 > 0 and len5 <= MAX_BARS
canShow20  = len20 > 0 and len20 <= MAX_BARS
canShow50  = len50 > 0 and len50 <= MAX_BARS
canShow200 = len200 > 0 and len200 <= MAX_BARS

// Calculate SMAs unconditionally (Pine Script requirement), use guards for display
sma5   = ta.sma(close, canShow5 ? math.min(len5, MAX_BARS) : 1)
sma20  = ta.sma(close, canShow20 ? math.min(len20, MAX_BARS) : 1)
sma50  = ta.sma(close, canShow50 ? math.min(len50, MAX_BARS) : 1)
sma200 = ta.sma(close, canShow200 ? math.min(len200, MAX_BARS) : 1)

sma20w = ta.sma(close, 20)
sma31w = ta.sma(close, 31)
sma42w = ta.sma(close, 42)

// ═══════════════════════════════════════════════════════════════════════════════
// ATR & POSITION SIZE CALCULATION
// ═══════════════════════════════════════════════════════════════════════════════

// OPTIMIZED: Combine all daily timeframe requests into single call for efficiency
// Best practice: Use [1] offset with lookahead_on for non-repainting historical data
// This gives us the completed previous day's values consistently on all bars
[atrValue, avgVolume, dailyHigh, dailyLow, dailyClose] = request.security(syminfo.tickerid, "D", [ta.atr(atrPeriod)[1], ta.sma(volume, volumePeriod)[1], high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)

atrPercent = atrValue > 0 and close > 0 ? (atrValue / close) * 100 : 0
avgVolumeFormatted = showVolume and avgVolume > 0 ? avgVolume : 0

// Pivot calculations using previous day's OHLC from request.security above
float dailyRange = dailyHigh - dailyLow
float pivotP = (dailyHigh + dailyLow + dailyClose) / 3
float pivotR1 = 2 * pivotP - dailyLow
float pivotS1 = 2 * pivotP - dailyHigh
float pivotR2 = pivotP + dailyRange
float pivotS2 = pivotP - dailyRange
float pivotR3 = dailyHigh + 2 * (pivotP - dailyLow)
float pivotS3 = dailyLow - 2 * (dailyHigh - pivotP)

float calculatedShares = 0.0
float calculatedLots = 0.0
float capitalAmount = 0.0

if riskAmount > 0 and atrValue > 0
    if isFutures and syminfo.pointvalue > 0
        calculatedLots := riskAmount / (atrValue * syminfo.pointvalue)
        capitalAmount := calculatedLots * close * syminfo.pointvalue
    else
        calculatedShares := riskAmount / atrValue
        capitalAmount := calculatedShares * close

// ═══════════════════════════════════════════════════════════════════════════════
// KEY LEVELS DATA (PDH/PDL, PWH/PWL, PMH/PML, PYH/PYL, ATH)
// ═══════════════════════════════════════════════════════════════════════════════

string keyLevelsTicker = ticker.new(syminfo.prefix, syminfo.ticker, session.extended, settlement_as_close=settlement_as_close.off)

// WEEKLY, MONTHLY, YEARLY levels via request.security (works on all timeframes)
[pwh, pwl] = request.security(keyLevelsTicker, "W", [high[1], low[1]], lookahead=barmerge.lookahead_on)
[pmh, pml] = request.security(keyLevelsTicker, "M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
[pyh, pyl] = request.security(keyLevelsTicker, "12M", [high[1], low[1]], lookahead=barmerge.lookahead_on)

float ath = request.security(keyLevelsTicker, "D", ta.highest(high, bar_index + 1), lookahead=barmerge.lookahead_on)

// MANUAL TRACKING for DAILY levels (PDH/PDL)
var float prevDayHigh = na
var float prevDayLow = na
var float currentDayHigh = na
var float currentDayLow = na

// On calendar day change, save previous day values
if newDay and not na(currentDayHigh)
    prevDayHigh := currentDayHigh
    prevDayLow := currentDayLow
    currentDayHigh := high
    currentDayLow := low
else
    currentDayHigh := na(currentDayHigh) ? high : math.max(currentDayHigh, high)
    currentDayLow := na(currentDayLow) ? low : math.min(currentDayLow, low)

// Assign to standard variable names for rendering
float pdh = prevDayHigh
float pdl = prevDayLow

var line linePDH = na, var line linePDL = na, var label labelPDH = na, var label labelPDL = na
var line linePWH = na, var line linePWL = na, var label labelPWH = na, var label labelPWL = na
var line linePMH = na, var line linePML = na, var label labelPMH = na, var label labelPML = na
var line linePYH = na, var line linePYL = na, var label labelPYH = na, var label labelPYL = na
var line lineATH = na, var label labelATH = na

// Render key levels (updates every bar to extend lines to current bar_index)
// Works on all timeframes (intraday, daily, weekly)
if showKeyLevels and barstate.islast
    // Using values from request.security calls above - works on all timeframes
    int startBar = math.max(0, bar_index - globalLineLengthBars)
    string keyLevelsLineStyleActual = getLineStyle(keyLevelsLineStyle)
    string labelSizeActual = getLabelSize(globalLabelSize)

    // Track rendered prices to avoid duplicates (priority: ATH > PYH/PYL > PMH/PML > PWH/PWL > PDH/PDL)
    var array<float> renderedPrices = array.new<float>()
    array.clear(renderedPrices)

    // ATH (ABSOLUTE HIGHEST PRIORITY - always shows, blocks all duplicates)
    if showATH and not na(ath)
        string labelText = globalShowPriceValues ? "ATH (" + str.tostring(ath, format.mintick) + ")" : "ATH"
        if na(lineATH)
            lineATH := line.new(startBar, ath, bar_index, ath, color=colorATH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelATH := label.new(bar_index, ath, labelText, color=labelBgColor(colorATH), textcolor=colorATH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineATH, startBar, ath), line.set_xy2(lineATH, bar_index, ath)
            label.set_xy(labelATH, bar_index, ath), label.set_text(labelATH, labelText)
        // Add to rendered prices to block any other level at same price
        array.push(renderedPrices, ath)
    else
        // Hide line/label if not rendered
        if not na(lineATH)
            line.delete(lineATH), lineATH := na
        if not na(labelATH)
            label.delete(labelATH), labelATH := na

    // PYH (Yearly High)
    if showPYH and not na(pyh) and not array.includes(renderedPrices, pyh)
        string labelText = globalShowPriceValues ? "PYH (" + str.tostring(pyh, format.mintick) + ")" : "PYH"
        if na(linePYH)
            linePYH := line.new(startBar, pyh, bar_index, pyh, color=colorPYH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPYH := label.new(bar_index, pyh, labelText, color=labelBgColor(colorPYH), textcolor=colorPYH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePYH, startBar, pyh), line.set_xy2(linePYH, bar_index, pyh)
            label.set_xy(labelPYH, bar_index, pyh), label.set_text(labelPYH, labelText)
        array.push(renderedPrices, pyh)
    else if not na(linePYH)
        line.delete(linePYH), linePYH := na, label.delete(labelPYH), labelPYH := na

    // PYL (Yearly Low)
    if showPYL and not na(pyl) and not array.includes(renderedPrices, pyl)
        string labelText = globalShowPriceValues ? "PYL (" + str.tostring(pyl, format.mintick) + ")" : "PYL"
        if na(linePYL)
            linePYL := line.new(startBar, pyl, bar_index, pyl, color=colorPYL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPYL := label.new(bar_index, pyl, labelText, color=labelBgColor(colorPYL), textcolor=colorPYL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePYL, startBar, pyl), line.set_xy2(linePYL, bar_index, pyl)
            label.set_xy(labelPYL, bar_index, pyl), label.set_text(labelPYL, labelText)
        array.push(renderedPrices, pyl)
    else if not na(linePYL)
        line.delete(linePYL), linePYL := na, label.delete(labelPYL), labelPYL := na

    // PMH (Monthly High)
    if showPMH and not na(pmh) and not array.includes(renderedPrices, pmh)
        string labelText = globalShowPriceValues ? "PMH (" + str.tostring(pmh, format.mintick) + ")" : "PMH"
        if na(linePMH)
            linePMH := line.new(startBar, pmh, bar_index, pmh, color=colorPMH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPMH := label.new(bar_index, pmh, labelText, color=labelBgColor(colorPMH), textcolor=colorPMH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePMH, startBar, pmh), line.set_xy2(linePMH, bar_index, pmh)
            label.set_xy(labelPMH, bar_index, pmh), label.set_text(labelPMH, labelText)
        array.push(renderedPrices, pmh)
    else if not na(linePMH)
        line.delete(linePMH), linePMH := na, label.delete(labelPMH), labelPMH := na

    // PML (Monthly Low)
    if showPML and not na(pml) and not array.includes(renderedPrices, pml)
        string labelText = globalShowPriceValues ? "PML (" + str.tostring(pml, format.mintick) + ")" : "PML"
        if na(linePML)
            linePML := line.new(startBar, pml, bar_index, pml, color=colorPML, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPML := label.new(bar_index, pml, labelText, color=labelBgColor(colorPML), textcolor=colorPML, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePML, startBar, pml), line.set_xy2(linePML, bar_index, pml)
            label.set_xy(labelPML, bar_index, pml), label.set_text(labelPML, labelText)
        array.push(renderedPrices, pml)
    else if not na(linePML)
        line.delete(linePML), linePML := na, label.delete(labelPML), labelPML := na

    // PWH (Weekly High)
    if showPWH and not na(pwh) and not array.includes(renderedPrices, pwh)
        string labelText = globalShowPriceValues ? "PWH (" + str.tostring(pwh, format.mintick) + ")" : "PWH"
        if na(linePWH)
            linePWH := line.new(startBar, pwh, bar_index, pwh, color=colorPWH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPWH := label.new(bar_index, pwh, labelText, color=labelBgColor(colorPWH), textcolor=colorPWH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePWH, startBar, pwh), line.set_xy2(linePWH, bar_index, pwh)
            label.set_xy(labelPWH, bar_index, pwh), label.set_text(labelPWH, labelText)
        array.push(renderedPrices, pwh)
    else if not na(linePWH)
        line.delete(linePWH), linePWH := na, label.delete(labelPWH), labelPWH := na

    // PWL (Weekly Low)
    if showPWL and not na(pwl) and not array.includes(renderedPrices, pwl)
        string labelText = globalShowPriceValues ? "PWL (" + str.tostring(pwl, format.mintick) + ")" : "PWL"
        if na(linePWL)
            linePWL := line.new(startBar, pwl, bar_index, pwl, color=colorPWL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPWL := label.new(bar_index, pwl, labelText, color=labelBgColor(colorPWL), textcolor=colorPWL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePWL, startBar, pwl), line.set_xy2(linePWL, bar_index, pwl)
            label.set_xy(labelPWL, bar_index, pwl), label.set_text(labelPWL, labelText)
        array.push(renderedPrices, pwl)
    else if not na(linePWL)
        line.delete(linePWL), linePWL := na, label.delete(labelPWL), labelPWL := na

    // PDH (Daily High)
    if showPDH and not na(pdh) and not array.includes(renderedPrices, pdh)
        string labelText = globalShowPriceValues ? "PDH (" + str.tostring(pdh, format.mintick) + ")" : "PDH"
        if na(linePDH)
            linePDH := line.new(startBar, pdh, bar_index, pdh, color=colorPDH, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPDH := label.new(bar_index, pdh, labelText, color=labelBgColor(colorPDH), textcolor=colorPDH, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePDH, startBar, pdh), line.set_xy2(linePDH, bar_index, pdh)
            label.set_xy(labelPDH, bar_index, pdh), label.set_text(labelPDH, labelText)
        array.push(renderedPrices, pdh)
    else if not na(linePDH)
        line.delete(linePDH), linePDH := na, label.delete(labelPDH), labelPDH := na

    // PDL (Daily Low)
    if showPDL and not na(pdl) and not array.includes(renderedPrices, pdl)
        string labelText = globalShowPriceValues ? "PDL (" + str.tostring(pdl, format.mintick) + ")" : "PDL"
        if na(linePDL)
            linePDL := line.new(startBar, pdl, bar_index, pdl, color=colorPDL, width=keyLevelsLineWidth, style=keyLevelsLineStyleActual)
            labelPDL := label.new(bar_index, pdl, labelText, color=labelBgColor(colorPDL), textcolor=colorPDL, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(linePDL, startBar, pdl), line.set_xy2(linePDL, bar_index, pdl)
            label.set_xy(labelPDL, bar_index, pdl), label.set_text(labelPDL, labelText)
        array.push(renderedPrices, pdl)
    else if not na(linePDL)
        line.delete(linePDL), linePDL := na, label.delete(labelPDL), labelPDL := na

// ═══════════════════════════════════════════════════════════════════════════════
// DISPLAY CONDITIONS & SHADING
// ═══════════════════════════════════════════════════════════════════════════════

// Daily SMA display conditions
show5   = not isWeekly and isIntraday and canShow5 and bar_index >= len5 - 1
show20  = not isWeekly and canShow20 and bar_index >= len20 - 1
show50  = not isWeekly and canShow50 and bar_index >= len50 - 1
show200 = not isWeekly and canShow200 and bar_index >= len200 - 1

// Determine shading color based on trend (5-day SMA only)
canShade = show5 and not na(sma5[1])
bool isBullish = canShade and close > sma5 and sma5 > sma5[1]
bool isBearish = canShade and close <= sma5 and sma5 <= sma5[1]
bool isTransition = canShade and not isBullish and not isBearish
color baseColor = isBullish ? shadeBullishColor : isBearish ? shadeBearishColor : isTransition ? shadeTransitionColor : na

// ═══════════════════════════════════════════════════════════════════════════════
// PLOTS - DAILY SMAs
// ═══════════════════════════════════════════════════════════════════════════════

p5   = plot(show5 ? sma5 : na, "5-Day SMA", COL_SMA5, 2)
p20  = plot(show20 ? sma20 : na, "20-Day SMA", COL_SMA20, 2)
p50  = plot(show50 ? sma50 : na, "50-Day SMA", COL_SMA50, 2)
p200 = plot(show200 ? sma200 : na, "200-Day SMA", COL_SMA200, 2)

// ═══════════════════════════════════════════════════════════════════════════════
// PLOTS - WEEKLY SMAs
// ═══════════════════════════════════════════════════════════════════════════════

plot(isWeekly and bar_index >= 19 ? sma20w : na, "20W SMA", COL_SMA20W, 2)
plot(isWeekly and bar_index >= 30 ? sma31w : na, "31W SMA", COL_SMA31W, 2)
plot(isWeekly and bar_index >= 41 ? sma42w : na, "42W SMA", COL_SMA42W, 2)

// ═══════════════════════════════════════════════════════════════════════════════
// SHADING & START LINES
// ═══════════════════════════════════════════════════════════════════════════════

pClose = plot(close, display=display.none, editable=false)

// Prepare shading fill parameters based on mode
color flatColor = na
color gradientColorTop = na
color gradientColorBottom = na
float gradientTop = na
float gradientBottom = na

if canShade and not na(baseColor) and shadingMode != "None"
    if shadingMode == "Gradient"
        // Gradient mode: shadow fades from bar toward SMA direction
        float shadowDistance = close * (shadowLengthPercent / 100)
        bool aboveSMA = close > sma5

        if aboveSMA
            gradientTop := close
            gradientBottom := close - shadowDistance
            gradientColorTop := baseColor
            gradientColorBottom := color.new(color.rgb(color.r(baseColor), color.g(baseColor), color.b(baseColor)), gradientMaxAlpha)
        else
            gradientTop := close + shadowDistance
            gradientBottom := close
            gradientColorTop := color.new(color.rgb(color.r(baseColor), color.g(baseColor), color.b(baseColor)), gradientMaxAlpha)
            gradientColorBottom := baseColor
    else
        // Flat mode: uniform color between close and SMA
        flatColor := baseColor

// Render fills (only one will be active based on non-na values)
fill(pClose, p5, gradientTop, gradientBottom, gradientColorTop, gradientColorBottom, title="5-Day SMA Gradient")
fill(pClose, p5, flatColor, title="5-Day SMA Flat")

var line startLine5 = na
if barstate.islast and show5 and show5StartLineInput and na(startLine5)
    startBar = bar_index - len5 + 1
    if startBar >= 0
        startLine5 := line.new(startBar, low[len5 - 1], startBar, high[len5 - 1],
             extend=extend.both, color=COL_SMA5, style=getLineStyle(startLineStyle5Input), width=2)

var line startLine50 = na
if barstate.islast and show50 and show50StartLineInput and na(startLine50)
    startBar = bar_index - len50 + 1
    if startBar >= 0
        startLine50 := line.new(startBar, low[len50 - 1], startBar, high[len50 - 1],
             extend=extend.both, color=COL_SMA50, style=getLineStyle(startLineStyle50Input), width=2)

var line startLine200 = na
if barstate.islast and show200 and show200StartLineInput and na(startLine200)
    startBar = bar_index - len200 + 1
    if startBar >= 0
        startLine200 := line.new(startBar, low[len200 - 1], startBar, high[len200 - 1],
             extend=extend.both, color=COL_SMA200, style=getLineStyle(startLineStyle200Input), width=2)

// ═══════════════════════════════════════════════════════════════════════════════
// INFO BAR DISPLAY
// ═══════════════════════════════════════════════════════════════════════════════

if showInfoBar and barstate.islast
    pos = infoBarPosition == "Top Left" ? position.top_left :
          infoBarPosition == "Top Center" ? position.top_center :
          infoBarPosition == "Top Right" ? position.top_right :
          infoBarPosition == "Bottom Left" ? position.bottom_left :
          infoBarPosition == "Bottom Center" ? position.bottom_center :
          position.bottom_right

    txtSize = infoBarTextSize == "Auto" ? size.auto :
              infoBarTextSize == "Tiny" ? size.tiny :
              infoBarTextSize == "Small" ? size.small :
              infoBarTextSize == "Normal" ? size.normal :
              infoBarTextSize == "Large" ? size.large :
              size.huge

    var table infoTable = table.new(pos, 1, 1, frame_width = 1, frame_color = color.gray)
    table.clear(infoTable, 0, 0, 0, 0)

    string infoText = ""

    if showTicker
        infoText := syminfo.ticker

    if showATR
        string atrText = atrValue > 0 ?
             "ATR(" + str.tostring(atrPeriod) + "): " + str.tostring(atrPercent, "0.0") + "%" :
             "ATR(" + str.tostring(atrPeriod) + "): N/A"

        if riskAmount > 0 and atrValue > 0
            currSymbol = getCurrencySymbol(syminfo.currency)
            positionText = isFutures and calculatedLots > 0 ?
                 str.tostring(calculatedLots, "0.0") + " lots (" + currSymbol + str.tostring(capitalAmount, "#,###") + ")" :
                 not isFutures and calculatedShares > 0 ?
                 str.tostring(math.round(calculatedShares), "#,###") + " shares (" + currSymbol + str.tostring(capitalAmount, "#,###") + ")" :
                 "N/A"
            atrText := atrText + " | 1 ATR = " + currSymbol + str.tostring(riskAmount, "#,###") + " → " + positionText

        infoText := infoText == "" ? atrText : infoText + " | " + atrText

    if showVolume and avgVolumeFormatted > 0
        string volumeText = "Avg Vol(" + str.tostring(volumePeriod) + "): " + str.tostring(avgVolumeFormatted / 1000000, "#.##") + "M"
        infoText := infoText == "" ? volumeText : infoText + " | " + volumeText

    if infoText != ""
        table.cell(infoTable, 0, 0, infoText, text_color = infoBarTextColor, bgcolor = infoBarBgColor, text_size = txtSize)

// ═══════════════════════════════════════════════════════════════════════════════
// PIVOT POINTS DISPLAY
// ═══════════════════════════════════════════════════════════════════════════════

// Convert style inputs once
string lineStyleActual = getLineStyle(pivotLineStyle)
string labelSizeActual = getLabelSize(globalLabelSize)

// Store pivot lines and labels
var line lineP = na, var line lineR1 = na, var line lineR2 = na, var line lineR3 = na
var line lineS1 = na, var line lineS2 = na, var line lineS3 = na
var label labelP = na, var label labelR1 = na, var label labelR2 = na, var label labelR3 = na
var label labelS1 = na, var label labelS2 = na, var label labelS3 = na

// Draw/update pivot levels (always span from start of current day)
// Note: Updates on every bar to extend lines to current bar_index (intentional for real-time tracking)
if showPivots and (not pivotIntradayOnly or timeframe.isintraday) and not na(dayStartBar)
    int startBar = dayStartBar

    // P Level
    if showPivotP and not na(pivotP)
        string labelTextP = globalShowPriceValues ? "P (" + str.tostring(pivotP, format.mintick) + ")" : "P"
        if na(lineP)
            lineP := line.new(startBar, pivotP, bar_index, pivotP, color=pivotColorP, width=pivotLineWidth, style=lineStyleActual)
            labelP := label.new(bar_index, pivotP, labelTextP, color=labelBgColor(pivotColorP), textcolor=pivotColorP, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineP, startBar, pivotP), line.set_xy2(lineP, bar_index, pivotP)
            label.set_xy(labelP, bar_index, pivotP), label.set_text(labelP, labelTextP)

    // R1 Level
    if showPivotR1 and not na(pivotR1)
        string labelTextR1 = globalShowPriceValues ? "R1 (" + str.tostring(pivotR1, format.mintick) + ")" : "R1"
        if na(lineR1)
            lineR1 := line.new(startBar, pivotR1, bar_index, pivotR1, color=pivotColorR1, width=pivotLineWidth, style=lineStyleActual)
            labelR1 := label.new(bar_index, pivotR1, labelTextR1, color=labelBgColor(pivotColorR1), textcolor=pivotColorR1, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineR1, startBar, pivotR1), line.set_xy2(lineR1, bar_index, pivotR1)
            label.set_xy(labelR1, bar_index, pivotR1), label.set_text(labelR1, labelTextR1)

    // R2 Level
    if showPivotR2 and not na(pivotR2)
        string labelTextR2 = globalShowPriceValues ? "R2 (" + str.tostring(pivotR2, format.mintick) + ")" : "R2"
        if na(lineR2)
            lineR2 := line.new(startBar, pivotR2, bar_index, pivotR2, color=pivotColorR2, width=pivotLineWidth, style=lineStyleActual)
            labelR2 := label.new(bar_index, pivotR2, labelTextR2, color=labelBgColor(pivotColorR2), textcolor=pivotColorR2, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineR2, startBar, pivotR2), line.set_xy2(lineR2, bar_index, pivotR2)
            label.set_xy(labelR2, bar_index, pivotR2), label.set_text(labelR2, labelTextR2)

    // R3 Level
    if showPivotR3 and not na(pivotR3)
        string labelTextR3 = globalShowPriceValues ? "R3 (" + str.tostring(pivotR3, format.mintick) + ")" : "R3"
        if na(lineR3)
            lineR3 := line.new(startBar, pivotR3, bar_index, pivotR3, color=pivotColorR3, width=pivotLineWidth, style=lineStyleActual)
            labelR3 := label.new(bar_index, pivotR3, labelTextR3, color=labelBgColor(pivotColorR3), textcolor=pivotColorR3, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineR3, startBar, pivotR3), line.set_xy2(lineR3, bar_index, pivotR3)
            label.set_xy(labelR3, bar_index, pivotR3), label.set_text(labelR3, labelTextR3)

    // S1 Level
    if showPivotS1 and not na(pivotS1)
        string labelTextS1 = globalShowPriceValues ? "S1 (" + str.tostring(pivotS1, format.mintick) + ")" : "S1"
        if na(lineS1)
            lineS1 := line.new(startBar, pivotS1, bar_index, pivotS1, color=pivotColorS1, width=pivotLineWidth, style=lineStyleActual)
            labelS1 := label.new(bar_index, pivotS1, labelTextS1, color=labelBgColor(pivotColorS1), textcolor=pivotColorS1, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineS1, startBar, pivotS1), line.set_xy2(lineS1, bar_index, pivotS1)
            label.set_xy(labelS1, bar_index, pivotS1), label.set_text(labelS1, labelTextS1)

    // S2 Level
    if showPivotS2 and not na(pivotS2)
        string labelTextS2 = globalShowPriceValues ? "S2 (" + str.tostring(pivotS2, format.mintick) + ")" : "S2"
        if na(lineS2)
            lineS2 := line.new(startBar, pivotS2, bar_index, pivotS2, color=pivotColorS2, width=pivotLineWidth, style=lineStyleActual)
            labelS2 := label.new(bar_index, pivotS2, labelTextS2, color=labelBgColor(pivotColorS2), textcolor=pivotColorS2, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineS2, startBar, pivotS2), line.set_xy2(lineS2, bar_index, pivotS2)
            label.set_xy(labelS2, bar_index, pivotS2), label.set_text(labelS2, labelTextS2)

    // S3 Level
    if showPivotS3 and not na(pivotS3)
        string labelTextS3 = globalShowPriceValues ? "S3 (" + str.tostring(pivotS3, format.mintick) + ")" : "S3"
        if na(lineS3)
            lineS3 := line.new(startBar, pivotS3, bar_index, pivotS3, color=pivotColorS3, width=pivotLineWidth, style=lineStyleActual)
            labelS3 := label.new(bar_index, pivotS3, labelTextS3, color=labelBgColor(pivotColorS3), textcolor=pivotColorS3, style=label.style_label_left, size=labelSizeActual)
        else
            line.set_xy1(lineS3, startBar, pivotS3), line.set_xy2(lineS3, bar_index, pivotS3)
            label.set_xy(labelS3, bar_index, pivotS3), label.set_text(labelS3, labelTextS3)

// ═══════════════════════════════════════════════════════════════════════════════
// SETTLEMENT PRICES DISPLAY (FUTURES ONLY)
// ═══════════════════════════════════════════════════════════════════════════════

// Convert style inputs once
string settlementLineStyleActual = getLineStyle(settlementLineStyle)
string settlementLabelSizeActual = getLabelSize(globalLabelSize)

// Only show for futures and optionally only on intraday timeframes
bool showSettlementsCondition = showSettlements and isFutures and (not settlementIntradayOnly or isIntraday)

// Store settlement data in arrays
var array<float> settlementPrices = array.new<float>()
var array<color> settlementColors = array.new<color>()
var array<string> settlementDateLabels = array.new<string>()
var array<bool> settlementCrossed = array.new<bool>()

// Store settlement lines and labels (persistent objects)
var array<line> settlementLines = array.new<line>()
var array<label> settlementLabels = array.new<label>()

// Collect settlement data on each daily bar
if showSettlementsCondition and timeframe.change("D") and barstate.isconfirmed
    // Maintain rolling window of last N settlements
    if array.size(settlementPrices) >= settlementCount
        array.shift(settlementPrices), array.shift(settlementColors)
        array.shift(settlementDateLabels), array.shift(settlementCrossed)

        // Also shift and delete oldest line/label
        line oldLine = array.shift(settlementLines)
        label oldLabel = array.shift(settlementLabels)
        if not na(oldLine)
            line.delete(oldLine)
        if not na(oldLabel)
            label.delete(oldLabel)

    // OPTIMIZED: Settlement data - consistent with other historical data requests
    // Use [1] offset with lookahead_on for non-repainting completed settlement values
    // Settlement ticker modifier ensures we get official settlement prices for futures
    string settlementTicker = ticker.new(syminfo.prefix, syminfo.ticker, syminfo.session, settlement_as_close=settlement_as_close.on)
    [settlementPrice, settlementTime] = request.security(settlementTicker, "D", [close[1], time[1]], lookahead=barmerge.lookahead_on)

    if not na(settlementPrice)
        // Calculate label timestamp and determine line color
        int labelTimestamp = settlementTime + MS_PER_DAY
        int dayOfWeek = dayofweek(labelTimestamp, syminfo.timezone)
        bool isFridayOrWeekend = dayOfWeek == dayofweek.friday or dayOfWeek == dayofweek.saturday or dayOfWeek == dayofweek.sunday
        color lineColor = isFridayOrWeekend ? settlementFridayColor : settlementColor

        // Store data for rendering (crossed detection happens at render time, not collection time)
        array.push(settlementPrices, settlementPrice)
        array.push(settlementColors, lineColor)
        array.push(settlementDateLabels, str.format_time(labelTimestamp, "EEE MMM dd", syminfo.timezone))
        array.push(settlementCrossed, false)  // Will be updated at render time

        // Push placeholder for new line/label (will be created at render time)
        array.push(settlementLines, na)
        array.push(settlementLabels, na)

// Update crossed status only on confirmed bars (optimize performance)
if showSettlementsCondition and barstate.isconfirmed and array.size(settlementPrices) > 0
    // Check if current time is within RTH (9:30 AM - 4:00 PM ET)
    int hourOfDay = hour(time, "America/New_York")
    int minuteOfDay = minute(time, "America/New_York")
    int currentMinutes = hourOfDay * 60 + minuteOfDay
    bool isRth = currentMinutes >= RTH_START_MINUTES and currentMinutes < RTH_END_MINUTES

    for i = 0 to array.size(settlementPrices) - 1
        if not array.get(settlementCrossed, i)  // Only check uncrossed settlements
            float price = array.get(settlementPrices, i)
            // Only mark as crossed if: price touched AND (RTH-only is disabled OR currently in RTH)
            if not na(price) and low <= price and high >= price and (not settlementRthOnly or isRth)
                array.set(settlementCrossed, i, true)

// Render settlement lines on last bar only
bool shouldRenderSettlements = showSettlementsCondition and barstate.islast and array.size(settlementPrices) > 0

// Render/update settlements on last bar
if shouldRenderSettlements
    int startDrawBar = math.max(0, bar_index - globalLineLengthBars)

    // Render each settlement line/label
    for i = 0 to array.size(settlementPrices) - 1
        float price = array.get(settlementPrices, i)
        if na(price)
            continue

        // Apply visibility filters
        bool wasCrossed = array.get(settlementCrossed, i)
        float distanceInTicks = syminfo.mintick > 0 ? math.abs(price - close) / syminfo.mintick : 0
        bool isWithinDistance = not settlementDistanceFilter or distanceInTicks <= settlementMaxDistance
        bool shouldBeVisible = not (settlementHideCrossed and wasCrossed) and isWithinDistance

        line existingLine = array.get(settlementLines, i)
        label existingLabel = array.get(settlementLabels, i)

        if shouldBeVisible
            // Use special color for most recent settlement (last in array = most recent)
            bool isMostRecent = i == (array.size(settlementPrices) - 1)
            bool isGapClose = settlementShowAsGapTarget and settlementHideCrossed and settlementRthOnly and isMostRecent

            // Determine styling based on whether it's gap close or regular settlement
            color lineColor = isGapClose ? settlementGapColor : (isMostRecent ? settlementGapColor : array.get(settlementColors, i))
            int lineWidth = isGapClose ? settlementGapLineWidth : settlementLineWidth
            string lineStyleUsed = isGapClose ? getLineStyle(settlementGapLineStyle) : settlementLineStyleActual

            // Determine label text: show "Gap Close" only for most recent, dates for others
            string settlementLabelText = ""
            if isGapClose
                // Only most recent settlement shows as "Gap Close"
                settlementLabelText := globalShowPriceValues ? "Gap Close (" + str.tostring(price, format.mintick) + ")" : "Gap Close"
            else
                // All others show date
                settlementLabelText := globalShowPriceValues ? array.get(settlementDateLabels, i) + " (" + str.tostring(price, format.mintick) + ")" : array.get(settlementDateLabels, i)

            // Create or update line and label
            if na(existingLine)
                // Create new
                array.set(settlementLines, i, line.new(startDrawBar, price, bar_index, price,
                     color=lineColor, width=lineWidth, style=lineStyleUsed))
                array.set(settlementLabels, i, label.new(bar_index, price, settlementLabelText,
                     color=labelBgColor(lineColor), textcolor=lineColor,
                     style=label.style_label_left, size=settlementLabelSizeActual))
            else
                // Update existing
                line.set_xy1(existingLine, startDrawBar, price)
                line.set_xy2(existingLine, bar_index, price)
                line.set_color(existingLine, lineColor)
                line.set_width(existingLine, lineWidth)
                line.set_style(existingLine, lineStyleUsed)
                if not na(existingLabel)
                    label.set_xy(existingLabel, bar_index, price)
                    label.set_text(existingLabel, settlementLabelText)
                    label.set_textcolor(existingLabel, lineColor)
                    label.set_color(existingLabel, labelBgColor(lineColor))
                else
                    // Recreate label if it was deleted
                    array.set(settlementLabels, i, label.new(bar_index, price, settlementLabelText,
                         color=labelBgColor(lineColor), textcolor=lineColor,
                         style=label.style_label_left, size=settlementLabelSizeActual))
        else
            // Hide line/label if not visible
            if not na(existingLine)
                line.delete(existingLine)
                array.set(settlementLines, i, na)
            if not na(existingLabel)
                label.delete(existingLabel)
                array.set(settlementLabels, i, na)

// ═══════════════════════════════════════════════════════════════════════════════
// SESSION DETECTION LABELS
// ═══════════════════════════════════════════════════════════════════════════════

// Determine if session labels should be shown based on mode
bool showSessionsCondition = showSessionsMode == "Always" or (showSessionsMode == "Only Futures" and syminfo.type == "futures")

if showSessionsCondition and barstate.islast
    // Determine current timeframe constraints (use cached values)
    bool isDailyOrHigher = isDaily or isWeekly or isMonthly
    bool isWeeklyOrHigher = isWeekly or isMonthly
    bool isMonthlyOrHigher = isMonthly

    // Counters: all counters are hierarchical (track actual timeframe progression)
    int dailyCounter = 0, weeklyCounter = 0, monthlyCounter = 0, yearlyCounter = 0

    // Validate arrays and cache sizes
    int arraySize = array.size(sessionBars)
    if arraySize > 0 and arraySize == array.size(sessionTypes) and arraySize == array.size(sessionHighs)
        for i = 0 to arraySize - 1
            // Early exit when all counters exceed limits
            if (numDailySessions == 0 or isDailyOrHigher or dailyCounter > numDailySessions) and
               (numWeeklySessions == 0 or isWeeklyOrHigher or weeklyCounter > numWeeklySessions) and
               (numMonthlySessions == 0 or isMonthlyOrHigher or monthlyCounter > numMonthlySessions) and
               (numYearlySessions == 0 or yearlyCounter > numYearlySessions)
                break

            string sType = array.get(sessionTypes, i)
            int barIdx = array.get(sessionBars, i)

            // Skip bars beyond buffer
            if bar_index - barIdx > 4999
                continue

            // Increment counters hierarchically (Y increments all, M increments M/W/D, W increments W/D, D increments D)
            dailyCounter += 1
            if sType == "W" or sType == "M" or sType == "Y"
                weeklyCounter += 1
            if sType == "M" or sType == "Y"
                monthlyCounter += 1
            if sType == "Y"
                yearlyCounter += 1

            // Determine display properties (highest priority wins)
            int displayCounter = sType == "Y" ? yearlyCounter : sType == "M" ? monthlyCounter : sType == "W" ? weeklyCounter : dailyCounter
            color labelColor = sType == "Y" ? colorSessionYearly : sType == "M" ? colorSessionMonthly : sType == "W" ? colorSessionWeekly : colorSessionDaily

            // Check display conditions (all use counter-based limits)
            bool shouldShow = false
            if sType == "Y" and numYearlySessions > 0 and yearlyCounter <= numYearlySessions
                shouldShow := true
            else if sType == "M" and numMonthlySessions > 0 and monthlyCounter <= numMonthlySessions and not isMonthlyOrHigher
                shouldShow := true
            else if sType == "W" and numWeeklySessions > 0 and weeklyCounter <= numWeeklySessions and not isWeeklyOrHigher
                shouldShow := true
            else if sType == "D" and numDailySessions > 0 and dailyCounter <= numDailySessions and not isDailyOrHigher
                shouldShow := true

            // Create label
            if shouldShow
                label.new(barIdx, array.get(sessionHighs, i), sType + str.tostring(displayCounter),
                         style=label.style_label_down, color=labelColor, textcolor=color.white, size=size.small)

// ═══════════════════════════════════════════════════════════════════════════════
// DYNAMIC PERIOD SEPARATORS (LOWEST PRIORITY - AFTER THICK BARS)
// ═══════════════════════════════════════════════════════════════════════════════

if showPeriodSeparators
    // Calculate bars per timeframe unit based on current chart timeframe
    float barsPerMinute = tfSeconds < 60 ? 60.0 / tfSeconds : na
    float barsPerHour = tfSeconds < 3600 ? 3600.0 / tfSeconds : na

    // For daily/weekly/monthly charts, use direct bar calculations
    float barsPerWeek = na
    float barsPerMonth = na
    float barsPerYear = na

    if isMonthly
        barsPerYear := 12.0
        barsPerMonth := 1.0
    else if isWeekly
        barsPerMonth := 4.3
        barsPerYear := 52.0
    else if isDaily
        barsPerMonth := 21.0
        barsPerYear := 252.0
    else if barsPerDay > 0
        // On intraday charts: use barsPerDay calculation
        barsPerWeek := barsPerDay * 5
        barsPerMonth := barsPerDay * 21
        barsPerYear := barsPerDay * 252

    // Determine which timeframe to use (smallest to largest)
    string separatorTimeframe =
         not na(barsPerMinute) and barsPerMinute >= minBarsPerSegment ? "1" :
         not na(barsPerHour) and barsPerHour >= minBarsPerSegment ? "60" :
         not na(barsPerDay) and barsPerDay >= minBarsPerSegment ? "D" :
         not na(barsPerWeek) and barsPerWeek >= minBarsPerSegment ? "W" :
         not na(barsPerMonth) and barsPerMonth >= minBarsPerSegment ? "M" : "12M"

    // Draw separator on timeframe boundary
    if timeframe.change(separatorTimeframe)
        string separatorLineStyle = getLineStyle(separatorStyle)
        line.new(bar_index, high, bar_index, low,
             extend=extend.both, color=separatorColor, style=separatorLineStyle, width=separatorWidth)

// ═══════════════════════════════════════════════════════════════════════════════
// THICK BARS DISPLAY (HI-DPI READABILITY - LOWEST PRIORITY)
// ═══════════════════════════════════════════════════════════════════════════════

if showThickBars
    int keyLevelsCount = showKeyLevels ? ((showPDH ? 1 : 0) + (showPDL ? 1 : 0) + (showPWH ? 1 : 0) + (showPWL ? 1 : 0) + (showPMH ? 1 : 0) + (showPML ? 1 : 0) + (showPYH ? 1 : 0) + (showPYL ? 1 : 0) + (showATH ? 1 : 0)) : 0
    int periodSeparatorEstimate = showPeriodSeparators ? 50 : 0  // Conservative estimate for period separator lines
    int sessionLabelEstimate = (numDailySessions + numWeeklySessions + numMonthlySessions + numYearlySessions)
    int safetyBuffer = 20  // Extra buffer for labels and other small objects
    int reservedLines = ((show5StartLineInput or show50StartLineInput or show200StartLineInput) ? 3 : 0) + (showPivots ? 7 : 0) + (showSettlements and isFutures ? settlementCount : 0) + keyLevelsCount + periodSeparatorEstimate + sessionLabelEstimate + safetyBuffer
    int barsFromEnd = last_bar_index - bar_index

    if barsFromEnd < (500 - reservedLines)
        color barColor = thickBarsBaseOnPrevClose ?
             (bar_index > 0 and close >= close[1] ? thickBarsColorUp : close < close[1] ? thickBarsColorDown : close >= open ? thickBarsColorUp : thickBarsColorDown) :
             (close >= open ? thickBarsColorUp : thickBarsColorDown)
        line.new(bar_index, high, bar_index, low, width=thickBarsWidth, color=barColor, xloc=xloc.bar_index)
